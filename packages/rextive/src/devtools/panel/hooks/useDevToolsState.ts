/**
 * Hook for managing DevTools state (signals, tags, events, etc.)
 */

import { useState, useEffect, useRef } from "react";
import {
  isDevToolsEnabled,
  getSignals,
  getTags,
  getStats,
  onDevToolsEvent,
  enableChainTracking,
  disableChainTracking,
} from "@/devtools/index";
import type {
  SignalInfo,
  TagInfo,
  DevToolsEvent,
  ChainReaction,
} from "@/devtools/types";

const BOOKMARKS_STORAGE_KEY = "rextive-devtools-bookmarks";

type EventLogEntry = DevToolsEvent & {
  id: number;
  timestamp: number;
  isError?: boolean;
};

export function useDevToolsState() {
  const [signals, setSignals] = useState<Map<string, SignalInfo>>(new Map());
  const [tags, setTags] = useState<Map<string, TagInfo>>(new Map());
  const [events, setEvents] = useState<EventLogEntry[]>([]);
  const [stats, setStats] = useState({
    signalCount: 0,
    mutableCount: 0,
    computedCount: 0,
    tagCount: 0,
    totalChanges: 0,
    totalErrors: 0,
    signalsWithErrors: 0,
    disposedCount: 0,
  });
  const [enabled, setEnabled] = useState(false);
  const [chains, setChains] = useState<ChainReaction[]>([]);

  const [bookmarkedSignals, setBookmarkedSignals] = useState<Set<string>>(
    () => {
      try {
        const saved = localStorage.getItem(BOOKMARKS_STORAGE_KEY);
        if (saved) {
          return new Set(JSON.parse(saved));
        }
      } catch {
        // Ignore localStorage errors
      }
      return new Set<string>();
    }
  );

  const eventIdRef = useRef(0);
  const flashTimeoutsRef = useRef<Map<string, NodeJS.Timeout>>(new Map());
  const showAutoGeneratedRef = useRef(false);

  // Check if devtools is enabled
  useEffect(() => {
    const checkEnabled = () => {
      const isEnabled = isDevToolsEnabled();
      setEnabled(isEnabled);
      if (!isEnabled) {
        console.warn("[rextive/devtools] DevTools is not enabled. Call enableDevTools() before creating signals.");
      }
    };

    checkEnabled();
    const interval = setInterval(checkEnabled, 1000);
    return () => clearInterval(interval);
  }, []);

  // Refresh data periodically when enabled
  useEffect(() => {
    if (!enabled) {
      console.log("[rextive/devtools] Panel refresh disabled - DevTools not enabled");
      return;
    }

    const refresh = () => {
      const signalsMap = new Map(getSignals());
      const tagsMap = new Map(getTags());
      const statsData = getStats();
      
      if (signalsMap.size === 0 && tagsMap.size === 0) {
        console.log("[rextive/devtools] No signals or tags found. Make sure enableDevTools() is called before creating signals.");
      }
      
      setSignals(signalsMap);
      setTags(tagsMap);
      setStats(statsData);
    };

    refresh();
    const interval = setInterval(refresh, 500);
    return () => clearInterval(interval);
  }, [enabled]);

  // Subscribe to events
  useEffect(() => {
    if (!enabled) return;

    const unsubscribe = onDevToolsEvent((event) => {
      // Handle signals:forget - remove all events related to forgotten signals
      if (event.type === "signals:forget") {
        const forgottenIds = new Set(event.signalIds);
        setEvents((prev) =>
          prev.filter((e) => {
            // Filter out events related to forgotten signals
            if ("signalId" in e && forgottenIds.has(e.signalId)) return false;
            if ("signal" in e && forgottenIds.has(e.signal.id)) return false;
            return true;
          })
        );
        // Also update signals state to remove forgotten signals
        setSignals((prev) => {
          const next = new Map(prev);
          for (const id of forgottenIds) {
            next.delete(id);
          }
          return next;
        });
        return; // Don't log this event
      }

      // Check if this is an error event
      let isError = false;
      if (event.type === "signal:error") {
        // Explicit error event
        isError = true;
      } else if (event.type === "window:error" || event.type === "window:unhandledrejection") {
        // Window error events
        isError = true;
      } else if (event.type === "signal:change" && "signalId" in event) {
        // Change event where signal has error
        const signalInfo = getSignals().get(event.signalId);
        if (signalInfo?.signal?.error?.()) {
          isError = true;
        }
      }

      const entry: EventLogEntry = {
        ...event,
        id: eventIdRef.current++,
        timestamp: Date.now(),
        isError,
      };
      setEvents((prev) => [entry, ...prev].slice(0, 100));
    });

    return () => {
      unsubscribe();
      flashTimeoutsRef.current.forEach((timeout) => clearTimeout(timeout));
      flashTimeoutsRef.current.clear();
    };
  }, [enabled]);

  // Toggle bookmark
  const toggleBookmark = (signalId: string) => {
    setBookmarkedSignals((prev) => {
      const next = new Set(prev);
      if (next.has(signalId)) {
        next.delete(signalId);
      } else {
        next.add(signalId);
      }
      // Persist to localStorage
      try {
        localStorage.setItem(
          BOOKMARKS_STORAGE_KEY,
          JSON.stringify(Array.from(next))
        );
      } catch {
        // Ignore localStorage errors
      }
      return next;
    });
  };

  return {
    signals,
    tags,
    events,
    stats,
    enabled,
    chains,
    bookmarkedSignals,
    showAutoGeneratedRef,
    eventIdRef,
    flashTimeoutsRef,
    setSignals,
    setTags,
    setEvents,
    setStats,
    setChains,
    toggleBookmark,
  };
}

/**
 * Hook for chain tracking - enable only when chains tab is active
 */
export function useChainTracking(
  activeTab: string,
  enabled: boolean,
  refreshChains: () => void
) {
  useEffect(() => {
    if (activeTab === "chains" && enabled) {
      enableChainTracking();
      // Refresh chains periodically
      const interval = setInterval(() => {
        refreshChains();
      }, 200);
      return () => {
        disableChainTracking();
        clearInterval(interval);
      };
    } else {
      disableChainTracking();
    }
  }, [activeTab, enabled, refreshChains]);
}

