/**
 * DevTools Panel Component
 *
 * A bottom drawer panel for inspecting Rextive signals and tags.
 * Uses pure React state (no signals) to avoid circular dependencies.
 * Responsive design for mobile devices.
 */

import React, { useState, useEffect, useCallback, useRef } from "react";
import type { SignalInfo, TagInfo, DevToolsEvent } from "../types";
import {
  isDevToolsEnabled,
  getSignals,
  getTags,
  getStats,
  onDevToolsEvent,
  clearDisposed,
} from "../index";
import { isAutoGeneratedName } from "../../utils/nameGenerator";
import * as styles from "./styles";
import type { PanelPosition } from "./styles";

type Tab = "signals" | "tags" | "errors" | "events" | "stats";

const STORAGE_KEY = "rextive-devtools-config";

interface DevToolsConfig {
  position: PanelPosition;
  expanded: boolean;
  activeTab: Tab;
  showAutoGenerated: boolean;
  sizeBottom: number | null;
  sizeLeft: number | null;
}

const DEFAULT_CONFIG: DevToolsConfig = {
  position: "left",
  expanded: false,
  activeTab: "signals",
  showAutoGenerated: false,
  sizeBottom: null,
  sizeLeft: null,
};

// Load config from localStorage
const loadConfig = (): DevToolsConfig => {
  try {
    const saved = localStorage.getItem(STORAGE_KEY);
    if (saved) {
      const parsed = JSON.parse(saved);
      return { ...DEFAULT_CONFIG, ...parsed };
    }
  } catch {
    // Ignore localStorage errors
  }
  return DEFAULT_CONFIG;
};

// Save config to localStorage
const saveConfig = (config: Partial<DevToolsConfig>) => {
  try {
    const current = loadConfig();
    localStorage.setItem(
      STORAGE_KEY,
      JSON.stringify({ ...current, ...config })
    );
  } catch {
    // Ignore localStorage errors
  }
};

// Clear all persisted config
const clearConfig = () => {
  try {
    localStorage.removeItem(STORAGE_KEY);
  } catch {
    // Ignore localStorage errors
  }
};

type EventLogEntry = DevToolsEvent & {
  id: number;
  timestamp: number;
};

export function DevToolsPanel(): React.ReactElement | null {
  // Load initial config
  const initialConfig = useRef(loadConfig()).current;

  const [isExpanded, setIsExpanded] = useState(initialConfig.expanded);
  const [position, setPosition] = useState<PanelPosition>(
    initialConfig.position
  );
  const [activeTab, setActiveTab] = useState<Tab>(initialConfig.activeTab);
  const [showAutoGenerated, setShowAutoGenerated] = useState(
    initialConfig.showAutoGenerated
  );
  const [sizeBottom, setSizeBottom] = useState<number | null>(
    initialConfig.sizeBottom
  );
  const [sizeLeft, setSizeLeft] = useState<number | null>(
    initialConfig.sizeLeft
  );
  const [isResizing, setIsResizing] = useState(false);

  const [signals, setSignals] = useState<Map<string, SignalInfo>>(new Map());
  const [tags, setTags] = useState<Map<string, TagInfo>>(new Map());
  const [events, setEvents] = useState<EventLogEntry[]>([]);
  const [stats, setStats] = useState({
    signalCount: 0,
    mutableCount: 0,
    computedCount: 0,
    tagCount: 0,
    totalChanges: 0,
    totalErrors: 0,
    signalsWithErrors: 0,
    disposedCount: 0,
  });
  const [enabled, setEnabled] = useState(false);
  const [expandedSignal, setExpandedSignal] = useState<string | null>(null);
  const [hoveredItem, setHoveredItem] = useState<string | null>(null);
  const [flashingSignals, setFlashingSignals] = useState<
    Map<string, "change" | "create">
  >(new Map());
  const eventIdRef = useRef(0);
  const flashTimeoutsRef = useRef<Map<string, NodeJS.Timeout>>(new Map());
  const panelRef = useRef<HTMLDivElement>(null);

  // Persist config changes
  const togglePosition = useCallback(() => {
    setPosition((prev) => {
      const next = prev === "bottom" ? "left" : "bottom";
      saveConfig({ position: next });
      return next;
    });
  }, []);

  const updateActiveTab = useCallback((tab: Tab) => {
    setActiveTab(tab);
    saveConfig({ activeTab: tab });
  }, []);

  const updateShowAutoGenerated = useCallback((show: boolean) => {
    setShowAutoGenerated(show);
    saveConfig({ showAutoGenerated: show });
  }, []);

  const resetConfig = useCallback(() => {
    clearConfig();
    setIsExpanded(DEFAULT_CONFIG.expanded);
    setPosition(DEFAULT_CONFIG.position);
    setActiveTab(DEFAULT_CONFIG.activeTab);
    setShowAutoGenerated(DEFAULT_CONFIG.showAutoGenerated);
    setSizeBottom(DEFAULT_CONFIG.sizeBottom);
    setSizeLeft(DEFAULT_CONFIG.sizeLeft);
  }, []);

  // Resize handlers
  const handleResizeStart = useCallback(
    (e: React.MouseEvent) => {
      e.preventDefault();
      e.stopPropagation();
      setIsResizing(true);

      const startY = e.clientY;
      const startX = e.clientX;
      const startSize =
        position === "bottom"
          ? sizeBottom ?? styles.PANEL_SIZE_EXPANDED_BOTTOM
          : sizeLeft ?? styles.PANEL_SIZE_EXPANDED_LEFT;

      const handleMouseMove = (e: MouseEvent) => {
        if (position === "bottom") {
          // For bottom panel, dragging up increases size
          const delta = startY - e.clientY;
          const newSize = Math.max(
            styles.PANEL_MIN_SIZE_BOTTOM,
            Math.min(styles.PANEL_MAX_SIZE_BOTTOM, startSize + delta)
          );
          setSizeBottom(newSize);
        } else {
          // For left panel, dragging right increases size
          const delta = e.clientX - startX;
          const newSize = Math.max(
            styles.PANEL_MIN_SIZE_LEFT,
            Math.min(styles.PANEL_MAX_SIZE_LEFT, startSize + delta)
          );
          setSizeLeft(newSize);
        }
      };

      const handleMouseUp = () => {
        setIsResizing(false);
        document.removeEventListener("mousemove", handleMouseMove);
        document.removeEventListener("mouseup", handleMouseUp);
        document.body.style.cursor = "";
        document.body.style.userSelect = "";

        // Save the new size
        if (position === "bottom") {
          saveConfig({ sizeBottom: sizeBottom });
        } else {
          saveConfig({ sizeLeft: sizeLeft });
        }
      };

      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);
      document.body.style.cursor =
        position === "bottom" ? "ns-resize" : "ew-resize";
      document.body.style.userSelect = "none";
    },
    [position, sizeBottom, sizeLeft]
  );

  // Save size after resize ends
  useEffect(() => {
    if (!isResizing) {
      if (position === "bottom" && sizeBottom !== null) {
        saveConfig({ sizeBottom });
      } else if (position === "left" && sizeLeft !== null) {
        saveConfig({ sizeLeft });
      }
    }
  }, [isResizing, position, sizeBottom, sizeLeft]);

  // Manage body padding to prevent content from being hidden by devtools
  useEffect(() => {
    const updateBodyPadding = () => {
      if (position === "bottom" && isExpanded) {
        // Add padding to bottom when panel is at bottom and expanded
        const height = sizeBottom ?? styles.PANEL_SIZE_EXPANDED_BOTTOM;
        document.body.style.paddingBottom = `${height}px`;
        document.body.style.paddingLeft = "";
      } else if (position === "left" && isExpanded) {
        // Add padding to left when panel is at left and expanded
        const width = sizeLeft ?? styles.PANEL_SIZE_EXPANDED_LEFT;
        document.body.style.paddingLeft = `${width}px`;
        document.body.style.paddingBottom = "";
      } else {
        // Remove padding when panel is collapsed
        if (position === "bottom") {
          document.body.style.paddingBottom = `${styles.PANEL_SIZE_COLLAPSED}px`;
          document.body.style.paddingLeft = "";
        } else {
          document.body.style.paddingLeft = `${styles.PANEL_SIZE_COLLAPSED}px`;
          document.body.style.paddingBottom = "";
        }
      }
    };

    updateBodyPadding();

    // Cleanup: remove padding when component unmounts
    return () => {
      document.body.style.paddingBottom = "";
      document.body.style.paddingLeft = "";
    };
  }, [position, isExpanded, sizeBottom, sizeLeft]);

  // Check if devtools is enabled
  useEffect(() => {
    const checkEnabled = () => {
      setEnabled(isDevToolsEnabled());
    };

    checkEnabled();
    const interval = setInterval(checkEnabled, 1000);
    return () => clearInterval(interval);
  }, []);

  // Refresh data periodically when expanded
  useEffect(() => {
    if (!enabled) return;

    const refresh = () => {
      setSignals(new Map(getSignals()));
      setTags(new Map(getTags()));
      setStats(getStats());
    };

    refresh();
    const interval = setInterval(refresh, 500);
    return () => clearInterval(interval);
  }, [enabled]);

  // Subscribe to events
  useEffect(() => {
    if (!enabled) return;

    const unsubscribe = onDevToolsEvent((event) => {
      const entry: EventLogEntry = {
        ...event,
        id: eventIdRef.current++,
        timestamp: Date.now(),
      };
      setEvents((prev) => [entry, ...prev].slice(0, 100));

      const flashSignal = (signalId: string, type: "change" | "create") => {
        const existingTimeout = flashTimeoutsRef.current.get(signalId);
        if (existingTimeout) clearTimeout(existingTimeout);

        setFlashingSignals((prev) => new Map(prev).set(signalId, type));

        const timeout = setTimeout(() => {
          setFlashingSignals((prev) => {
            const next = new Map(prev);
            next.delete(signalId);
            return next;
          });
          flashTimeoutsRef.current.delete(signalId);
        }, 600);

        flashTimeoutsRef.current.set(signalId, timeout);
      };

      if (event.type === "signal:change" && "signalId" in event) {
        flashSignal(event.signalId, "change");
      } else if (event.type === "signal:create" && "signal" in event) {
        flashSignal(event.signal.id, "create");
      }
    });

    return () => {
      unsubscribe();
      flashTimeoutsRef.current.forEach((timeout) => clearTimeout(timeout));
      flashTimeoutsRef.current.clear();
    };
  }, [enabled]);

  const togglePanel = useCallback(() => {
    setIsExpanded((prev) => {
      const next = !prev;
      saveConfig({ expanded: next });
      return next;
    });
  }, []);

  const formatValue = (value: unknown): string => {
    if (value === undefined) return "undefined";
    if (value === null) return "null";
    if (typeof value === "function") return "[Function]";
    if (typeof value === "symbol") return value.toString();
    try {
      const str = JSON.stringify(value);
      return str.length > 40 ? str.slice(0, 40) + "‚Ä¶" : str;
    } catch {
      return String(value);
    }
  };

  const formatTime = (timestamp: number): string => {
    const date = new Date(timestamp);
    return date.toLocaleTimeString("en-US", {
      hour12: false,
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
    });
  };

  // Filter signals/tags based on showAutoGenerated
  const filteredSignals = Array.from(signals.values()).filter(
    (s) => showAutoGenerated || !isAutoGeneratedName(s.id)
  );
  const filteredTags = Array.from(tags.values()).filter(
    (t) => showAutoGenerated || !isAutoGeneratedName(t.id)
  );

  const renderSignals = () => {
    if (signals.size === 0) {
      return <div style={styles.emptyStateStyles}>No signals tracked</div>;
    }

    if (filteredSignals.length === 0) {
      return (
        <div style={styles.emptyStateStyles}>
          No user-named signals
          <div style={{ fontSize: "9px", marginTop: "4px", opacity: 0.7 }}>
            Check "Show #auto" to see {signals.size} auto-generated
          </div>
        </div>
      );
    }

    // Sort: active signals first, then disposed
    const sortedSignals = [...filteredSignals].sort((a, b) => {
      if (a.disposed !== b.disposed) return a.disposed ? 1 : -1;
      return 0;
    });

    return (
      <div style={styles.contentGridStyles}>
        {sortedSignals.map((info) => {
          let currentValue: unknown;
          if (info.disposed) {
            currentValue = "[disposed]";
          } else {
            try {
              currentValue = info.signal();
            } catch {
              currentValue = "[error]";
            }
          }

          const isExpanded = expandedSignal === info.id;
          const isHovered = hoveredItem === `signal-${info.id}`;
          const flashType = flashingSignals.get(info.id) || null;

          return (
            <div
              key={info.id}
              style={{
                ...styles.itemStyles(isHovered, flashType),
                ...(info.disposed && {
                  opacity: 0.6,
                  borderLeft: `3px solid #666`,
                  backgroundColor: "#2a2a2a",
                  filter: "grayscale(100%)",
                }),
              }}
              onClick={() => setExpandedSignal(isExpanded ? null : info.id)}
              onMouseEnter={() => setHoveredItem(`signal-${info.id}`)}
              onMouseLeave={() => setHoveredItem(null)}
            >
              <div style={styles.itemHeaderStyles}>
                <span style={styles.itemNameStyles}>
                  <span
                    style={{
                      ...styles.badgeStyles(info.kind),
                      ...(info.disposed && {
                        backgroundColor: "#444",
                        color: "#888",
                      }),
                    }}
                  >
                    {info.disposed ? "‚úï" : info.kind === "mutable" ? "M" : "C"}
                  </span>
                  <span
                    style={{
                      overflow: "hidden",
                      textOverflow: "ellipsis",
                      ...(info.disposed && {
                        textDecoration: "line-through",
                        color: "#666",
                      }),
                    }}
                  >
                    {info.id}
                  </span>
                </span>
                <span
                  style={{
                    color: info.disposed ? "#888" : styles.colors.textDim,
                    fontSize: "9px",
                    flexShrink: 0,
                    ...(info.disposed && {
                      backgroundColor: "#333",
                      padding: "1px 4px",
                      borderRadius: "3px",
                    }),
                  }}
                >
                  {info.disposed ? "disposed" : `√ó${info.changeCount}`}
                </span>
              </div>
              <div
                style={{
                  ...styles.valueStyles,
                  ...(info.disposed && { color: "#555" }),
                }}
              >
                {formatValue(currentValue)}
              </div>

              {isExpanded && info.history.length > 0 && (
                <div
                  style={{
                    marginTop: "6px",
                    paddingTop: "6px",
                    borderTop: `1px solid ${styles.colors.border}`,
                  }}
                >
                  {info.history.slice(0, 3).map((entry, i) => (
                    <div
                      key={i}
                      style={{
                        fontSize: "9px",
                        color: styles.colors.textDim,
                        marginBottom: "1px",
                      }}
                    >
                      <span style={{ color: styles.colors.textMuted }}>
                        {formatTime(entry.timestamp)}
                      </span>
                      {" ‚Üí "}
                      {formatValue(entry.value)}
                    </div>
                  ))}
                </div>
              )}
            </div>
          );
        })}
      </div>
    );
  };

  const renderTags = () => {
    if (tags.size === 0) {
      return <div style={styles.emptyStateStyles}>No tags tracked</div>;
    }

    if (filteredTags.length === 0) {
      return (
        <div style={styles.emptyStateStyles}>
          No user-named tags
          <div style={{ fontSize: "9px", marginTop: "4px", opacity: 0.7 }}>
            Check "Show #auto" to see {tags.size} auto-generated
          </div>
        </div>
      );
    }

    return (
      <div style={styles.contentGridStyles}>
        {filteredTags.map((info) => {
          const isHovered = hoveredItem === `tag-${info.id}`;

          return (
            <div
              key={info.id}
              style={styles.itemStyles(isHovered)}
              onMouseEnter={() => setHoveredItem(`tag-${info.id}`)}
              onMouseLeave={() => setHoveredItem(null)}
            >
              <div style={styles.itemHeaderStyles}>
                <span style={styles.itemNameStyles}>
                  <span style={styles.badgeStyles("tag")}>T</span>
                  <span
                    style={{ overflow: "hidden", textOverflow: "ellipsis" }}
                  >
                    {info.id}
                  </span>
                </span>
                <span style={{ color: styles.colors.textDim, fontSize: "9px" }}>
                  {info.signals.size} sig
                </span>
              </div>
              {info.signals.size > 0 && (
                <div style={styles.valueStyles}>
                  {Array.from(info.signals).slice(0, 3).join(", ")}
                  {info.signals.size > 3 && ` +${info.signals.size - 3}`}
                </div>
              )}
            </div>
          );
        })}
      </div>
    );
  };

  const clearEvents = () => {
    setEvents([]);
  };

  const renderEvents = () => {
    return (
      <div style={{ display: "flex", flexDirection: "column", height: "100%" }}>
        {/* Clear button */}
        <div
          style={{
            display: "flex",
            justifyContent: "flex-end",
            padding: "4px 8px",
            borderBottom: `1px solid ${styles.colors.border}`,
            flexShrink: 0,
          }}
        >
          <button
            onClick={clearEvents}
            style={{
              padding: "2px 8px",
              fontSize: "10px",
              backgroundColor: styles.colors.bgHover,
              border: `1px solid ${styles.colors.border}`,
              borderRadius: "4px",
              color: styles.colors.textMuted,
              cursor: "pointer",
            }}
            disabled={events.length === 0}
          >
            Clear ({events.length})
          </button>
        </div>

        {events.length === 0 ? (
          <div style={styles.emptyStateStyles}>No events yet</div>
        ) : (
          <div
            style={{
              ...styles.eventLogStyles,
              flex: 1,
              overflowY: "auto",
              maxHeight: "none",
            }}
          >
            {events.map((event) => (
              <div key={event.id} style={styles.eventItemStyles}>
                <span
                  style={{
                    color: styles.colors.textMuted,
                    fontSize: "8px",
                    minWidth: "50px",
                    flexShrink: 0,
                  }}
                >
                  {formatTime(event.timestamp)}
                </span>
                <span style={styles.eventTypeStyles(event.type)}>
                  {event.type.split(":")[1]}
                </span>
                <span
                  style={{
                    color: styles.colors.textDim,
                    flex: 1,
                    overflow: "hidden",
                    textOverflow: "ellipsis",
                    whiteSpace: "nowrap",
                  }}
                >
                  {"signalId" in event && String(event.signalId)}
                  {"tagId" in event && String(event.tagId)}
                  {"value" in event && ` ‚Üí ${formatValue(event.value)}`}
                </span>
              </div>
            ))}
          </div>
        )}
      </div>
    );
  };

  const renderStats = () => (
    <div style={styles.statsGridStyles}>
      <div style={styles.statBoxStyles}>
        <div style={styles.statValueStyles}>{stats.signalCount}</div>
        <div style={styles.statLabelStyles}>Signals</div>
      </div>
      <div style={styles.statBoxStyles}>
        <div
          style={{ ...styles.statValueStyles, color: styles.colors.mutable }}
        >
          {stats.mutableCount}
        </div>
        <div style={styles.statLabelStyles}>Mutable</div>
      </div>
      <div style={styles.statBoxStyles}>
        <div
          style={{ ...styles.statValueStyles, color: styles.colors.computed }}
        >
          {stats.computedCount}
        </div>
        <div style={styles.statLabelStyles}>Computed</div>
      </div>
      <div style={styles.statBoxStyles}>
        <div style={{ ...styles.statValueStyles, color: styles.colors.tag }}>
          {stats.tagCount}
        </div>
        <div style={styles.statLabelStyles}>Tags</div>
      </div>
      <div style={styles.statBoxStyles}>
        <div style={styles.statValueStyles}>{stats.totalChanges}</div>
        <div style={styles.statLabelStyles}>Changes</div>
      </div>
      <div style={styles.statBoxStyles}>
        <div style={styles.statValueStyles}>{events.length}</div>
        <div style={styles.statLabelStyles}>Events</div>
      </div>
      <div style={styles.statBoxStyles}>
        <div
          style={{
            ...styles.statValueStyles,
            color:
              stats.totalErrors > 0
                ? styles.colors.error
                : styles.colors.textDim,
          }}
        >
          {stats.totalErrors}
        </div>
        <div style={styles.statLabelStyles}>Errors</div>
      </div>
    </div>
  );

  // Get signals with errors (filtered by showAutoGenerated)
  const signalsWithErrors = Array.from(signals.values()).filter(
    (s) => s.errorCount > 0 && (showAutoGenerated || !isAutoGeneratedName(s.id))
  );

  const renderErrors = () => {
    if (signalsWithErrors.length === 0) {
      return (
        <div style={styles.emptyStateStyles}>
          <div style={{ color: styles.colors.success }}>‚úì No errors</div>
          <div style={{ fontSize: "9px", marginTop: "4px", opacity: 0.7 }}>
            Signals are running without errors
          </div>
        </div>
      );
    }

    return (
      <div>
        {signalsWithErrors.map((info) => (
          <div
            key={info.id}
            style={{
              ...styles.itemStyles(hoveredItem === `error-${info.id}`),
              borderLeft: `3px solid ${styles.colors.error}`,
            }}
            onMouseEnter={() => setHoveredItem(`error-${info.id}`)}
            onMouseLeave={() => setHoveredItem(null)}
          >
            <div style={styles.itemHeaderStyles}>
              <span style={styles.itemNameStyles}>
                <span style={styles.badgeStyles(info.kind)}>
                  {info.kind === "mutable" ? "M" : "C"}
                </span>
                <span style={{ overflow: "hidden", textOverflow: "ellipsis" }}>
                  {info.id}
                </span>
              </span>
              <span
                style={{
                  color: styles.colors.error,
                  fontSize: "9px",
                  fontWeight: 600,
                }}
              >
                {info.errorCount} error{info.errorCount !== 1 ? "s" : ""}
              </span>
            </div>

            {/* Show recent errors */}
            {info.errors.slice(0, 3).map((err, i) => (
              <div
                key={i}
                style={{
                  marginTop: i === 0 ? "6px" : "3px",
                  padding: "4px 6px",
                  backgroundColor: `${styles.colors.error}15`,
                  borderRadius: "3px",
                  fontSize: "9px",
                }}
              >
                <div
                  style={{
                    color: styles.colors.error,
                    fontWeight: 500,
                    marginBottom: "2px",
                  }}
                >
                  {err.message.length > 60
                    ? err.message.slice(0, 60) + "‚Ä¶"
                    : err.message}
                </div>
                <div
                  style={{ color: styles.colors.textMuted, fontSize: "8px" }}
                >
                  {formatTime(err.timestamp)}
                </div>
              </div>
            ))}
            {info.errors.length > 3 && (
              <div
                style={{
                  marginTop: "3px",
                  fontSize: "8px",
                  color: styles.colors.textMuted,
                }}
              >
                +{info.errors.length - 3} more errors
              </div>
            )}
          </div>
        ))}
      </div>
    );
  };

  const renderContent = () => {
    if (!enabled) {
      return (
        <div style={styles.warningBoxStyles}>
          <div style={{ marginBottom: "4px" }}>‚ö†Ô∏è DevTools not enabled</div>
          <div style={{ fontSize: "10px", opacity: 0.8 }}>
            Call{" "}
            <code
              style={{
                backgroundColor: "rgba(0,0,0,0.3)",
                padding: "1px 4px",
                borderRadius: "2px",
              }}
            >
              enableDevTools()
            </code>{" "}
            before creating signals
          </div>
        </div>
      );
    }

    switch (activeTab) {
      case "signals":
        return renderSignals();
      case "tags":
        return renderTags();
      case "errors":
        return renderErrors();
      case "events":
        return renderEvents();
      case "stats":
        return renderStats();
    }
  };

  // Calculate counts for tabs
  const getTabCount = (tab: Tab): string => {
    if (!enabled) return "";
    if (tab === "signals") {
      const count = filteredSignals.length;
      return count !== signals.size ? `${count}/${signals.size}` : `${count}`;
    }
    if (tab === "tags") {
      const count = filteredTags.length;
      return count !== tags.size ? `${count}/${tags.size}` : `${count}`;
    }
    if (tab === "errors") return `${signalsWithErrors.length}`;
    if (tab === "events") return `${events.length}`;
    return "";
  };

  const isLeftCollapsed = position === "left" && !isExpanded;
  const currentSize = position === "bottom" ? sizeBottom : sizeLeft;

  return (
    <div style={styles.panelContainerStyles(position)}>
      <div
        ref={panelRef}
        style={{
          ...styles.panelStyles(
            isExpanded,
            position,
            currentSize ?? undefined,
            isResizing
          ),
          position: "relative",
        }}
      >
        {/* Resize handle - only show when expanded */}
        {isExpanded && (
          <div
            style={styles.resizeHandleStyles(position, isResizing)}
            onMouseDown={handleResizeStart}
          >
            <div style={styles.resizeHandleGripStyles(position)} />
          </div>
        )}

        {/* Header - clickable to toggle */}
        <div
          style={styles.headerStyles(position, isExpanded)}
          onClick={togglePanel}
        >
          <h3 style={styles.titleStyles(isLeftCollapsed)}>
            <span>‚ö°</span>
            {!isLeftCollapsed && <span>Rextive</span>}
          </h3>

          {/* Quick stats in header (hide when left collapsed) */}
          {enabled && !isLeftCollapsed && (
            <div style={styles.headerStatsStyles}>
              <span style={styles.headerStatBadgeStyles("mutable")}>
                M {stats.mutableCount}
              </span>
              <span style={styles.headerStatBadgeStyles("computed")}>
                C {stats.computedCount}
              </span>
              {stats.tagCount > 0 && (
                <span style={styles.headerStatBadgeStyles("tag")}>
                  T {stats.tagCount}
                </span>
              )}
            </div>
          )}

          <div
            style={{
              ...styles.headerRightStyles,
              flexDirection: isLeftCollapsed ? "column" : "row",
            }}
          >
            {/* Show all toggle (including auto-generated) */}
            {enabled && !isLeftCollapsed && (
              <button
                style={{
                  ...styles.positionButtonStyles,
                  fontSize: "10px",
                  padding: "3px 8px",
                  borderRadius: "10px",
                  backgroundColor: showAutoGenerated
                    ? styles.colors.accent + "33"
                    : styles.colors.bgHover,
                  color: showAutoGenerated
                    ? styles.colors.accent
                    : styles.colors.textMuted,
                  opacity: 1,
                }}
                onClick={(e) => {
                  e.stopPropagation();
                  updateShowAutoGenerated(!showAutoGenerated);
                }}
                title={
                  showAutoGenerated
                    ? "Hide auto-generated signals"
                    : "Show all signals (including #auto)"
                }
              >
                {showAutoGenerated ? "All" : "User"}
              </button>
            )}

            {/* Clear disposed button */}
            {enabled && !isLeftCollapsed && stats.disposedCount > 0 && (
              <button
                style={{
                  ...styles.positionButtonStyles,
                  fontSize: "10px",
                  padding: "3px 8px",
                  borderRadius: "10px",
                  backgroundColor: styles.colors.bgHover,
                  color: styles.colors.textMuted,
                  opacity: 1,
                }}
                onClick={(e) => {
                  e.stopPropagation();
                  clearDisposed();
                }}
                title={`Clear ${stats.disposedCount} disposed signal${
                  stats.disposedCount !== 1 ? "s" : ""
                }`}
              >
                üóë {stats.disposedCount}
              </button>
            )}

            {/* Position toggle */}
            <button
              style={styles.positionButtonStyles}
              onClick={(e) => {
                e.stopPropagation();
                togglePosition();
              }}
              title={position === "bottom" ? "Move to left" : "Move to bottom"}
            >
              {position === "bottom" ? "‚óÄ" : "‚ñº"}
            </button>

            {/* Expand/Collapse toggle */}
            <button
              style={styles.toggleButtonStyles}
              onClick={(e) => {
                e.stopPropagation();
                togglePanel();
              }}
              title={isExpanded ? "Collapse" : "Expand"}
            >
              {position === "bottom"
                ? isExpanded
                  ? "‚ñº"
                  : "‚ñ≤"
                : isExpanded
                ? "‚óÄ"
                : "‚ñ∂"}
            </button>
          </div>
        </div>

        {/* Tabs + Content (only when expanded) */}
        {isExpanded && (
          <>
            <div style={styles.tabsContainerStyles}>
              {(["signals", "tags", "errors", "events", "stats"] as Tab[]).map(
                (tab) => (
                  <button
                    key={tab}
                    style={styles.tabStyles(activeTab === tab)}
                    onClick={() => updateActiveTab(tab)}
                  >
                    {tab.charAt(0).toUpperCase() + tab.slice(1)}
                    {getTabCount(tab) && ` (${getTabCount(tab)})`}
                  </button>
                )
              )}

              {/* Reset config button */}
              <button
                style={styles.resetButtonStyles}
                onClick={(e) => {
                  e.stopPropagation();
                  resetConfig();
                }}
                title="Reset DevTools settings"
              >
                ‚Ü∫
              </button>
            </div>

            <div style={styles.contentStyles}>{renderContent()}</div>
          </>
        )}
      </div>
    </div>
  );
}
