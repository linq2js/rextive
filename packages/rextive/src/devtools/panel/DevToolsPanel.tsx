/**
 * DevTools Panel Component
 *
 * A bottom drawer panel for inspecting Rextive signals and tags.
 * Uses pure React state (no signals) to avoid circular dependencies.
 * Responsive design for mobile devices.
 */

import React, { useState, useEffect, useCallback, useRef } from "react";
import type {
  SignalInfo,
  TagInfo,
  DevToolsEvent,
  ChainReaction,
} from "../types";
import {
  isDevToolsEnabled,
  getSignals,
  getTags,
  getStats,
  onDevToolsEvent,
  clearDisposed,
  deleteSignal,
  enableChainTracking,
  disableChainTracking,
  getChainsList,
  deleteChain,
} from "../index";
import { isAutoGeneratedName } from "../../utils/nameGenerator";
import { loadable } from "../../utils/loadable";
import {
  IconReset,
  IconArrowLeft,
  IconArrowDown,
  IconChevronUp,
  IconChevronDown,
  IconChevronLeft,
  IconChevronRight,
  IconCopy,
  IconEdit,
  IconHistory,
  IconRefresh,
  IconTrash,
  IconClose,
  IconBolt,
  IconResetSmall,
} from "./icons";
import { isPromiseLike } from "../../utils/isPromiseLike";
import * as styles from "./styles";
import type { PanelPosition } from "./styles";

type Tab = "signals" | "tags" | "events" | "chains";

const STORAGE_KEY = "rextive-devtools-config";

interface DevToolsConfig {
  position: PanelPosition;
  expanded: boolean;
  activeTab: Tab;
  showAutoGenerated: boolean;
  sizeBottom: number | null;
  sizeLeft: number | null;
}

const DEFAULT_CONFIG: DevToolsConfig = {
  position: "left",
  expanded: false,
  activeTab: "signals",
  showAutoGenerated: false,
  sizeBottom: null,
  sizeLeft: null,
};

// Load config from localStorage
const loadConfig = (): DevToolsConfig => {
  try {
    const saved = localStorage.getItem(STORAGE_KEY);
    if (saved) {
      const parsed = JSON.parse(saved);
      return { ...DEFAULT_CONFIG, ...parsed };
    }
  } catch {
    // Ignore localStorage errors
  }
  return DEFAULT_CONFIG;
};

// Save config to localStorage
const saveConfig = (config: Partial<DevToolsConfig>) => {
  try {
    const current = loadConfig();
    localStorage.setItem(
      STORAGE_KEY,
      JSON.stringify({ ...current, ...config })
    );
  } catch {
    // Ignore localStorage errors
  }
};

// Clear all persisted config
const clearConfig = () => {
  try {
    localStorage.removeItem(STORAGE_KEY);
  } catch {
    // Ignore localStorage errors
  }
};

type EventLogEntry = DevToolsEvent & {
  id: number;
  timestamp: number;
  isError?: boolean;
};

export function DevToolsPanel(): React.ReactElement | null {
  // Load initial config
  const initialConfig = useRef(loadConfig()).current;

  const [isExpanded, setIsExpanded] = useState(initialConfig.expanded);
  const [position, setPosition] = useState<PanelPosition>(
    initialConfig.position
  );
  const [activeTab, setActiveTab] = useState<Tab>(initialConfig.activeTab);
  const [showAutoGenerated, setShowAutoGenerated] = useState(
    initialConfig.showAutoGenerated
  );
  const [sizeBottom, setSizeBottom] = useState<number | null>(
    initialConfig.sizeBottom
  );
  const [sizeLeft, setSizeLeft] = useState<number | null>(
    initialConfig.sizeLeft
  );
  const [isResizing, setIsResizing] = useState(false);
  const [isMobile, setIsMobile] = useState(
    () => typeof window !== "undefined" && window.innerWidth <= 768
  );

  const [signals, setSignals] = useState<Map<string, SignalInfo>>(new Map());
  const [tags, setTags] = useState<Map<string, TagInfo>>(new Map());
  const [events, setEvents] = useState<EventLogEntry[]>([]);
  const [stats, setStats] = useState({
    signalCount: 0,
    mutableCount: 0,
    computedCount: 0,
    tagCount: 0,
    totalChanges: 0,
    totalErrors: 0,
    signalsWithErrors: 0,
    disposedCount: 0,
  });
  const [enabled, setEnabled] = useState(false);
  const [expandedSignal, setExpandedSignal] = useState<string | null>(null);
  const [hoveredItem, setHoveredItem] = useState<string | null>(null);
  const [flashingSignals, setFlashingSignals] = useState<
    Map<string, "change" | "create">
  >(new Map());
  const [searchQuery, setSearchQuery] = useState("");
  const [editingSignal, setEditingSignal] = useState<string | null>(null);
  const [editValue, setEditValue] = useState("");
  const [editError, setEditError] = useState<string | null>(null);
  const [expandedEvents, setExpandedEvents] = useState<Set<number>>(new Set());
  const [expandedTag, setExpandedTag] = useState<string | null>(null);
  const [signalKindFilter, setSignalKindFilter] = useState<
    "all" | "mutable" | "computed" | "error" | "disposed"
  >("all");
  const [recentActivitySort, setRecentActivitySort] = useState(true);
  const [eventKindFilter, setEventKindFilter] = useState<
    "all" | "error" | "update" | "create" | "dispose"
  >("all");
  // Chain reaction state
  const [chains, setChains] = useState<ChainReaction[]>([]);
  const [expandedChain, setExpandedChain] = useState<string | null>(null);
  const [chainFilter, setChainFilter] = useState("");
  const eventIdRef = useRef(0);
  const flashTimeoutsRef = useRef<Map<string, NodeJS.Timeout>>(new Map());
  const panelRef = useRef<HTMLDivElement>(null);

  // Mobile mode detection - force bottom position on small screens
  useEffect(() => {
    const checkMobile = () => {
      const mobile = window.innerWidth <= 768;
      setIsMobile(mobile);
      // Force bottom position in mobile mode (use functional form to avoid dependency)
      if (mobile) {
        setPosition((prev) => (prev !== "bottom" ? "bottom" : prev));
      }
    };

    checkMobile();
    window.addEventListener("resize", checkMobile);
    return () => window.removeEventListener("resize", checkMobile);
  }, []);

  // Persist config changes
  const togglePosition = useCallback(() => {
    setPosition((prev) => {
      const next = prev === "bottom" ? "left" : "bottom";
      saveConfig({ position: next });
      return next;
    });
  }, []);

  const updateActiveTab = useCallback((tab: Tab) => {
    setActiveTab(tab);
    saveConfig({ activeTab: tab });
  }, []);

  const updateShowAutoGenerated = useCallback((show: boolean) => {
    setShowAutoGenerated(show);
    saveConfig({ showAutoGenerated: show });
  }, []);

  const resetConfig = useCallback(() => {
    clearConfig();
    setIsExpanded(DEFAULT_CONFIG.expanded);
    setPosition(DEFAULT_CONFIG.position);
    setActiveTab(DEFAULT_CONFIG.activeTab);
    setShowAutoGenerated(DEFAULT_CONFIG.showAutoGenerated);
    setSizeBottom(DEFAULT_CONFIG.sizeBottom);
    setSizeLeft(DEFAULT_CONFIG.sizeLeft);
  }, []);

  // Resize handlers - supports both mouse and touch events
  const handleResizeStart = useCallback(
    (e: React.MouseEvent | React.TouchEvent) => {
      e.preventDefault();
      e.stopPropagation();
      setIsResizing(true);

      // Get initial position from mouse or touch event
      const isTouch = "touches" in e;
      const startY = isTouch ? e.touches[0].clientY : e.clientY;
      const startX = isTouch ? e.touches[0].clientX : e.clientX;
      const startSize =
        position === "bottom"
          ? sizeBottom ?? styles.PANEL_SIZE_EXPANDED_BOTTOM
          : sizeLeft ?? styles.PANEL_SIZE_EXPANDED_LEFT;

      const handleMove = (moveEvent: MouseEvent | TouchEvent) => {
        const isTouchMove = "touches" in moveEvent;
        const currentY = isTouchMove
          ? moveEvent.touches[0].clientY
          : moveEvent.clientY;
        const currentX = isTouchMove
          ? moveEvent.touches[0].clientX
          : moveEvent.clientX;

        if (position === "bottom") {
          // For bottom panel, dragging up increases size
          const delta = startY - currentY;
          const newSize = Math.max(
            styles.PANEL_MIN_SIZE_BOTTOM,
            Math.min(styles.PANEL_MAX_SIZE_BOTTOM, startSize + delta)
          );
          setSizeBottom(newSize);
        } else {
          // For left panel, dragging right increases size
          const delta = currentX - startX;
          const newSize = Math.max(
            styles.PANEL_MIN_SIZE_LEFT,
            Math.min(styles.PANEL_MAX_SIZE_LEFT, startSize + delta)
          );
          setSizeLeft(newSize);
        }
      };

      const handleEnd = () => {
        setIsResizing(false);
        document.removeEventListener("mousemove", handleMove);
        document.removeEventListener("mouseup", handleEnd);
        document.removeEventListener("touchmove", handleMove);
        document.removeEventListener("touchend", handleEnd);
        document.removeEventListener("touchcancel", handleEnd);
        document.body.style.cursor = "";
        document.body.style.userSelect = "";

        // Save the new size
        if (position === "bottom") {
          saveConfig({ sizeBottom: sizeBottom });
        } else {
          saveConfig({ sizeLeft: sizeLeft });
        }
      };

      // Add both mouse and touch event listeners
      document.addEventListener("mousemove", handleMove);
      document.addEventListener("mouseup", handleEnd);
      document.addEventListener("touchmove", handleMove, { passive: false });
      document.addEventListener("touchend", handleEnd);
      document.addEventListener("touchcancel", handleEnd);
      document.body.style.cursor =
        position === "bottom" ? "ns-resize" : "ew-resize";
      document.body.style.userSelect = "none";
    },
    [position, sizeBottom, sizeLeft]
  );

  // Save size after resize ends
  useEffect(() => {
    if (!isResizing) {
      if (position === "bottom" && sizeBottom !== null) {
        saveConfig({ sizeBottom });
      } else if (position === "left" && sizeLeft !== null) {
        saveConfig({ sizeLeft });
      }
    }
  }, [isResizing, position, sizeBottom, sizeLeft]);

  // Manage body padding to prevent content from being hidden by devtools
  useEffect(() => {
    const updateBodyPadding = () => {
      if (position === "bottom" && isExpanded) {
        // Add padding to bottom when panel is at bottom and expanded
        const height = sizeBottom ?? styles.PANEL_SIZE_EXPANDED_BOTTOM;
        document.body.style.paddingBottom = `${height}px`;
        document.body.style.paddingLeft = "";
      } else if (position === "left" && isExpanded) {
        // Add padding to left when panel is at left and expanded
        const width = sizeLeft ?? styles.PANEL_SIZE_EXPANDED_LEFT;
        document.body.style.paddingLeft = `${width}px`;
        document.body.style.paddingBottom = "";
      } else {
        // Remove padding when panel is collapsed
        if (position === "bottom") {
          document.body.style.paddingBottom = `${styles.PANEL_SIZE_COLLAPSED}px`;
          document.body.style.paddingLeft = "";
        } else {
          document.body.style.paddingLeft = `${styles.PANEL_SIZE_COLLAPSED}px`;
          document.body.style.paddingBottom = "";
        }
      }
    };

    updateBodyPadding();

    // Cleanup: remove padding when component unmounts
    return () => {
      document.body.style.paddingBottom = "";
      document.body.style.paddingLeft = "";
    };
  }, [position, isExpanded, sizeBottom, sizeLeft]);

  // Check if devtools is enabled
  useEffect(() => {
    const checkEnabled = () => {
      setEnabled(isDevToolsEnabled());
    };

    checkEnabled();
    const interval = setInterval(checkEnabled, 1000);
    return () => clearInterval(interval);
  }, []);

  // Refresh data periodically when expanded
  useEffect(() => {
    if (!enabled) return;

    const refresh = () => {
      setSignals(new Map(getSignals()));
      setTags(new Map(getTags()));
      setStats(getStats());
    };

    refresh();
    const interval = setInterval(refresh, 500);
    return () => clearInterval(interval);
  }, [enabled]);

  // Subscribe to events
  useEffect(() => {
    if (!enabled) return;

    const unsubscribe = onDevToolsEvent((event) => {
      // Handle signals:forget - remove all events related to forgotten signals
      if (event.type === "signals:forget") {
        const forgottenIds = new Set(event.signalIds);
        setEvents((prev) =>
          prev.filter((e) => {
            // Filter out events related to forgotten signals
            if ("signalId" in e && forgottenIds.has(e.signalId)) return false;
            if ("signal" in e && forgottenIds.has(e.signal.id)) return false;
            return true;
          })
        );
        // Also update signals state to remove forgotten signals
        setSignals((prev) => {
          const next = new Map(prev);
          for (const id of forgottenIds) {
            next.delete(id);
          }
          return next;
        });
        return; // Don't log this event
      }

      // Check if this is an error event
      let isError = false;
      if (event.type === "signal:error") {
        // Explicit error event
        isError = true;
      } else if (event.type === "signal:change" && "signalId" in event) {
        // Change event where signal has error
        const signalInfo = getSignals().get(event.signalId);
        if (signalInfo?.signal?.error?.()) {
          isError = true;
        }
      }

      const entry: EventLogEntry = {
        ...event,
        id: eventIdRef.current++,
        timestamp: Date.now(),
        isError,
      };
      setEvents((prev) => [entry, ...prev].slice(0, 100));

      const flashSignal = (signalId: string, type: "change" | "create") => {
        const existingTimeout = flashTimeoutsRef.current.get(signalId);
        if (existingTimeout) clearTimeout(existingTimeout);

        setFlashingSignals((prev) => new Map(prev).set(signalId, type));

        const timeout = setTimeout(() => {
          setFlashingSignals((prev) => {
            const next = new Map(prev);
            next.delete(signalId);
            return next;
          });
          flashTimeoutsRef.current.delete(signalId);
        }, 600);

        flashTimeoutsRef.current.set(signalId, timeout);
      };

      if (event.type === "signal:change" && "signalId" in event) {
        flashSignal(event.signalId, "change");
      } else if (event.type === "signal:create" && "signal" in event) {
        flashSignal(event.signal.id, "create");
      }
    });

    return () => {
      unsubscribe();
      flashTimeoutsRef.current.forEach((timeout) => clearTimeout(timeout));
      flashTimeoutsRef.current.clear();
    };
  }, [enabled]);

  // Chain tracking - enable only when chains tab is active
  useEffect(() => {
    if (activeTab === "chains" && enabled) {
      enableChainTracking();
      // Refresh chains periodically
      const interval = setInterval(() => {
        setChains(getChainsList());
      }, 200);
      return () => {
        disableChainTracking();
        clearInterval(interval);
      };
    } else {
      disableChainTracking();
    }
  }, [activeTab, enabled]);

  const togglePanel = useCallback(() => {
    setIsExpanded((prev) => {
      const next = !prev;
      saveConfig({ expanded: next });
      return next;
    });
  }, []);

  const formatValue = (value: unknown, maxLength = 40): string => {
    if (value === undefined) return "undefined";
    if (value === null) return "null";
    if (typeof value === "function") return "[Function]";
    if (typeof value === "symbol") return value.toString();
    try {
      const str = JSON.stringify(value);
      return str.length > maxLength ? str.slice(0, maxLength) + "‚Ä¶" : str;
    } catch {
      return String(value);
    }
  };

  const formatValueFull = (value: unknown): string => {
    if (value === undefined) return "undefined";
    if (value === null) return "null";
    if (typeof value === "function") return "[Function]";
    if (typeof value === "symbol") return value.toString();
    try {
      return JSON.stringify(value, null, 2);
    } catch {
      return String(value);
    }
  };

  const formatTime = (timestamp: number): string => {
    const date = new Date(timestamp);
    return date.toLocaleTimeString("en-US", {
      hour12: false,
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
    });
  };

  // Filter signals/tags based on showAutoGenerated and search query
  const searchLower = searchQuery.toLowerCase().trim();
  // When search starts with '#', automatically include auto-generated names
  const searchingAutoGenerated = searchLower.startsWith("#");
  const effectiveShowAutoGenerated =
    showAutoGenerated || searchingAutoGenerated;

  const filteredSignals = Array.from(signals.values()).filter((s) => {
    // Filter by auto-generated (skip if searching for auto-generated names)
    if (!effectiveShowAutoGenerated && isAutoGeneratedName(s.name)) return false;
    // Filter by search query (search by display name)
    if (searchLower && !s.name.toLowerCase().includes(searchLower)) return false;
    // Filter by kind
    if (signalKindFilter === "error") {
      if (s.errorCount === 0) return false;
    } else if (signalKindFilter === "disposed") {
      if (!s.disposed) return false;
    } else if (signalKindFilter !== "all" && s.kind !== signalKindFilter) {
      return false;
    }
    return true;
  });

  const filteredTags = Array.from(tags.values()).filter((t) => {
    // Filter by auto-generated (skip if searching for auto-generated names)
    if (!effectiveShowAutoGenerated && isAutoGeneratedName(t.id)) return false;
    // Filter by search query
    if (searchLower && !t.id.toLowerCase().includes(searchLower)) return false;
    return true;
  });

  // Filter events by search query and kind filter
  const filteredEvents = events.filter((e) => {
    // Filter by search query
    if (searchLower) {
      // Get signal name from ID (for searching by display name)
      const signalId = "signalId" in e ? String(e.signalId) : "";
      const signalInfo = signalId ? signals.get(signalId) : undefined;
      const signalName = signalInfo?.name || signalId;
      const tagId = "tagId" in e ? String(e.tagId) : "";
      const type = e.type;
      if (
        !signalName.toLowerCase().includes(searchLower) &&
        !tagId.toLowerCase().includes(searchLower) &&
        !type.toLowerCase().includes(searchLower)
      ) {
        return false;
      }
    }
    // Filter by event kind
    if (eventKindFilter === "error") {
      return e.isError || e.type === "signal:error";
    } else if (eventKindFilter === "update") {
      return e.type === "signal:change";
    } else if (eventKindFilter === "create") {
      return e.type === "signal:create" || e.type === "tag:create";
    } else if (eventKindFilter === "dispose") {
      return e.type === "signal:dispose";
    }
    return true; // "all"
  });

  const renderSignals = () => {
    if (signals.size === 0) {
      return <div style={styles.emptyStateStyles}>No signals tracked</div>;
    }

    if (filteredSignals.length === 0) {
      if (searchLower) {
        return (
          <div style={styles.emptyStateStyles}>
            No signals match "{searchQuery}"
          </div>
        );
      }
      return (
        <div style={styles.emptyStateStyles}>
          No user-named signals
          <div style={{ fontSize: "9px", marginTop: "4px", opacity: 0.7 }}>
            Check "Show #auto" to see {signals.size} auto-generated
          </div>
        </div>
      );
    }

    // Sort signals based on mode
    const sortedSignals = [...filteredSignals].sort((a, b) => {
      if (recentActivitySort) {
        // Sort by last activity time (updatedAt), latest first
        return b.updatedAt - a.updatedAt;
      }
      // Default: active signals first, then disposed
      if (a.disposed !== b.disposed) return a.disposed ? 1 : -1;
      return 0;
    });

    return (
      <div style={styles.contentGridStyles(position)}>
        {sortedSignals.map((info) => {
          let currentValue: unknown;
          let signalError: unknown = undefined;

          if (info.disposed) {
            // Format disposal time
            const disposedTime = info.disposedAt
              ? new Date(info.disposedAt).toLocaleTimeString()
              : "";
            currentValue = disposedTime
              ? `[disposed at ${disposedTime}]`
              : "[disposed]";
          } else {
            // Check for error first (works for both sync and async signals)
            signalError = info.signal.error();
            if (signalError) {
              currentValue = signalError;
            } else {
              currentValue = info.signal.tryGet();
              // For async signals, show the resolved/rejected value from loadable
              if (isPromiseLike(currentValue)) {
                const state = loadable(currentValue);
                if (state.status === "success") {
                  currentValue = state.value;
                } else if (state.status === "error") {
                  signalError = state.error;
                  currentValue = state.error;
                } else {
                  // Loading state - show "[async]"
                  currentValue = "[async]";
                }
              }
            }
          }

          const isExpanded = expandedSignal === info.id;
          const isHovered = hoveredItem === `signal-${info.id}`;
          const flashType = flashingSignals.get(info.id) || null;
          const hasError = !info.disposed && signalError !== undefined;

          // Build hover tooltip with full name and source location
          const hoverTitle = [
            info.id,
            info.source
              ? `üìç ${info.source.file}:${info.source.line}${info.source.functionName ? ` (${info.source.functionName})` : ""}`
              : null,
          ]
            .filter(Boolean)
            .join("\n");

          return (
            <div
              key={info.id}
              style={{
                ...styles.itemStyles(isHovered, flashType, hasError),
                ...(info.disposed && {
                  opacity: 0.6,
                  borderLeft: `3px solid #666`,
                  backgroundColor: "#2a2a2a",
                  filter: "grayscale(100%)",
                }),
              }}
              title={hoverTitle}
              onClick={() => setExpandedSignal(isExpanded ? null : info.id)}
              onMouseEnter={() => setHoveredItem(`signal-${info.id}`)}
              onMouseLeave={() => setHoveredItem(null)}
            >
              <div style={styles.itemHeaderStyles}>
                <span style={styles.itemNameStyles}>
                  <span
                    style={{
                      ...styles.badgeStyles(info.kind),
                      ...(info.disposed && {
                        backgroundColor: "#444",
                        color: "#888",
                      }),
                    }}
                  >
                    {info.disposed ? "‚úï" : info.kind === "mutable" ? "M" : "C"}
                  </span>
                  <span
                    style={{
                      overflow: "hidden",
                      textOverflow: "ellipsis",
                      ...(info.disposed && {
                        textDecoration: "line-through",
                        color: "#666",
                      }),
                    }}
                  >
                    {info.name}
                  </span>
                  {info.disposed && (
                    <span
                      style={{
                        color: "#888",
                        fontSize: "9px",
                        marginLeft: "6px",
                        flexShrink: 0,
                        backgroundColor: "#333",
                        padding: "1px 4px",
                        borderRadius: "3px",
                      }}
                    >
                      disposed
                    </span>
                  )}
                </span>
                <div style={styles.signalActionsContainerStyles}>
                  {/* View events button */}
                  <button
                    style={styles.signalActionButtonStyles}
                    onClick={(e) => {
                      e.stopPropagation();
                      setSearchQuery(info.name);
                      setEventKindFilter("all");
                      updateActiveTab("events");
                    }}
                    title="View events for this signal"
                  >
                    <IconHistory size={12} />
                  </button>
                  {/* Reset button for mutable signals */}
                  {!info.disposed && info.kind === "mutable" && (
                    <button
                      style={styles.signalActionButtonStyles}
                      onClick={(e) => {
                        e.stopPropagation();
                        try {
                          (info.signal as any).reset();
                        } catch (err) {
                          console.error("Reset failed:", err);
                        }
                      }}
                      title="Reset to initial value"
                    >
                      <IconResetSmall size={12} />
                    </button>
                  )}
                  {/* Refresh button for computed signals */}
                  {!info.disposed && info.kind === "computed" && (
                    <button
                      style={styles.signalActionButtonStyles}
                      onClick={(e) => {
                        e.stopPropagation();
                        try {
                          const sig = info.signal as any;
                          if (sig.paused?.()) {
                            sig.resume();
                          } else {
                            // Force re-read to refresh
                            sig();
                          }
                        } catch (err) {
                          console.error("Refresh failed:", err);
                        }
                      }}
                      title="Refresh / Resume if paused"
                    >
                      <IconRefresh size={12} />
                    </button>
                  )}
                  {/* Delete button for disposed signals */}
                  {info.disposed && (
                    <button
                      style={{
                        ...styles.signalActionButtonStyles,
                        color: "#888",
                      }}
                      onClick={(e) => {
                        e.stopPropagation();
                        deleteSignal(info.id);
                      }}
                      title="Remove from devtools"
                    >
                      <IconTrash size={12} />
                    </button>
                  )}
                </div>
              </div>
              <div
                style={{
                  ...styles.valueStyles,
                  ...(info.disposed && { color: "#555" }),
                  ...(hasError && { color: styles.colors.errorText }),
                }}
              >
                {!info.disposed && (
                  <span
                    style={{
                      color: styles.colors.textMuted,
                      marginRight: "4px",
                    }}
                  >
                    {info.changeCount}√ó
                  </span>
                )}
                {hasError
                  ? `‚ö† ${String(currentValue)}`
                  : formatValue(currentValue)}
              </div>

              {/* Edit form for mutable signals */}
              {editingSignal === info.id && info.kind === "mutable" && (
                <div
                  style={{
                    marginTop: "6px",
                    paddingTop: "6px",
                    borderTop: `1px solid ${styles.colors.border}`,
                  }}
                  onClick={(e) => e.stopPropagation()}
                >
                  <textarea
                    value={editValue}
                    onChange={(e) => {
                      setEditValue(e.target.value);
                      setEditError(null);
                    }}
                    style={{
                      width: "100%",
                      minHeight: "60px",
                      backgroundColor: styles.colors.bg,
                      border: editError
                        ? `1px solid ${styles.colors.error}`
                        : `1px solid ${styles.colors.border}`,
                      borderRadius: "4px",
                      color: styles.colors.text,
                      fontSize: "10px",
                      fontFamily: styles.fontMono,
                      padding: "6px",
                      resize: "vertical",
                      outline: "none",
                    }}
                    placeholder="Enter JSON value..."
                    autoFocus
                  />
                  {editError && (
                    <div
                      style={{
                        color: styles.colors.error,
                        fontSize: "9px",
                        marginTop: "4px",
                      }}
                    >
                      {editError}
                    </div>
                  )}
                  <div
                    style={{
                      display: "flex",
                      gap: "6px",
                      marginTop: "6px",
                      justifyContent: "flex-end",
                      flexWrap: "nowrap",
                    }}
                  >
                    <button
                      style={{
                        ...styles.signalActionButtonStyles,
                        width: "auto",
                        height: "auto",
                        padding: "4px 10px",
                        whiteSpace: "nowrap",
                      }}
                      onClick={() => {
                        setEditingSignal(null);
                        setEditError(null);
                      }}
                    >
                      Cancel
                    </button>
                    <button
                      style={{
                        ...styles.signalActionButtonStyles,
                        width: "auto",
                        height: "auto",
                        padding: "4px 10px",
                        backgroundColor: styles.colors.mutable + "33",
                        color: styles.colors.mutable,
                        whiteSpace: "nowrap",
                      }}
                      onClick={() => {
                        try {
                          const parsed = JSON.parse(editValue);
                          (info.signal as any).set(parsed);
                          setEditingSignal(null);
                          setEditError(null);
                        } catch (err) {
                          setEditError(
                            err instanceof Error ? err.message : "Invalid JSON"
                          );
                        }
                      }}
                    >
                      Set Value
                    </button>
                  </div>
                </div>
              )}

              {isExpanded && (
                <div
                  style={{
                    marginTop: "6px",
                    paddingTop: "6px",
                    borderTop: `1px solid ${styles.colors.border}`,
                  }}
                >
                  {/* Full signal name */}
                  <div
                    style={{
                      fontSize: "10px",
                      color: styles.colors.text,
                      marginBottom: "8px",
                      wordBreak: "break-all",
                      fontFamily: styles.fontMono,
                    }}
                  >
                    <span style={{ color: styles.colors.textMuted, fontSize: "9px" }}>
                      Name:{" "}
                    </span>
                    {info.name}
                  </div>

                  {/* Full value with actions */}
                  {!info.disposed && (
                    <div style={{ marginBottom: "8px" }}>
                      <div
                        style={{
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "space-between",
                          marginBottom: "4px",
                        }}
                      >
                        <span
                          style={{
                            fontSize: "9px",
                            color: styles.colors.textMuted,
                          }}
                        >
                          Value:
                        </span>
                        <div style={{ display: "flex", gap: "4px" }}>
                          {/* Copy button */}
                          <button
                            style={styles.signalActionButtonStyles}
                            onClick={(e) => {
                              e.stopPropagation();
                              try {
                                if (hasError) {
                                  navigator.clipboard.writeText(String(signalError));
                                } else {
                                  const value = info.signal.tryGet();
                                  const json = JSON.stringify(value, null, 2);
                                  navigator.clipboard.writeText(json);
                                }
                              } catch (err) {
                                console.error("Copy failed:", err);
                              }
                            }}
                            title={hasError ? "Copy error message" : "Copy JSON value"}
                          >
                            <IconCopy size={12} />
                          </button>
                          {/* Edit button for mutable signals */}
                          {info.kind === "mutable" && !hasError && (
                            <button
                              style={styles.signalActionButtonStyles}
                              onClick={(e) => {
                                e.stopPropagation();
                                try {
                                  const value = info.signal.tryGet();
                                  setEditValue(JSON.stringify(value, null, 2));
                                  setEditError(null);
                                  setEditingSignal(info.id);
                                } catch (err) {
                                  console.error("Edit failed:", err);
                                }
                              }}
                              title="Edit value (JSON)"
                            >
                              <IconEdit size={12} />
                            </button>
                          )}
                        </div>
                      </div>
                      <pre
                        style={{
                          margin: 0,
                          padding: "6px",
                          backgroundColor: styles.colors.bg,
                          borderRadius: "4px",
                          fontSize: "9px",
                          color: hasError ? styles.colors.errorText : styles.colors.text,
                          overflow: "auto",
                          maxHeight: "150px",
                          whiteSpace: "pre-wrap",
                          wordBreak: "break-all",
                          fontFamily: styles.fontMono,
                        }}
                      >
                        {hasError
                          ? `‚ö† ${String(signalError)}`
                          : formatValueFull(currentValue)}
                      </pre>
                    </div>
                  )}

                  {/* Source location */}
                  {info.source && (
                    <div
                      style={{
                        fontSize: "9px",
                        color: styles.colors.textMuted,
                        marginBottom: info.history.length > 0 ? "6px" : 0,
                      }}
                    >
                      <span style={{ opacity: 0.6 }}>üìç</span>{" "}
                      <span
                        style={{ color: styles.colors.textDim }}
                        title={info.source.functionName || undefined}
                      >
                        {info.source.file}:{info.source.line}
                      </span>
                      {info.source.functionName && (
                        <span style={{ opacity: 0.6 }}>
                          {" "}
                          ({info.source.functionName})
                        </span>
                      )}
                    </div>
                  )}
                  {/* History */}
                  {info.history.length > 0 && (
                    <div style={{ marginTop: "6px" }}>
                      <div
                        style={{
                          fontSize: "9px",
                          color: styles.colors.textMuted,
                          marginBottom: "4px",
                        }}
                      >
                        History:
                      </div>
                      {info.history.slice(0, 5).map((entry, i) => (
                        <div
                          key={i}
                          style={{
                            display: "flex",
                            alignItems: "center",
                            gap: "4px",
                            fontSize: "9px",
                            color: styles.colors.textDim,
                            marginBottom: "2px",
                          }}
                        >
                          <span style={{ color: styles.colors.textMuted }}>
                            {formatTime(entry.timestamp)}
                          </span>
                          <span style={{ flex: 1, overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" }}>
                            ‚Üí {formatValue(entry.value)}
                          </span>
                          <button
                            style={{
                              ...styles.signalActionButtonStyles,
                              width: "18px",
                              height: "18px",
                              flexShrink: 0,
                            }}
                            onClick={(e) => {
                              e.stopPropagation();
                              try {
                                const json = JSON.stringify(entry.value, null, 2);
                                navigator.clipboard.writeText(json);
                              } catch (err) {
                                console.error("Copy failed:", err);
                              }
                            }}
                            title="Copy value"
                          >
                            <IconCopy size={10} />
                          </button>
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              )}
            </div>
          );
        })}
      </div>
    );
  };

  const renderTags = () => {
    if (tags.size === 0) {
      return <div style={styles.emptyStateStyles}>No tags tracked</div>;
    }

    if (filteredTags.length === 0) {
      if (searchLower) {
        return (
          <div style={styles.emptyStateStyles}>
            No tags match "{searchQuery}"
          </div>
        );
      }
      return (
        <div style={styles.emptyStateStyles}>
          No user-named tags
          <div style={{ fontSize: "9px", marginTop: "4px", opacity: 0.7 }}>
            Check "Show #auto" to see {tags.size} auto-generated
          </div>
        </div>
      );
    }

    return (
      <div style={styles.contentGridStyles(position)}>
        {filteredTags.map((info) => {
          const isHovered = hoveredItem === `tag-${info.id}`;
          const isExpanded = expandedTag === info.id;
          const signalIds = Array.from(info.signals);

          return (
            <div
              key={info.id}
              style={styles.itemStyles(isHovered)}
              onMouseEnter={() => setHoveredItem(`tag-${info.id}`)}
              onMouseLeave={() => setHoveredItem(null)}
              onClick={() => setExpandedTag(isExpanded ? null : info.id)}
            >
              <div style={styles.itemHeaderStyles}>
                <span style={styles.itemNameStyles}>
                  <span style={styles.badgeStyles("tag")}>T</span>
                  <span
                    style={{ overflow: "hidden", textOverflow: "ellipsis" }}
                  >
                    {info.id}
                  </span>
                </span>
                <div
                  style={{ display: "flex", alignItems: "center", gap: "6px" }}
                >
                  <span
                    style={{ color: styles.colors.textDim, fontSize: "9px" }}
                  >
                    {info.signals.size} sig
                  </span>
                  <span
                    style={{
                      color: styles.colors.textMuted,
                      fontSize: "8px",
                      transition: "transform 0.2s",
                      transform: isExpanded ? "rotate(90deg)" : "rotate(0deg)",
                    }}
                  >
                    ‚ñ∂
                  </span>
                </div>
              </div>

              {/* Collapsed preview */}
              {!isExpanded && info.signals.size > 0 && (
                <div style={styles.valueStyles}>
                  {signalIds.slice(0, 3).join(", ")}
                  {info.signals.size > 3 && ` +${info.signals.size - 3}`}
                </div>
              )}

              {/* Expanded details box */}
              {isExpanded && (
                <div
                  style={{
                    marginTop: "8px",
                    paddingTop: "8px",
                    borderTop: `1px solid ${styles.colors.border}`,
                  }}
                  onClick={(e) => e.stopPropagation()}
                >
                  <div
                    style={{
                      fontSize: "9px",
                      color: styles.colors.textMuted,
                      marginBottom: "6px",
                      fontWeight: 600,
                    }}
                  >
                    Signals ({info.signals.size})
                  </div>
                  {info.signals.size === 0 ? (
                    <div
                      style={{
                        fontSize: "10px",
                        color: styles.colors.textDim,
                        fontStyle: "italic",
                      }}
                    >
                      No signals in this tag
                    </div>
                  ) : (
                    <div
                      style={{
                        display: "flex",
                        flexDirection: "column",
                        gap: "4px",
                        maxHeight: "200px",
                        overflowY: "auto",
                      }}
                    >
                      {signalIds.map((signalId) => {
                        const signalInfo = signals.get(signalId);
                        const isDisposed = signalInfo?.disposed;

                        return (
                          <div
                            key={signalId}
                            style={{
                              display: "flex",
                              alignItems: "center",
                              gap: "6px",
                              padding: "4px 6px",
                              backgroundColor: styles.colors.bgHover,
                              borderRadius: "4px",
                              cursor: "pointer",
                              ...(isDisposed && {
                                opacity: 0.5,
                                textDecoration: "line-through",
                              }),
                            }}
                            onClick={(e) => {
                              e.stopPropagation();
                              setSearchQuery(signalId);
                              setSignalKindFilter("all");
                              updateActiveTab("signals");
                            }}
                            title={`Go to signal: ${signalId}`}
                          >
                            <span
                              style={{
                                ...styles.badgeStyles(
                                  signalInfo?.kind || "mutable"
                                ),
                                ...(isDisposed && {
                                  backgroundColor: "#444",
                                  color: "#888",
                                }),
                              }}
                            >
                              {isDisposed
                                ? "‚úï"
                                : signalInfo?.kind === "computed"
                                ? "C"
                                : "M"}
                            </span>
                            <span
                              style={{
                                fontSize: "10px",
                                color: styles.colors.text,
                                flex: 1,
                                overflow: "hidden",
                                textOverflow: "ellipsis",
                                whiteSpace: "nowrap",
                              }}
                            >
                              {signalId}
                            </span>
                            {signalInfo && !isDisposed && (
                              <span
                                style={{
                                  fontSize: "9px",
                                  color: styles.colors.textDim,
                                  maxWidth: "100px",
                                  overflow: "hidden",
                                  textOverflow: "ellipsis",
                                  whiteSpace: "nowrap",
                                }}
                              >
                                {(() => {
                                  const val = signalInfo.signal.tryGet();
                                  if (isPromiseLike(val)) {
                                    const state = loadable(val);
                                    if (state.status === "success")
                                      return formatValue(state.value);
                                    if (state.status === "error")
                                      return `‚ö† ${String(state.error)}`;
                                    return "[async]";
                                  }
                                  return formatValue(val);
                                })()}
                              </span>
                            )}
                          </div>
                        );
                      })}
                    </div>
                  )}
                </div>
              )}
            </div>
          );
        })}
      </div>
    );
  };

  const clearEvents = () => {
    setEvents([]);
  };

  const renderEvents = () => {
    return (
      <div style={{ display: "flex", flexDirection: "column", height: "100%" }}>
        {filteredEvents.length === 0 ? (
          <div style={styles.emptyStateStyles}>
            {events.length === 0 ? "No events yet" : "No matching events"}
          </div>
        ) : (
          <div
            style={{
              ...styles.eventLogStyles,
              flex: 1,
              overflowY: "auto",
              maxHeight: "none",
            }}
          >
            {filteredEvents.map((event) => {
              // Get signal name for display (lookup by ID if needed)
              let signalName: string | null = null;
              if ("signal" in event && event.signal) {
                signalName = (event.signal as any).name || (event.signal as any).id;
              } else if ("signalId" in event) {
                const info = signals.get(String(event.signalId));
                signalName = info?.name || String(event.signalId);
              }
              const tagId = "tagId" in event ? String(event.tagId) : null;
              const isEventExpanded = expandedEvents.has(event.id);

              // Handle both value and error events
              let valueStr: string | null = null;
              let errorContext: string | null = null;
              if ("value" in event) {
                valueStr = JSON.stringify(event.value, null, 2);
              } else if ("error" in event && event.error) {
                const err = event.error as any;
                valueStr = err.message || String(err.error);
                // Show error context (when/async)
                if (err.context) {
                  errorContext = `${err.context.when}${err.context.async ? " (async)" : ""}`;
                }
              }

              return (
                <div
                  key={event.id}
                  style={{
                    ...styles.eventItemStyles,
                    cursor: valueStr ? "pointer" : "default",
                    flexDirection: "column",
                    alignItems: "flex-start",
                    gap: "4px",
                    ...(event.isError && {
                      backgroundColor: `${styles.colors.error}15`,
                      borderLeft: `3px solid ${styles.colors.error}`,
                    }),
                  }}
                  onClick={() => {
                    if (valueStr) {
                      setExpandedEvents((prev) => {
                        const next = new Set(prev);
                        if (next.has(event.id)) {
                          next.delete(event.id);
                        } else {
                          next.add(event.id);
                        }
                        return next;
                      });
                    }
                  }}
                >
                  <div
                    style={{
                      display: "flex",
                      alignItems: "center",
                      gap: "6px",
                      width: "100%",
                      flex: 1,
                      minWidth: 0,
                      overflow: "hidden",
                    }}
                  >
                    <span
                      style={{
                        color: styles.colors.textMuted,
                        fontSize: "8px",
                        minWidth: "50px",
                        flexShrink: 0,
                      }}
                    >
                      {formatTime(event.timestamp)}
                    </span>
                    <span
                      style={styles.eventTypeStyles(event.type, event.isError)}
                    >
                      {event.type.split(":")[1] === "change"
                        ? "update"
                        : event.type.split(":")[1]}
                    </span>
                    {errorContext && (
                      <span
                        style={{
                          fontSize: "8px",
                          padding: "1px 4px",
                          borderRadius: "3px",
                          backgroundColor: `${styles.colors.error}30`,
                          color: styles.colors.errorText,
                          fontFamily: styles.fontMono,
                        }}
                        title="Error context: when the error occurred"
                      >
                        {errorContext}
                      </span>
                    )}
                    <span
                      style={{
                        color: styles.colors.textDim,
                        flex: 1,
                        overflow: "hidden",
                        textOverflow: "ellipsis",
                        whiteSpace: "nowrap",
                      }}
                    >
                      {signalName && (
                        <span
                          style={{
                            cursor: "pointer",
                            textDecoration: "underline",
                            textDecorationStyle: "dotted",
                          }}
                          onClick={(e) => {
                            e.stopPropagation();
                            setSearchQuery(signalName);
                            setSignalKindFilter("all");
                            updateActiveTab("signals");
                          }}
                          title={`Go to signal: ${signalName}`}
                        >
                          {signalName}
                        </span>
                      )}
                      {tagId && (
                        <span
                          style={{
                            cursor: "pointer",
                            textDecoration: "underline",
                            textDecorationStyle: "dotted",
                          }}
                          onClick={(e) => {
                            e.stopPropagation();
                            setSearchQuery(tagId);
                            updateActiveTab("tags");
                          }}
                          title={`Go to tag: ${tagId}`}
                        >
                          {tagId}
                        </span>
                      )}
                    </span>
                    {valueStr && (
                      <button
                        style={{
                          ...styles.signalActionButtonStyles,
                          flexShrink: 0,
                        }}
                        onClick={(e) => {
                          e.stopPropagation();
                          try {
                            navigator.clipboard.writeText(valueStr);
                          } catch (err) {
                            console.error("Copy failed:", err);
                          }
                        }}
                        title="Copy value"
                      >
                        <IconCopy size={12} />
                      </button>
                    )}
                    {valueStr && (
                      <span
                        style={{
                          color: styles.colors.textMuted,
                          flexShrink: 0,
                          display: "flex",
                          alignItems: "center",
                        }}
                      >
                        {isEventExpanded ? (
                          <IconChevronDown size={12} />
                        ) : (
                          <IconChevronRight size={12} />
                        )}
                      </span>
                    )}
                  </div>
                  {/* Value on second line */}
                  {valueStr && !isEventExpanded && (
                    <div
                      style={{
                        fontSize: "9px",
                        color: styles.colors.textMuted,
                        overflow: "hidden",
                        textOverflow: "ellipsis",
                        whiteSpace: "nowrap",
                        width: "100%",
                        fontFamily: styles.fontMono,
                      }}
                    >
                      {formatValue((event as any).value)}
                    </div>
                  )}
                  {isEventExpanded && valueStr && (
                    <pre
                      style={{
                        margin: "6px 0 0 0",
                        padding: "6px",
                        backgroundColor: styles.colors.bg,
                        borderRadius: "4px",
                        fontSize: "9px",
                        color: styles.colors.text,
                        overflow: "auto",
                        maxHeight: "200px",
                        width: "100%",
                        whiteSpace: "pre-wrap",
                        wordBreak: "break-all",
                      }}
                    >
                      {valueStr}
                    </pre>
                  )}
                </div>
              );
            })}
          </div>
        )}
      </div>
    );
  };

  // Render chains tab
  const renderChains = () => {
    // Filter chains by signal name
    const filteredChains = chainFilter
      ? chains.filter((chain) =>
          chain.path.some((signalId) =>
            signalId.toLowerCase().includes(chainFilter.toLowerCase())
          )
        )
      : chains;

    if (chains.length === 0) {
      return (
        <div
          style={{
            ...styles.emptyStateStyles,
            textAlign: "center",
            padding: "32px",
          }}
        >
          <div style={{ fontSize: "24px", marginBottom: "4px" }}>üîó</div>
          <div style={{ marginBottom: "4px" }}>
            No chain reactions detected yet
          </div>
          <div style={{ fontSize: "11px", color: styles.colors.textMuted }}>
            Chain reactions with 2+ signals will appear here
          </div>
        </div>
      );
    }

    if (filteredChains.length === 0) {
      return (
        <div
          style={{
            ...styles.emptyStateStyles,
            textAlign: "center",
            padding: "32px",
          }}
        >
          <div style={{ marginBottom: "8px" }}>No chains match filter</div>
          <div style={{ fontSize: "11px", color: styles.colors.textMuted }}>
            {chains.length} chain{chains.length !== 1 ? "s" : ""} total
          </div>
        </div>
      );
    }

    return (
      <div style={{ display: "flex", flexDirection: "column", gap: "6px" }}>
        {filteredChains.map((chain) => {
          const isExpanded = expandedChain === chain.id;
          const occurrenceCount = chain.occurrences.length;

          return (
            <div
              key={chain.id}
              style={{
                backgroundColor: styles.colors.bgLight,
                borderRadius: "6px",
                border: `1px solid ${styles.colors.border}`,
                overflow: "hidden",
              }}
            >
              {/* Chain header */}
              <div
                style={{
                  padding: "10px 12px",
                  display: "flex",
                  alignItems: "center",
                  gap: "8px",
                  cursor: "pointer",
                  backgroundColor: isExpanded
                    ? styles.colors.bgHover
                    : "transparent",
                }}
                onClick={() => setExpandedChain(isExpanded ? null : chain.id)}
              >
                {/* Expand arrow */}
                <span
                  style={{
                    fontSize: "10px",
                    color: styles.colors.textMuted,
                    transition: "transform 0.15s",
                    transform: isExpanded ? "rotate(90deg)" : "rotate(0deg)",
                  }}
                >
                  ‚ñ∂
                </span>

                {/* Chain path */}
                <div
                  style={{
                    flex: 1,
                    fontSize: "11px",
                    fontFamily: styles.fontMono,
                    display: "flex",
                    flexWrap: "wrap",
                    alignItems: "center",
                    gap: "4px",
                  }}
                >
                  {chain.path.map((signalId, idx) => (
                    <React.Fragment key={idx}>
                      <span
                        style={{
                          color: chain.asyncSignals.has(signalId)
                            ? styles.colors.warning
                            : styles.colors.text,
                          cursor: "pointer",
                        }}
                        onClick={(e) => {
                          e.stopPropagation();
                          setSearchQuery(signalId);
                          setSignalKindFilter("all");
                          updateActiveTab("signals");
                        }}
                        title={`Go to signal: ${signalId}`}
                      >
                        {signalId}
                        {chain.asyncSignals.has(signalId) && (
                          <span
                            style={{
                              fontSize: "8px",
                              marginLeft: "2px",
                              color: styles.colors.warning,
                            }}
                          >
                            [async]
                          </span>
                        )}
                      </span>
                      {idx < chain.path.length - 1 && (
                        <span style={{ color: styles.colors.textMuted }}>
                          ‚Üí
                        </span>
                      )}
                    </React.Fragment>
                  ))}
                </div>

                {/* Occurrence count */}
                <span
                  style={{
                    fontSize: "10px",
                    color: styles.colors.textMuted,
                    backgroundColor: styles.colors.bgHover,
                    padding: "2px 6px",
                    borderRadius: "10px",
                  }}
                >
                  √ó{occurrenceCount}
                </span>

                {/* Delete button */}
                <button
                  style={{
                    ...styles.signalActionButtonStyles,
                    padding: "2px 6px",
                    fontSize: "10px",
                  }}
                  onClick={(e) => {
                    e.stopPropagation();
                    deleteChain(chain.id);
                    setChains(getChainsList());
                  }}
                  title="Delete chain"
                >
                  <IconClose size={12} />
                </button>
              </div>

              {/* Expanded: occurrence history */}
              {isExpanded && (
                <div
                  style={{
                    borderTop: `1px solid ${styles.colors.border}`,
                    padding: "8px 12px",
                    maxHeight: "200px",
                    overflowY: "auto",
                  }}
                >
                  <div
                    style={{
                      fontSize: "10px",
                      color: styles.colors.textMuted,
                      marginBottom: "8px",
                    }}
                  >
                    Recent occurrences:
                  </div>
                  {chain.occurrences.slice(0, 20).map((occ, idx) => (
                    <div
                      key={idx}
                      style={{
                        display: "flex",
                        alignItems: "center",
                        gap: "8px",
                        fontSize: "10px",
                        padding: "4px 0",
                        borderBottom:
                          idx < chain.occurrences.length - 1
                            ? `1px solid ${styles.colors.border}`
                            : "none",
                      }}
                    >
                      <span style={{ color: styles.colors.textDim }}>
                        {new Date(occ.startTime).toLocaleTimeString()}
                      </span>
                      {occ.duration !== undefined && (
                        <span
                          style={{
                            color: styles.colors.textMuted,
                            backgroundColor: styles.colors.bgHover,
                            padding: "1px 4px",
                            borderRadius: "3px",
                          }}
                        >
                          {occ.duration}ms
                        </span>
                      )}
                      <span
                        style={{
                          color:
                            occ.status === "complete"
                              ? styles.colors.success
                              : occ.status === "interrupted"
                              ? styles.colors.error
                              : styles.colors.warning,
                        }}
                      >
                        {occ.status === "complete"
                          ? "‚úì"
                          : occ.status === "interrupted"
                          ? "‚úï"
                          : "‚è≥"}
                      </span>
                    </div>
                  ))}
                  {chain.occurrences.length > 20 && (
                    <div
                      style={{
                        fontSize: "9px",
                        color: styles.colors.textMuted,
                        textAlign: "center",
                        marginTop: "8px",
                      }}
                    >
                      ... and {chain.occurrences.length - 20} more
                    </div>
                  )}
                </div>
              )}
            </div>
          );
        })}
      </div>
    );
  };

  const renderContent = () => {
    if (!enabled) {
      return (
        <div style={styles.warningBoxStyles}>
          <div style={{ marginBottom: "4px" }}>‚ö†Ô∏è DevTools not enabled</div>
          <div style={{ fontSize: "10px", opacity: 0.8 }}>
            Call{" "}
            <code
              style={{
                backgroundColor: "rgba(0,0,0,0.3)",
                padding: "1px 4px",
                borderRadius: "2px",
              }}
            >
              enableDevTools()
            </code>{" "}
            before creating signals
          </div>
        </div>
      );
    }

    switch (activeTab) {
      case "signals":
        return renderSignals();
      case "tags":
        return renderTags();
      case "events":
        return renderEvents();
      case "chains":
        return renderChains();
    }
  };

  // Calculate counts for tabs
  const errorEventsCount = events.filter((e) => e.isError).length;

  const getTabCount = (tab: Tab): string => {
    if (!enabled) return "";
    if (tab === "signals") {
      const count = filteredSignals.length;
      return count !== signals.size ? `${count}/${signals.size}` : `${count}`;
    }
    if (tab === "tags") {
      const count = filteredTags.length;
      return count !== tags.size ? `${count}/${tags.size}` : `${count}`;
    }
    // Events tab count is handled separately in renderTabLabel
    if (tab === "events") return "";
    return "";
  };

  const renderTabLabel = (tab: Tab) => {
    const label = tab.charAt(0).toUpperCase() + tab.slice(1);
    const count = getTabCount(tab);
    const isActive = activeTab === tab;

    // Only show counts when tab is active
    if (!isActive) {
      return label;
    }

    if (tab === "events" && enabled) {
      return (
        <>
          {label} (
          {errorEventsCount > 0 && (
            <span style={{ color: styles.colors.error }}>
              {errorEventsCount}
            </span>
          )}
          {errorEventsCount > 0 && "/"}
          {events.length})
        </>
      );
    }

    if (tab === "chains") {
      return chains.length > 0 ? `Chains (${chains.length})` : "Chains";
    }

    return count ? `${label} (${count})` : label;
  };

  const isLeftCollapsed = position === "left" && !isExpanded;
  const currentSize = position === "bottom" ? sizeBottom : sizeLeft;

  return (
    <div style={styles.panelContainerStyles(position)}>
      <div
        ref={panelRef}
        style={{
          ...styles.panelStyles(
            isExpanded,
            position,
            currentSize ?? undefined,
            isResizing
          ),
          position: "relative",
        }}
      >
        {/* Resize handle - only show when expanded */}
        {isExpanded && (
          <div
            style={styles.resizeHandleStyles(position, isResizing)}
            onMouseDown={handleResizeStart}
            onTouchStart={handleResizeStart}
          >
            <div style={styles.resizeHandleGripStyles(position)} />
          </div>
        )}

        {/* Header - clickable to toggle */}
        <div
          style={styles.headerStyles(position, isExpanded)}
          onClick={togglePanel}
        >
          <h3 style={styles.titleStyles(isLeftCollapsed)}>
            <span style={{ color: "#fbbf24" }}>
              <IconBolt size={18} />
            </span>
            {!isLeftCollapsed && <span>Rextive</span>}
          </h3>

          <div
            style={{
              ...styles.headerRightStyles,
              flexDirection: isLeftCollapsed ? "column" : "row",
            }}
          >
            {/* Reset config button */}
            {!isLeftCollapsed && (
              <button
                style={styles.positionButtonStyles}
                onClick={(e) => {
                  e.stopPropagation();
                  resetConfig();
                }}
                title="Reset DevTools settings"
              >
                <IconReset size={14} />
              </button>
            )}

            {/* Position toggle - hidden in mobile mode */}
            {!isMobile && (
              <button
                style={styles.positionButtonStyles}
                onClick={(e) => {
                  e.stopPropagation();
                  togglePosition();
                }}
                title={
                  position === "bottom" ? "Move to left" : "Move to bottom"
                }
              >
                {position === "bottom" ? <IconArrowLeft /> : <IconArrowDown />}
              </button>
            )}

            {/* Expand/Collapse toggle */}
            <button
              style={styles.toggleButtonStyles}
              onClick={(e) => {
                e.stopPropagation();
                togglePanel();
              }}
              title={isExpanded ? "Collapse" : "Expand"}
            >
              {position === "bottom" ? (
                isExpanded ? (
                  <IconChevronDown />
                ) : (
                  <IconChevronUp />
                )
              ) : isExpanded ? (
                <IconChevronLeft />
              ) : (
                <IconChevronRight />
              )}
            </button>
          </div>
        </div>

        {/* Tabs + Content (only when expanded) */}
        {isExpanded && (
          <>
            <div style={styles.tabsContainerStyles}>
              {(["signals", "tags", "events", "chains"] as Tab[]).map((tab) => (
                <button
                  key={tab}
                  style={styles.tabStyles(activeTab === tab)}
                  onClick={() => updateActiveTab(tab)}
                >
                  {renderTabLabel(tab)}
                </button>
              ))}
            </div>

            {/* Search box */}
            <div style={styles.searchContainerStyles}>
              <div
                style={{ display: "flex", alignItems: "center", gap: "8px" }}
              >
                {/* Clear all disposed button - only in signals tab */}
                {activeTab === "signals" && stats.disposedCount > 0 && (
                  <button
                    style={{
                      padding: "4px 8px",
                      fontSize: "10px",
                      backgroundColor: "#66666633",
                      border: `1px solid #666`,
                      borderRadius: "4px",
                      color: "#888",
                      cursor: "pointer",
                      fontFamily: "inherit",
                      display: "flex",
                      alignItems: "center",
                      gap: "4px",
                      whiteSpace: "nowrap",
                    }}
                    onClick={(e) => {
                      e.stopPropagation();
                      clearDisposed();
                    }}
                    title={`Clear all ${stats.disposedCount} disposed signal${
                      stats.disposedCount !== 1 ? "s" : ""
                    }`}
                  >
                    <IconTrash size={12} /> {stats.disposedCount}
                  </button>
                )}
                {/* Search/filter box - different for chains tab */}
                {activeTab === "chains" ? (
                  <div style={{ ...styles.searchBoxStyles, flex: 1 }}>
                    <span style={styles.searchIconStyles}>üîç</span>
                    <input
                      type="text"
                      placeholder="Filter by signal name..."
                      value={chainFilter}
                      onChange={(e) => setChainFilter(e.target.value)}
                      style={styles.searchInputStyles}
                      onClick={(e) => e.stopPropagation()}
                    />
                    {chainFilter && (
                      <button
                        style={styles.searchClearStyles}
                        onClick={(e) => {
                          e.stopPropagation();
                          setChainFilter("");
                        }}
                        title="Clear filter"
                      >
                        <IconClose size={10} />
                      </button>
                    )}
                  </div>
                ) : (
                  <div style={{ ...styles.searchBoxStyles, flex: 1 }}>
                    <span style={styles.searchIconStyles}>üîç</span>
                    <input
                      type="text"
                      placeholder={`Search ${activeTab}...`}
                      value={searchQuery}
                      onChange={(e) => setSearchQuery(e.target.value)}
                      style={styles.searchInputStyles}
                      onClick={(e) => e.stopPropagation()}
                    />
                    {searchQuery && (
                      <button
                        style={styles.searchClearStyles}
                        onClick={(e) => {
                          e.stopPropagation();
                          setSearchQuery("");
                        }}
                        title="Clear search"
                      >
                        <IconClose size={10} />
                      </button>
                    )}
                  </div>
                )}
              </div>

              {/* Signal filters - only shown on signals tab */}
              {activeTab === "signals" && (
                <div
                  style={{
                    display: "flex",
                    alignItems: "center",
                    gap: "6px",
                    marginTop: "6px",
                    flexWrap: "wrap",
                  }}
                >
                  {/* Kind filter buttons */}
                  <div style={{ display: "flex", gap: "2px" }}>
                    {(
                      [
                        "all",
                        "mutable",
                        "computed",
                        "error",
                        "disposed",
                      ] as const
                    ).map((kind) => {
                      const isActive = signalKindFilter === kind;
                      const label =
                        kind === "all"
                          ? "A"
                          : kind === "mutable"
                          ? "M"
                          : kind === "computed"
                          ? "C"
                          : kind === "error"
                          ? "E"
                          : "D";
                      const color =
                        kind === "mutable"
                          ? styles.colors.mutable
                          : kind === "computed"
                          ? styles.colors.computed
                          : kind === "error"
                          ? styles.colors.error
                          : kind === "disposed"
                          ? "#666"
                          : styles.colors.text;
                      const count =
                        kind === "all"
                          ? signals.size
                          : kind === "mutable"
                          ? stats.mutableCount
                          : kind === "computed"
                          ? stats.computedCount
                          : kind === "error"
                          ? stats.signalsWithErrors
                          : stats.disposedCount;

                      // Emphasize E filter when there are errors
                      const hasErrors =
                        kind === "error" && stats.signalsWithErrors > 0;

                      return (
                        <button
                          key={kind}
                          style={{
                            padding: "3px 8px",
                            fontSize: "10px",
                            fontWeight: 600,
                            backgroundColor:
                              isActive || hasErrors
                                ? color + "33"
                                : styles.colors.bgHover,
                            border: `1px solid ${
                              isActive || hasErrors
                                ? color
                                : styles.colors.border
                            }`,
                            borderRadius: "4px",
                            color:
                              isActive || hasErrors
                                ? color
                                : styles.colors.textMuted,
                            cursor: "pointer",
                            fontFamily: "inherit",
                            display: "flex",
                            alignItems: "center",
                            gap: "4px",
                            ...(hasErrors &&
                              !isActive && {
                                animation: "pulse 2s infinite",
                              }),
                          }}
                          onClick={() => setSignalKindFilter(kind)}
                          title={`Show ${kind} signals`}
                        >
                          {label}
                          <span
                            style={{
                              fontWeight: 400,
                              fontSize: "9px",
                              opacity: 0.8,
                            }}
                          >
                            {count}
                          </span>
                        </button>
                      );
                    })}
                  </div>

                  {/* Sort & Filter toggles */}
                  <div
                    style={{ display: "flex", gap: "6px", marginLeft: "auto" }}
                  >
                    {/* Recent activity sort toggle */}
                    <button
                      style={{
                        padding: "3px 8px",
                        fontSize: "10px",
                        backgroundColor: recentActivitySort
                          ? styles.colors.warning + "33"
                          : styles.colors.bgHover,
                        border: `1px solid ${
                          recentActivitySort
                            ? styles.colors.warning
                            : styles.colors.border
                        }`,
                        borderRadius: "4px",
                        color: recentActivitySort
                          ? styles.colors.warning
                          : styles.colors.textMuted,
                        cursor: "pointer",
                        fontFamily: "inherit",
                      }}
                      onClick={() => setRecentActivitySort(!recentActivitySort)}
                      title={
                        recentActivitySort
                          ? "Sort by default (active first)"
                          : "Sort by recent activity"
                      }
                    >
                      üïê
                    </button>

                    {/* User/All toggle */}
                    <button
                      style={{
                        padding: "3px 8px",
                        fontSize: "10px",
                        backgroundColor: showAutoGenerated
                          ? styles.colors.accent + "33"
                          : styles.colors.bgHover,
                        border: `1px solid ${
                          showAutoGenerated
                            ? styles.colors.accent
                            : styles.colors.border
                        }`,
                        borderRadius: "4px",
                        color: showAutoGenerated
                          ? styles.colors.accent
                          : styles.colors.textMuted,
                        cursor: "pointer",
                        fontFamily: "inherit",
                      }}
                      onClick={() =>
                        updateShowAutoGenerated(!showAutoGenerated)
                      }
                      title={
                        showAutoGenerated
                          ? "Hide auto-generated signals"
                          : "Show all signals (including #auto)"
                      }
                    >
                      {showAutoGenerated ? "#auto" : "user"}
                    </button>
                  </div>
                </div>
              )}

              {/* Event filters - only shown on events tab */}
              {activeTab === "events" && (
                <div
                  style={{
                    display: "flex",
                    alignItems: "center",
                    gap: "6px",
                    marginTop: "6px",
                    flexWrap: "wrap",
                  }}
                >
                  <div style={{ display: "flex", gap: "2px" }}>
                    {(
                      ["all", "error", "update", "create", "dispose"] as const
                    ).map((kind) => {
                      const isActive = eventKindFilter === kind;
                      const label =
                        kind === "all"
                          ? "A"
                          : kind === "error"
                          ? "E"
                          : kind === "update"
                          ? "U"
                          : kind === "create"
                          ? "C"
                          : "D";
                      const color =
                        kind === "error"
                          ? styles.colors.error
                          : kind === "update"
                          ? styles.colors.warning
                          : kind === "create"
                          ? styles.colors.success
                          : kind === "dispose"
                          ? "#666"
                          : styles.colors.text;
                      const count =
                        kind === "all"
                          ? events.length
                          : kind === "error"
                          ? events.filter(
                              (e) => e.isError || e.type === "signal:error"
                            ).length
                          : kind === "update"
                          ? events.filter((e) => e.type === "signal:change")
                              .length
                          : kind === "create"
                          ? events.filter(
                              (e) =>
                                e.type === "signal:create" ||
                                e.type === "tag:create"
                            ).length
                          : events.filter((e) => e.type === "signal:dispose")
                              .length;

                      // Emphasize error filter when there are errors
                      const hasErrors =
                        kind === "error" &&
                        events.some(
                          (e) => e.isError || e.type === "signal:error"
                        );

                      return (
                        <button
                          key={kind}
                          style={{
                            padding: "3px 8px",
                            fontSize: "10px",
                            fontWeight: 600,
                            backgroundColor:
                              isActive || hasErrors
                                ? color + "33"
                                : styles.colors.bgHover,
                            border: `1px solid ${
                              isActive || hasErrors
                                ? color
                                : styles.colors.border
                            }`,
                            borderRadius: "4px",
                            color:
                              isActive || hasErrors
                                ? color
                                : styles.colors.textMuted,
                            cursor: "pointer",
                            fontFamily: "inherit",
                            display: "flex",
                            alignItems: "center",
                            gap: "4px",
                            ...(hasErrors &&
                              !isActive && {
                                animation: "pulse 2s infinite",
                              }),
                          }}
                          onClick={() => setEventKindFilter(kind)}
                          title={`Show ${kind} events`}
                        >
                          {label}
                          <span
                            style={{
                              fontWeight: 400,
                              fontSize: "9px",
                              opacity: 0.8,
                            }}
                          >
                            {count}
                          </span>
                        </button>
                      );
                    })}
                  </div>

                  {/* Clear button */}
                  <button
                    style={{
                      padding: "3px 8px",
                      fontSize: "10px",
                      backgroundColor: styles.colors.bgHover,
                      border: `1px solid ${styles.colors.border}`,
                      borderRadius: "4px",
                      color: styles.colors.textMuted,
                      cursor: events.length === 0 ? "not-allowed" : "pointer",
                      opacity: events.length === 0 ? 0.5 : 1,
                      fontFamily: "inherit",
                      marginLeft: "auto",
                    }}
                    onClick={clearEvents}
                    disabled={events.length === 0}
                    title="Clear all events"
                  >
                    Clear
                  </button>
                </div>
              )}
            </div>

            <div style={styles.contentStyles}>{renderContent()}</div>
          </>
        )}
      </div>
    </div>
  );
}
