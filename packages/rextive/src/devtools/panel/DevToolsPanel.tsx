/**
 * DevTools Panel Component
 *
 * A bottom drawer panel for inspecting Rextive signals and tags.
 * Uses pure React state (no signals) to avoid circular dependencies.
 * Responsive design for mobile devices.
 */

import React, { useState, useEffect, useCallback, useRef } from "react";
import type { SignalInfo, TagInfo, DevToolsEvent } from "../types";
import {
  isDevToolsEnabled,
  getSignals,
  getTags,
  getStats,
  onDevToolsEvent,
  clearDisposed,
} from "../index";
import { isAutoGeneratedName } from "../../utils/nameGenerator";
import { loadable } from "../../utils/loadable";
import { isPromiseLike } from "../../utils/isPromiseLike";
import * as styles from "./styles";
import type { PanelPosition } from "./styles";

type Tab = "signals" | "tags" | "events";

const STORAGE_KEY = "rextive-devtools-config";

interface DevToolsConfig {
  position: PanelPosition;
  expanded: boolean;
  activeTab: Tab;
  showAutoGenerated: boolean;
  sizeBottom: number | null;
  sizeLeft: number | null;
}

const DEFAULT_CONFIG: DevToolsConfig = {
  position: "left",
  expanded: false,
  activeTab: "signals",
  showAutoGenerated: false,
  sizeBottom: null,
  sizeLeft: null,
};

// Load config from localStorage
const loadConfig = (): DevToolsConfig => {
  try {
    const saved = localStorage.getItem(STORAGE_KEY);
    if (saved) {
      const parsed = JSON.parse(saved);
      return { ...DEFAULT_CONFIG, ...parsed };
    }
  } catch {
    // Ignore localStorage errors
  }
  return DEFAULT_CONFIG;
};

// Save config to localStorage
const saveConfig = (config: Partial<DevToolsConfig>) => {
  try {
    const current = loadConfig();
    localStorage.setItem(
      STORAGE_KEY,
      JSON.stringify({ ...current, ...config })
    );
  } catch {
    // Ignore localStorage errors
  }
};

// Clear all persisted config
const clearConfig = () => {
  try {
    localStorage.removeItem(STORAGE_KEY);
  } catch {
    // Ignore localStorage errors
  }
};

type EventLogEntry = DevToolsEvent & {
  id: number;
  timestamp: number;
  isError?: boolean;
};

export function DevToolsPanel(): React.ReactElement | null {
  // Load initial config
  const initialConfig = useRef(loadConfig()).current;

  const [isExpanded, setIsExpanded] = useState(initialConfig.expanded);
  const [position, setPosition] = useState<PanelPosition>(
    initialConfig.position
  );
  const [activeTab, setActiveTab] = useState<Tab>(initialConfig.activeTab);
  const [showAutoGenerated, setShowAutoGenerated] = useState(
    initialConfig.showAutoGenerated
  );
  const [sizeBottom, setSizeBottom] = useState<number | null>(
    initialConfig.sizeBottom
  );
  const [sizeLeft, setSizeLeft] = useState<number | null>(
    initialConfig.sizeLeft
  );
  const [isResizing, setIsResizing] = useState(false);

  const [signals, setSignals] = useState<Map<string, SignalInfo>>(new Map());
  const [tags, setTags] = useState<Map<string, TagInfo>>(new Map());
  const [events, setEvents] = useState<EventLogEntry[]>([]);
  const [stats, setStats] = useState({
    signalCount: 0,
    mutableCount: 0,
    computedCount: 0,
    tagCount: 0,
    totalChanges: 0,
    totalErrors: 0,
    signalsWithErrors: 0,
    disposedCount: 0,
  });
  const [enabled, setEnabled] = useState(false);
  const [expandedSignal, setExpandedSignal] = useState<string | null>(null);
  const [hoveredItem, setHoveredItem] = useState<string | null>(null);
  const [flashingSignals, setFlashingSignals] = useState<
    Map<string, "change" | "create">
  >(new Map());
  const [searchQuery, setSearchQuery] = useState("");
  const [editingSignal, setEditingSignal] = useState<string | null>(null);
  const [editValue, setEditValue] = useState("");
  const [editError, setEditError] = useState<string | null>(null);
  const [expandedEvents, setExpandedEvents] = useState<Set<number>>(new Set());
  const [signalKindFilter, setSignalKindFilter] = useState<
    "all" | "mutable" | "computed" | "error" | "disposed"
  >("all");
  const eventIdRef = useRef(0);
  const flashTimeoutsRef = useRef<Map<string, NodeJS.Timeout>>(new Map());
  const panelRef = useRef<HTMLDivElement>(null);

  // Persist config changes
  const togglePosition = useCallback(() => {
    setPosition((prev) => {
      const next = prev === "bottom" ? "left" : "bottom";
      saveConfig({ position: next });
      return next;
    });
  }, []);

  const updateActiveTab = useCallback((tab: Tab) => {
    setActiveTab(tab);
    saveConfig({ activeTab: tab });
  }, []);

  const updateShowAutoGenerated = useCallback((show: boolean) => {
    setShowAutoGenerated(show);
    saveConfig({ showAutoGenerated: show });
  }, []);

  const resetConfig = useCallback(() => {
    clearConfig();
    setIsExpanded(DEFAULT_CONFIG.expanded);
    setPosition(DEFAULT_CONFIG.position);
    setActiveTab(DEFAULT_CONFIG.activeTab);
    setShowAutoGenerated(DEFAULT_CONFIG.showAutoGenerated);
    setSizeBottom(DEFAULT_CONFIG.sizeBottom);
    setSizeLeft(DEFAULT_CONFIG.sizeLeft);
  }, []);

  // Resize handlers
  const handleResizeStart = useCallback(
    (e: React.MouseEvent) => {
      e.preventDefault();
      e.stopPropagation();
      setIsResizing(true);

      const startY = e.clientY;
      const startX = e.clientX;
      const startSize =
        position === "bottom"
          ? sizeBottom ?? styles.PANEL_SIZE_EXPANDED_BOTTOM
          : sizeLeft ?? styles.PANEL_SIZE_EXPANDED_LEFT;

      const handleMouseMove = (e: MouseEvent) => {
        if (position === "bottom") {
          // For bottom panel, dragging up increases size
          const delta = startY - e.clientY;
          const newSize = Math.max(
            styles.PANEL_MIN_SIZE_BOTTOM,
            Math.min(styles.PANEL_MAX_SIZE_BOTTOM, startSize + delta)
          );
          setSizeBottom(newSize);
        } else {
          // For left panel, dragging right increases size
          const delta = e.clientX - startX;
          const newSize = Math.max(
            styles.PANEL_MIN_SIZE_LEFT,
            Math.min(styles.PANEL_MAX_SIZE_LEFT, startSize + delta)
          );
          setSizeLeft(newSize);
        }
      };

      const handleMouseUp = () => {
        setIsResizing(false);
        document.removeEventListener("mousemove", handleMouseMove);
        document.removeEventListener("mouseup", handleMouseUp);
        document.body.style.cursor = "";
        document.body.style.userSelect = "";

        // Save the new size
        if (position === "bottom") {
          saveConfig({ sizeBottom: sizeBottom });
        } else {
          saveConfig({ sizeLeft: sizeLeft });
        }
      };

      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);
      document.body.style.cursor =
        position === "bottom" ? "ns-resize" : "ew-resize";
      document.body.style.userSelect = "none";
    },
    [position, sizeBottom, sizeLeft]
  );

  // Save size after resize ends
  useEffect(() => {
    if (!isResizing) {
      if (position === "bottom" && sizeBottom !== null) {
        saveConfig({ sizeBottom });
      } else if (position === "left" && sizeLeft !== null) {
        saveConfig({ sizeLeft });
      }
    }
  }, [isResizing, position, sizeBottom, sizeLeft]);

  // Manage body padding to prevent content from being hidden by devtools
  useEffect(() => {
    const updateBodyPadding = () => {
      if (position === "bottom" && isExpanded) {
        // Add padding to bottom when panel is at bottom and expanded
        const height = sizeBottom ?? styles.PANEL_SIZE_EXPANDED_BOTTOM;
        document.body.style.paddingBottom = `${height}px`;
        document.body.style.paddingLeft = "";
      } else if (position === "left" && isExpanded) {
        // Add padding to left when panel is at left and expanded
        const width = sizeLeft ?? styles.PANEL_SIZE_EXPANDED_LEFT;
        document.body.style.paddingLeft = `${width}px`;
        document.body.style.paddingBottom = "";
      } else {
        // Remove padding when panel is collapsed
        if (position === "bottom") {
          document.body.style.paddingBottom = `${styles.PANEL_SIZE_COLLAPSED}px`;
          document.body.style.paddingLeft = "";
        } else {
          document.body.style.paddingLeft = `${styles.PANEL_SIZE_COLLAPSED}px`;
          document.body.style.paddingBottom = "";
        }
      }
    };

    updateBodyPadding();

    // Cleanup: remove padding when component unmounts
    return () => {
      document.body.style.paddingBottom = "";
      document.body.style.paddingLeft = "";
    };
  }, [position, isExpanded, sizeBottom, sizeLeft]);

  // Check if devtools is enabled
  useEffect(() => {
    const checkEnabled = () => {
      setEnabled(isDevToolsEnabled());
    };

    checkEnabled();
    const interval = setInterval(checkEnabled, 1000);
    return () => clearInterval(interval);
  }, []);

  // Refresh data periodically when expanded
  useEffect(() => {
    if (!enabled) return;

    const refresh = () => {
      setSignals(new Map(getSignals()));
      setTags(new Map(getTags()));
      setStats(getStats());
    };

    refresh();
    const interval = setInterval(refresh, 500);
    return () => clearInterval(interval);
  }, [enabled]);

  // Subscribe to events
  useEffect(() => {
    if (!enabled) return;

    const unsubscribe = onDevToolsEvent((event) => {
      // Check if this is an error event (signal has error after change)
      let isError = false;
      if (event.type === "signal:change" && "signalId" in event) {
        const signalInfo = getSignals().get(event.signalId);
        if (signalInfo?.signal?.error?.()) {
          isError = true;
        }
      }

      const entry: EventLogEntry = {
        ...event,
        id: eventIdRef.current++,
        timestamp: Date.now(),
        isError,
      };
      setEvents((prev) => [entry, ...prev].slice(0, 100));

      const flashSignal = (signalId: string, type: "change" | "create") => {
        const existingTimeout = flashTimeoutsRef.current.get(signalId);
        if (existingTimeout) clearTimeout(existingTimeout);

        setFlashingSignals((prev) => new Map(prev).set(signalId, type));

        const timeout = setTimeout(() => {
          setFlashingSignals((prev) => {
            const next = new Map(prev);
            next.delete(signalId);
            return next;
          });
          flashTimeoutsRef.current.delete(signalId);
        }, 600);

        flashTimeoutsRef.current.set(signalId, timeout);
      };

      if (event.type === "signal:change" && "signalId" in event) {
        flashSignal(event.signalId, "change");
      } else if (event.type === "signal:create" && "signal" in event) {
        flashSignal(event.signal.id, "create");
      }
    });

    return () => {
      unsubscribe();
      flashTimeoutsRef.current.forEach((timeout) => clearTimeout(timeout));
      flashTimeoutsRef.current.clear();
    };
  }, [enabled]);

  const togglePanel = useCallback(() => {
    setIsExpanded((prev) => {
      const next = !prev;
      saveConfig({ expanded: next });
      return next;
    });
  }, []);

  const formatValue = (value: unknown): string => {
    if (value === undefined) return "undefined";
    if (value === null) return "null";
    if (typeof value === "function") return "[Function]";
    if (typeof value === "symbol") return value.toString();
    try {
      const str = JSON.stringify(value);
      return str.length > 40 ? str.slice(0, 40) + "‚Ä¶" : str;
    } catch {
      return String(value);
    }
  };

  const formatTime = (timestamp: number): string => {
    const date = new Date(timestamp);
    return date.toLocaleTimeString("en-US", {
      hour12: false,
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
    });
  };

  // Filter signals/tags based on showAutoGenerated and search query
  const searchLower = searchQuery.toLowerCase().trim();

  const filteredSignals = Array.from(signals.values()).filter((s) => {
    // Filter by auto-generated
    if (!showAutoGenerated && isAutoGeneratedName(s.id)) return false;
    // Filter by search query
    if (searchLower && !s.id.toLowerCase().includes(searchLower)) return false;
    // Filter by kind
    if (signalKindFilter === "error") {
      if (s.errorCount === 0) return false;
    } else if (signalKindFilter === "disposed") {
      if (!s.disposed) return false;
    } else if (signalKindFilter !== "all" && s.kind !== signalKindFilter) {
      return false;
    }
    return true;
  });

  const filteredTags = Array.from(tags.values()).filter((t) => {
    // Filter by auto-generated
    if (!showAutoGenerated && isAutoGeneratedName(t.id)) return false;
    // Filter by search query
    if (searchLower && !t.id.toLowerCase().includes(searchLower)) return false;
    return true;
  });

  // Filter events by search query
  const filteredEvents = searchLower
    ? events.filter((e) => {
        const signalId = "signalId" in e ? String(e.signalId) : "";
        const tagId = "tagId" in e ? String(e.tagId) : "";
        const type = e.type;
        return (
          signalId.toLowerCase().includes(searchLower) ||
          tagId.toLowerCase().includes(searchLower) ||
          type.toLowerCase().includes(searchLower)
        );
      })
    : events;

  const renderSignals = () => {
    if (signals.size === 0) {
      return <div style={styles.emptyStateStyles}>No signals tracked</div>;
    }

    if (filteredSignals.length === 0) {
      if (searchLower) {
        return (
          <div style={styles.emptyStateStyles}>
            No signals match "{searchQuery}"
          </div>
        );
      }
      return (
        <div style={styles.emptyStateStyles}>
          No user-named signals
          <div style={{ fontSize: "9px", marginTop: "4px", opacity: 0.7 }}>
            Check "Show #auto" to see {signals.size} auto-generated
          </div>
        </div>
      );
    }

    // Sort: active signals first, then disposed
    const sortedSignals = [...filteredSignals].sort((a, b) => {
      if (a.disposed !== b.disposed) return a.disposed ? 1 : -1;
      return 0;
    });

    return (
      <div style={styles.contentGridStyles}>
        {sortedSignals.map((info) => {
          let currentValue: unknown;
          let signalError: unknown = undefined;

          if (info.disposed) {
            currentValue = "[disposed]";
          } else {
            // Check for error first (works for both sync and async signals)
            signalError = info.signal.error();
            if (signalError) {
              currentValue = signalError;
            } else {
              currentValue = info.signal.tryGet();
              // For async signals, show the resolved/rejected value from loadable
              if (isPromiseLike(currentValue)) {
                const state = loadable(currentValue);
                if (state.status === "success") {
                  currentValue = state.value;
                } else if (state.status === "error") {
                  signalError = state.error;
                  currentValue = state.error;
                }
                // If loading, keep showing the Promise
              }
            }
          }

          const isExpanded = expandedSignal === info.id;
          const isHovered = hoveredItem === `signal-${info.id}`;
          const flashType = flashingSignals.get(info.id) || null;
          const hasError = !info.disposed && signalError !== undefined;

          return (
            <div
              key={info.id}
              style={{
                ...styles.itemStyles(isHovered, flashType, hasError),
                ...(info.disposed && {
                  opacity: 0.6,
                  borderLeft: `3px solid #666`,
                  backgroundColor: "#2a2a2a",
                  filter: "grayscale(100%)",
                }),
              }}
              onClick={() => setExpandedSignal(isExpanded ? null : info.id)}
              onMouseEnter={() => setHoveredItem(`signal-${info.id}`)}
              onMouseLeave={() => setHoveredItem(null)}
            >
              <div style={styles.itemHeaderStyles}>
                <span style={styles.itemNameStyles}>
                  <span
                    style={{
                      ...styles.badgeStyles(info.kind),
                      ...(info.disposed && {
                        backgroundColor: "#444",
                        color: "#888",
                      }),
                    }}
                  >
                    {info.disposed ? "‚úï" : info.kind === "mutable" ? "M" : "C"}
                  </span>
                  <span
                    style={{
                      overflow: "hidden",
                      textOverflow: "ellipsis",
                      ...(info.disposed && {
                        textDecoration: "line-through",
                        color: "#666",
                      }),
                    }}
                  >
                    {info.id}
                  </span>
                  <span
                    style={{
                      color: info.disposed ? "#888" : styles.colors.textDim,
                      fontSize: "9px",
                      marginLeft: "6px",
                      flexShrink: 0,
                      ...(info.disposed && {
                        backgroundColor: "#333",
                        padding: "1px 4px",
                        borderRadius: "3px",
                      }),
                    }}
                  >
                    {info.disposed ? "disposed" : `√ó${info.changeCount}`}
                  </span>
                </span>
                <div style={styles.signalActionsContainerStyles}>
                  {/* Copy JSON button */}
                  {!info.disposed && (
                    <button
                      style={styles.signalActionButtonStyles}
                      onClick={(e) => {
                        e.stopPropagation();
                        try {
                          if (hasError) {
                            navigator.clipboard.writeText(String(signalError));
                          } else {
                            const value = info.signal.tryGet();
                            const json = JSON.stringify(value, null, 2);
                            navigator.clipboard.writeText(json);
                          }
                        } catch (err) {
                          console.error("Copy failed:", err);
                        }
                      }}
                      title={
                        hasError ? "Copy error message" : "Copy JSON value"
                      }
                    >
                      üìã
                    </button>
                  )}
                  {/* Edit button for mutable signals (not when has error) */}
                  {!info.disposed && info.kind === "mutable" && !hasError && (
                    <button
                      style={styles.signalActionButtonStyles}
                      onClick={(e) => {
                        e.stopPropagation();
                        try {
                          const value = info.signal.tryGet();
                          setEditValue(JSON.stringify(value, null, 2));
                          setEditError(null);
                          setEditingSignal(info.id);
                        } catch (err) {
                          console.error("Edit failed:", err);
                        }
                      }}
                      title="Edit value (JSON)"
                    >
                      ‚úèÔ∏è
                    </button>
                  )}
                  {/* View events button */}
                  <button
                    style={styles.signalActionButtonStyles}
                    onClick={(e) => {
                      e.stopPropagation();
                      setSearchQuery(info.id);
                      updateActiveTab("events");
                    }}
                    title="View events for this signal"
                  >
                    üìú
                  </button>
                  {/* Reset button for mutable signals */}
                  {!info.disposed && info.kind === "mutable" && (
                    <button
                      style={styles.signalActionButtonStyles}
                      onClick={(e) => {
                        e.stopPropagation();
                        try {
                          (info.signal as any).reset();
                        } catch (err) {
                          console.error("Reset failed:", err);
                        }
                      }}
                      title="Reset to initial value"
                    >
                      ‚Ü∫
                    </button>
                  )}
                  {/* Refresh button for computed signals */}
                  {!info.disposed && info.kind === "computed" && (
                    <button
                      style={styles.signalActionButtonStyles}
                      onClick={(e) => {
                        e.stopPropagation();
                        try {
                          const sig = info.signal as any;
                          if (sig.paused?.()) {
                            sig.resume();
                          } else {
                            // Force re-read to refresh
                            sig();
                          }
                        } catch (err) {
                          console.error("Refresh failed:", err);
                        }
                      }}
                      title="Refresh / Resume if paused"
                    >
                      ‚ü≥
                    </button>
                  )}
                </div>
              </div>
              <div
                style={{
                  ...styles.valueStyles,
                  ...(info.disposed && { color: "#555" }),
                  ...(hasError && { color: styles.colors.errorText }),
                }}
              >
                {hasError
                  ? `‚ö† ${String(currentValue)}`
                  : formatValue(currentValue)}
              </div>

              {/* Edit form for mutable signals */}
              {editingSignal === info.id && info.kind === "mutable" && (
                <div
                  style={{
                    marginTop: "6px",
                    paddingTop: "6px",
                    borderTop: `1px solid ${styles.colors.border}`,
                  }}
                  onClick={(e) => e.stopPropagation()}
                >
                  <textarea
                    value={editValue}
                    onChange={(e) => {
                      setEditValue(e.target.value);
                      setEditError(null);
                    }}
                    style={{
                      width: "100%",
                      minHeight: "60px",
                      backgroundColor: styles.colors.bgHover,
                      border: editError
                        ? `1px solid ${styles.colors.error}`
                        : `1px solid ${styles.colors.border}`,
                      borderRadius: "4px",
                      color: styles.colors.text,
                      fontSize: "10px",
                      fontFamily: "inherit",
                      padding: "6px",
                      resize: "vertical",
                      outline: "none",
                    }}
                    placeholder="Enter JSON value..."
                    autoFocus
                  />
                  {editError && (
                    <div
                      style={{
                        color: styles.colors.error,
                        fontSize: "9px",
                        marginTop: "4px",
                      }}
                    >
                      {editError}
                    </div>
                  )}
                  <div
                    style={{
                      display: "flex",
                      gap: "6px",
                      marginTop: "6px",
                      justifyContent: "flex-end",
                    }}
                  >
                    <button
                      style={{
                        ...styles.signalActionButtonStyles,
                        padding: "4px 10px",
                      }}
                      onClick={() => {
                        setEditingSignal(null);
                        setEditError(null);
                      }}
                    >
                      Cancel
                    </button>
                    <button
                      style={{
                        ...styles.signalActionButtonStyles,
                        padding: "4px 10px",
                        backgroundColor: styles.colors.mutable + "33",
                        color: styles.colors.mutable,
                      }}
                      onClick={() => {
                        try {
                          const parsed = JSON.parse(editValue);
                          (info.signal as any).set(parsed);
                          setEditingSignal(null);
                          setEditError(null);
                        } catch (err) {
                          setEditError(
                            err instanceof Error ? err.message : "Invalid JSON"
                          );
                        }
                      }}
                    >
                      Set Value
                    </button>
                  </div>
                </div>
              )}

              {isExpanded && info.history.length > 0 && (
                <div
                  style={{
                    marginTop: "6px",
                    paddingTop: "6px",
                    borderTop: `1px solid ${styles.colors.border}`,
                  }}
                >
                  {info.history.slice(0, 5).map((entry, i) => (
                    <div
                      key={i}
                      style={{
                        fontSize: "9px",
                        color: styles.colors.textDim,
                        marginBottom: "1px",
                      }}
                    >
                      <span style={{ color: styles.colors.textMuted }}>
                        {formatTime(entry.timestamp)}
                      </span>
                      {" ‚Üí "}
                      {formatValue(entry.value)}
                    </div>
                  ))}
                </div>
              )}
            </div>
          );
        })}
      </div>
    );
  };

  const renderTags = () => {
    if (tags.size === 0) {
      return <div style={styles.emptyStateStyles}>No tags tracked</div>;
    }

    if (filteredTags.length === 0) {
      if (searchLower) {
        return (
          <div style={styles.emptyStateStyles}>
            No tags match "{searchQuery}"
          </div>
        );
      }
      return (
        <div style={styles.emptyStateStyles}>
          No user-named tags
          <div style={{ fontSize: "9px", marginTop: "4px", opacity: 0.7 }}>
            Check "Show #auto" to see {tags.size} auto-generated
          </div>
        </div>
      );
    }

    return (
      <div style={styles.contentGridStyles}>
        {filteredTags.map((info) => {
          const isHovered = hoveredItem === `tag-${info.id}`;

          return (
            <div
              key={info.id}
              style={styles.itemStyles(isHovered)}
              onMouseEnter={() => setHoveredItem(`tag-${info.id}`)}
              onMouseLeave={() => setHoveredItem(null)}
            >
              <div style={styles.itemHeaderStyles}>
                <span style={styles.itemNameStyles}>
                  <span style={styles.badgeStyles("tag")}>T</span>
                  <span
                    style={{ overflow: "hidden", textOverflow: "ellipsis" }}
                  >
                    {info.id}
                  </span>
                </span>
                <span style={{ color: styles.colors.textDim, fontSize: "9px" }}>
                  {info.signals.size} sig
                </span>
              </div>
              {info.signals.size > 0 && (
                <div style={styles.valueStyles}>
                  {Array.from(info.signals).slice(0, 3).join(", ")}
                  {info.signals.size > 3 && ` +${info.signals.size - 3}`}
                </div>
              )}
            </div>
          );
        })}
      </div>
    );
  };

  const clearEvents = () => {
    setEvents([]);
  };

  const renderEvents = () => {
    return (
      <div style={{ display: "flex", flexDirection: "column", height: "100%" }}>
        {/* Clear button */}
        <div
          style={{
            display: "flex",
            justifyContent: "flex-end",
            padding: "4px 8px",
            borderBottom: `1px solid ${styles.colors.border}`,
            flexShrink: 0,
          }}
        >
          <button
            onClick={clearEvents}
            style={{
              padding: "2px 8px",
              fontSize: "10px",
              backgroundColor: styles.colors.bgHover,
              border: `1px solid ${styles.colors.border}`,
              borderRadius: "4px",
              color: styles.colors.textMuted,
              cursor: "pointer",
            }}
            disabled={events.length === 0}
          >
            Clear ({events.length})
          </button>
        </div>

        {filteredEvents.length === 0 ? (
          <div style={styles.emptyStateStyles}>
            {events.length === 0 ? "No events yet" : "No matching events"}
          </div>
        ) : (
          <div
            style={{
              ...styles.eventLogStyles,
              flex: 1,
              overflowY: "auto",
              maxHeight: "none",
            }}
          >
            {filteredEvents.map((event) => {
              const signalId =
                "signalId" in event ? String(event.signalId) : null;
              const tagId = "tagId" in event ? String(event.tagId) : null;
              const isEventExpanded = expandedEvents.has(event.id);
              const valueStr =
                "value" in event ? JSON.stringify(event.value, null, 2) : null;
              const hasLongValue = valueStr && valueStr.length > 50;

              return (
                <div
                  key={event.id}
                  style={{
                    ...styles.eventItemStyles,
                    cursor: hasLongValue ? "pointer" : "default",
                    flexDirection: isEventExpanded ? "column" : "row",
                    alignItems: isEventExpanded ? "flex-start" : "center",
                    ...(event.isError && {
                      backgroundColor: `${styles.colors.error}15`,
                      borderLeft: `3px solid ${styles.colors.error}`,
                    }),
                  }}
                  onClick={() => {
                    if (hasLongValue) {
                      setExpandedEvents((prev) => {
                        const next = new Set(prev);
                        if (next.has(event.id)) {
                          next.delete(event.id);
                        } else {
                          next.add(event.id);
                        }
                        return next;
                      });
                    }
                  }}
                >
                  <div
                    style={{
                      display: "flex",
                      alignItems: "center",
                      gap: "6px",
                      width: isEventExpanded ? "100%" : "auto",
                      flex: isEventExpanded ? "none" : 1,
                    }}
                  >
                    <span
                      style={{
                        color: styles.colors.textMuted,
                        fontSize: "8px",
                        minWidth: "50px",
                        flexShrink: 0,
                      }}
                    >
                      {formatTime(event.timestamp)}
                    </span>
                    <span style={styles.eventTypeStyles(event.type)}>
                      {event.type.split(":")[1]}
                    </span>
                    <span
                      style={{
                        color: styles.colors.textDim,
                        flex: 1,
                        overflow: "hidden",
                        textOverflow: "ellipsis",
                        whiteSpace: "nowrap",
                      }}
                    >
                      {signalId && (
                        <span
                          style={{
                            cursor: "pointer",
                            textDecoration: "underline",
                            textDecorationStyle: "dotted",
                          }}
                          onClick={(e) => {
                            e.stopPropagation();
                            setSearchQuery(signalId);
                            updateActiveTab("signals");
                          }}
                          title={`Go to signal: ${signalId}`}
                        >
                          {signalId}
                        </span>
                      )}
                      {tagId && (
                        <span
                          style={{
                            cursor: "pointer",
                            textDecoration: "underline",
                            textDecorationStyle: "dotted",
                          }}
                          onClick={(e) => {
                            e.stopPropagation();
                            setSearchQuery(tagId);
                            updateActiveTab("tags");
                          }}
                          title={`Go to tag: ${tagId}`}
                        >
                          {tagId}
                        </span>
                      )}
                      {valueStr &&
                        !isEventExpanded &&
                        ` ‚Üí ${formatValue((event as any).value)}`}
                    </span>
                    {valueStr && (
                      <button
                        style={{
                          ...styles.signalActionButtonStyles,
                          padding: "1px 4px",
                          fontSize: "8px",
                        }}
                        onClick={(e) => {
                          e.stopPropagation();
                          try {
                            navigator.clipboard.writeText(valueStr);
                          } catch (err) {
                            console.error("Copy failed:", err);
                          }
                        }}
                        title="Copy value"
                      >
                        üìã
                      </button>
                    )}
                    {hasLongValue && (
                      <span
                        style={{
                          color: styles.colors.textMuted,
                          fontSize: "8px",
                          flexShrink: 0,
                        }}
                      >
                        {isEventExpanded ? "‚ñº" : "‚ñ∂"}
                      </span>
                    )}
                  </div>
                  {isEventExpanded && valueStr && (
                    <pre
                      style={{
                        margin: "6px 0 0 0",
                        padding: "6px",
                        backgroundColor: styles.colors.bgHover,
                        borderRadius: "4px",
                        fontSize: "9px",
                        color: styles.colors.text,
                        overflow: "auto",
                        maxHeight: "200px",
                        width: "100%",
                        whiteSpace: "pre-wrap",
                        wordBreak: "break-all",
                      }}
                    >
                      {valueStr}
                    </pre>
                  )}
                </div>
              );
            })}
          </div>
        )}
      </div>
    );
  };

  const renderContent = () => {
    if (!enabled) {
      return (
        <div style={styles.warningBoxStyles}>
          <div style={{ marginBottom: "4px" }}>‚ö†Ô∏è DevTools not enabled</div>
          <div style={{ fontSize: "10px", opacity: 0.8 }}>
            Call{" "}
            <code
              style={{
                backgroundColor: "rgba(0,0,0,0.3)",
                padding: "1px 4px",
                borderRadius: "2px",
              }}
            >
              enableDevTools()
            </code>{" "}
            before creating signals
          </div>
        </div>
      );
    }

    switch (activeTab) {
      case "signals":
        return renderSignals();
      case "tags":
        return renderTags();
      case "events":
        return renderEvents();
    }
  };

  // Calculate counts for tabs
  const errorEventsCount = events.filter((e) => e.isError).length;

  const getTabCount = (tab: Tab): string => {
    if (!enabled) return "";
    if (tab === "signals") {
      const count = filteredSignals.length;
      return count !== signals.size ? `${count}/${signals.size}` : `${count}`;
    }
    if (tab === "tags") {
      const count = filteredTags.length;
      return count !== tags.size ? `${count}/${tags.size}` : `${count}`;
    }
    // Events tab count is handled separately in renderTabLabel
    if (tab === "events") return "";
    return "";
  };

  const renderTabLabel = (tab: Tab) => {
    const label = tab.charAt(0).toUpperCase() + tab.slice(1);
    const count = getTabCount(tab);

    if (tab === "events" && enabled) {
      return (
        <>
          {label} (
          {errorEventsCount > 0 && (
            <span style={{ color: styles.colors.error }}>
              {errorEventsCount}
            </span>
          )}
          {errorEventsCount > 0 && "/"}
          {events.length})
        </>
      );
    }

    return count ? `${label} (${count})` : label;
  };

  const isLeftCollapsed = position === "left" && !isExpanded;
  const currentSize = position === "bottom" ? sizeBottom : sizeLeft;

  return (
    <div style={styles.panelContainerStyles(position)}>
      <div
        ref={panelRef}
        style={{
          ...styles.panelStyles(
            isExpanded,
            position,
            currentSize ?? undefined,
            isResizing
          ),
          position: "relative",
        }}
      >
        {/* Resize handle - only show when expanded */}
        {isExpanded && (
          <div
            style={styles.resizeHandleStyles(position, isResizing)}
            onMouseDown={handleResizeStart}
          >
            <div style={styles.resizeHandleGripStyles(position)} />
          </div>
        )}

        {/* Header - clickable to toggle */}
        <div
          style={styles.headerStyles(position, isExpanded)}
          onClick={togglePanel}
        >
          <h3 style={styles.titleStyles(isLeftCollapsed)}>
            <span>‚ö°</span>
            {!isLeftCollapsed && <span>Rextive</span>}
          </h3>

          <div
            style={{
              ...styles.headerRightStyles,
              flexDirection: isLeftCollapsed ? "column" : "row",
            }}
          >
            {/* Clear disposed button */}
            {enabled && !isLeftCollapsed && stats.disposedCount > 0 && (
              <button
                style={{
                  ...styles.positionButtonStyles,
                  fontSize: "10px",
                  padding: "3px 8px",
                  borderRadius: "10px",
                  backgroundColor: styles.colors.bgHover,
                  color: styles.colors.textMuted,
                  opacity: 1,
                }}
                onClick={(e) => {
                  e.stopPropagation();
                  clearDisposed();
                }}
                title={`Clear ${stats.disposedCount} disposed signal${
                  stats.disposedCount !== 1 ? "s" : ""
                }`}
              >
                üóë {stats.disposedCount}
              </button>
            )}

            {/* Position toggle */}
            <button
              style={styles.positionButtonStyles}
              onClick={(e) => {
                e.stopPropagation();
                togglePosition();
              }}
              title={position === "bottom" ? "Move to left" : "Move to bottom"}
            >
              {position === "bottom" ? "‚óÄ" : "‚ñº"}
            </button>

            {/* Expand/Collapse toggle */}
            <button
              style={styles.toggleButtonStyles}
              onClick={(e) => {
                e.stopPropagation();
                togglePanel();
              }}
              title={isExpanded ? "Collapse" : "Expand"}
            >
              {position === "bottom"
                ? isExpanded
                  ? "‚ñº"
                  : "‚ñ≤"
                : isExpanded
                ? "‚óÄ"
                : "‚ñ∂"}
            </button>
          </div>
        </div>

        {/* Tabs + Content (only when expanded) */}
        {isExpanded && (
          <>
            <div style={styles.tabsContainerStyles}>
              {(["signals", "tags", "events"] as Tab[]).map((tab) => (
                <button
                  key={tab}
                  style={styles.tabStyles(activeTab === tab)}
                  onClick={() => updateActiveTab(tab)}
                >
                  {renderTabLabel(tab)}
                </button>
              ))}

              {/* Reset config button */}
              <button
                style={styles.resetButtonStyles}
                onClick={(e) => {
                  e.stopPropagation();
                  resetConfig();
                }}
                title="Reset DevTools settings"
              >
                ‚Ü∫
              </button>
            </div>

            {/* Search box */}
            <div style={styles.searchContainerStyles}>
              <div style={styles.searchBoxStyles}>
                <span style={styles.searchIconStyles}>üîç</span>
                <input
                  type="text"
                  placeholder={`Search ${activeTab}...`}
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                  style={styles.searchInputStyles}
                  onClick={(e) => e.stopPropagation()}
                />
                {searchQuery && (
                  <button
                    style={styles.searchClearStyles}
                    onClick={(e) => {
                      e.stopPropagation();
                      setSearchQuery("");
                    }}
                    title="Clear search"
                  >
                    ‚úï
                  </button>
                )}
              </div>

              {/* Signal filters - only shown on signals tab */}
              {activeTab === "signals" && (
                <div
                  style={{
                    display: "flex",
                    alignItems: "center",
                    gap: "6px",
                    marginTop: "6px",
                    flexWrap: "wrap",
                  }}
                >
                  {/* Kind filter buttons */}
                  <div style={{ display: "flex", gap: "2px" }}>
                    {(
                      [
                        "all",
                        "mutable",
                        "computed",
                        "error",
                        "disposed",
                      ] as const
                    ).map((kind) => {
                      const isActive = signalKindFilter === kind;
                      const label =
                        kind === "all"
                          ? "A"
                          : kind === "mutable"
                          ? "M"
                          : kind === "computed"
                          ? "C"
                          : kind === "error"
                          ? "E"
                          : "D";
                      const color =
                        kind === "mutable"
                          ? styles.colors.mutable
                          : kind === "computed"
                          ? styles.colors.computed
                          : kind === "error"
                          ? styles.colors.error
                          : kind === "disposed"
                          ? "#666"
                          : styles.colors.text;
                      const count =
                        kind === "all"
                          ? signals.size
                          : kind === "mutable"
                          ? stats.mutableCount
                          : kind === "computed"
                          ? stats.computedCount
                          : kind === "error"
                          ? stats.signalsWithErrors
                          : stats.disposedCount;

                      // Emphasize E filter when there are errors
                      const hasErrors =
                        kind === "error" && stats.signalsWithErrors > 0;

                      return (
                        <button
                          key={kind}
                          style={{
                            padding: "3px 8px",
                            fontSize: "10px",
                            fontWeight: 600,
                            backgroundColor:
                              isActive || hasErrors
                                ? color + "33"
                                : styles.colors.bgHover,
                            border: `1px solid ${
                              isActive || hasErrors
                                ? color
                                : styles.colors.border
                            }`,
                            borderRadius: "4px",
                            color:
                              isActive || hasErrors
                                ? color
                                : styles.colors.textMuted,
                            cursor: "pointer",
                            fontFamily: "inherit",
                            display: "flex",
                            alignItems: "center",
                            gap: "4px",
                            ...(hasErrors &&
                              !isActive && {
                                animation: "pulse 2s infinite",
                              }),
                          }}
                          onClick={() => setSignalKindFilter(kind)}
                          title={`Show ${kind} signals`}
                        >
                          {label}
                          <span
                            style={{
                              fontWeight: 400,
                              fontSize: "9px",
                              opacity: 0.8,
                            }}
                          >
                            {count}
                          </span>
                        </button>
                      );
                    })}
                  </div>

                  {/* User/All toggle */}
                  <button
                    style={{
                      padding: "3px 8px",
                      fontSize: "10px",
                      backgroundColor: showAutoGenerated
                        ? styles.colors.accent + "33"
                        : styles.colors.bgHover,
                      border: `1px solid ${
                        showAutoGenerated
                          ? styles.colors.accent
                          : styles.colors.border
                      }`,
                      borderRadius: "4px",
                      color: showAutoGenerated
                        ? styles.colors.accent
                        : styles.colors.textMuted,
                      cursor: "pointer",
                      fontFamily: "inherit",
                      marginLeft: "auto",
                    }}
                    onClick={() => updateShowAutoGenerated(!showAutoGenerated)}
                    title={
                      showAutoGenerated
                        ? "Hide auto-generated signals"
                        : "Show all signals (including #auto)"
                    }
                  >
                    {showAutoGenerated ? "#auto" : "user"}
                  </button>
                </div>
              )}
            </div>

            <div style={styles.contentStyles}>{renderContent()}</div>
          </>
        )}
      </div>
    </div>
  );
}
