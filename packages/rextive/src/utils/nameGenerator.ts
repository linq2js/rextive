/**
 * Auto-incrementing counter for generating unique names.
 *
 * Used by devtools to identify signals, tags, etc. when no explicit name is provided.
 * Format: `#{kind}-{counter}` (e.g., "#mutable-1", "#computed-42", "#tag-5")
 *
 * The `#` prefix indicates an auto-generated name (vs user-provided).
 * Use `isAutoGeneratedName()` to check if a name was auto-generated.
 *
 * ## Operator Naming Convention
 *
 * When signals are piped through operators, names follow this pattern:
 *
 * | Type | Format | Example |
 * |------|--------|---------|
 * | User-provided | `{name}` | `pokemonName` |
 * | Auto mutable | `#mutable-N` | `#mutable-1` |
 * | Auto computed | `#computed-N` | `#computed-2` |
 * | Auto notifier | `#notifier-N` | `#notifier-3` |
 * | Operator ID | `#operator-N` | `#debounce-50` |
 * | Operator internal | `#operator-N.suffix` | `#debounce-50.internal` |
 * | Pipe result | `source>#operator-N` | `pokemonName>#debounce-50` |
 * | Chained result | `source>#op1>#op2` | `pokemonName>#debounce-50>#to-51` |
 *
 * @module nameGenerator
 */

let counter = 0;

/**
 * Separate counter for unique signal IDs.
 * This counter is independent from name counter and should never be reset.
 */
let uidCounter = 0;

/**
 * Generate a unique signal ID.
 * Format: "sig-{n}" (e.g., "sig-1", "sig-2", "sig-42")
 *
 * This ID is:
 * - Auto-generated and immutable
 * - Unique across all signals in the application lifecycle
 * - Independent from displayName (which can be changed)
 *
 * @returns Unique signal ID
 */
export function nextUid(): string {
  return `s:${++uidCounter}`;
}

/**
 * Prefix for auto-generated names.
 * Used to distinguish from user-provided names.
 */
export const AUTO_NAME_PREFIX = "#";

/**
 * Separator for pipe chains.
 * Used between source name and operator name.
 */
export const CHAIN_SEPARATOR = ">";

/**
 * Separator for internal signal suffixes.
 * Used between operator name and internal suffix.
 */
export const INTERNAL_SEPARATOR = ".";

/**
 * Valid prefixes for auto-generated names.
 */
export type NamePrefix = "mutable" | "computed" | "tag";

/**
 * Generate a unique name with the given prefix.
 * @param prefix - The prefix to use: "mutable", "computed", or "tag"
 * @returns Name in format "#{prefix}-{n}"
 */
export function nextName(prefix: NamePrefix): string {
  return `${AUTO_NAME_PREFIX}${prefix}-${++counter}`;
}

/**
 * Check if a name was auto-generated (contains #).
 *
 * A name is considered auto-generated if it contains the `#` prefix anywhere,
 * which covers:
 * - Direct auto names: `#mutable-1`, `#computed-2`
 * - Operator results: `pokemonName>#debounce-5`
 * - Chained operators: `pokemonName>#debounce-5>#to-6`
 * - Internal signals: `#debounce-5.i`
 *
 * @param name - The name to check
 * @returns true if the name contains any auto-generated component
 */
export function isAutoGeneratedName(name: string): boolean {
  return name.includes(AUTO_NAME_PREFIX);
}

/**
 * Generate a unique operator ID.
 * Format: "#operator-N" (e.g., "#debounce-50", "#to-51")
 *
 * @param operator - The operator name (e.g., "debounce", "to", "filter")
 * @returns Unique operator ID
 *
 * @example
 * operatorId("debounce") // "#debounce-50"
 * operatorId("to")       // "#to-51"
 */
export function operatorId(operator: string): string {
  return `${AUTO_NAME_PREFIX}${operator}-${++counter}`;
}

/**
 * Generate an internal signal name scoped to an operator.
 * Format: "#operator-N.suffix" (e.g., "#debounce-50.internal")
 *
 * @param opId - The operator ID from operatorId()
 * @param suffix - The internal suffix (e.g., "internal", "buffer")
 * @returns Scoped internal name
 *
 * @example
 * const opId = operatorId("debounce"); // "#debounce-50"
 * internalName(opId, "internal")       // "#debounce-50.internal"
 * internalName(opId, "buffer")         // "#debounce-50.buffer"
 */
export function internalName(opId: string, suffix: string): string {
  return `${opId}${INTERNAL_SEPARATOR}${suffix}`;
}

/**
 * Build a pipe chain name from source and operator.
 * Format: "source>#operator-N" (e.g., "pokemonName>#debounce-50")
 *
 * @param sourceName - The source signal's displayName
 * @param opId - The operator ID from operatorId()
 * @returns Chain name
 *
 * @example
 * const opId = operatorId("debounce"); // "#debounce-50"
 * chainName("pokemonName", opId)       // "pokemonName>#debounce-50"
 * chainName("#mutable-1", opId)        // "#mutable-1>#debounce-50"
 *
 * // Chaining multiple operators
 * const op1 = operatorId("debounce");  // "#debounce-50"
 * const chain1 = chainName("pokemonName", op1); // "pokemonName>#debounce-50"
 * const op2 = operatorId("to");        // "#to-51"
 * chainName(chain1, op2)               // "pokemonName>#debounce-50>#to-51"
 */
export function chainName(sourceName: string, opId: string): string {
  return `${sourceName}${CHAIN_SEPARATOR}${opId}`;
}

/**
 * @deprecated Use operatorId() + chainName() for operators.
 * Prefix a name with AUTO_NAME_PREFIX (#).
 * Useful for generating internal signal names in operators.
 * @param name - The name to prefix
 * @returns Name prefixed with #
 *
 * @example
 * autoPrefix("takeLast_internal") // "#takeLast_internal-N"
 * autoPrefix(`delay(${source.displayName})`) // "#delay(count)-N"
 */
export function autoPrefix(name: string): string {
  return `${AUTO_NAME_PREFIX}${name}-${++counter}`;
}

/**
 * Reset counter (for testing purposes only).
 * @internal
 */
export function resetCounter(): void {
  counter = 0;
}

/**
 * Get current counter value (for debugging/devtools).
 * @internal
 */
export function getCounter(): number {
  return counter;
}
