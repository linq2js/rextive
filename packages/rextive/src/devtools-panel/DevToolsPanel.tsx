/**
 * DevTools Panel Component
 *
 * A bottom drawer panel for inspecting Rextive signals and tags.
 * Uses pure React state (no signals) to avoid circular dependencies.
 * Responsive design for mobile devices.
 */

import React, {
  useState,
  useEffect,
  useCallback,
  useRef,
  useMemo,
  memo,
} from "react";
import type { SignalInfo, TagInfo, ChainReaction } from "../devtools/types";
import {
  isDevToolsEnabled,
  getSignals,
  getTags,
  getStats,
  onDevToolsEvent,
  clearDisposed,
  deleteSignal,
  enableChainTracking,
  disableChainTracking,
  getChainsList,
  deleteChain,
  updateDevToolsConfig,
} from "../devtools";
import { isAutoGeneratedName } from "../utils/nameGenerator";

// Types and configuration
import type {
  Tab,
  EventLogEntry,
  CompareModalState,
  SignalKindFilter,
  EventKindFilter,
} from "./types";
import {
  DEFAULT_CONFIG,
  loadConfig,
  saveConfig,
  clearConfig,
  loadBookmarks,
  saveBookmarks,
} from "./config";
import { formatTime, getTabLabel } from "./utils";

// Hooks
import { useFlash } from "./hooks/useFlash";
import { useSnapshots } from "./hooks/useSnapshots";

// Styles
import * as styles from "./styles";
import type { PanelPosition } from "./styles";

// Tab components
import { SignalsTab } from "./tabs/SignalsTab";
import { TagsTab } from "./tabs/TagsTab";
import { EventsTab } from "./tabs/EventsTab";
import { ChainsTab } from "./tabs/ChainsTab";
import { SnapshotsTab } from "./tabs/SnapshotsTab";

// Icons
import {
  IconReset,
  IconArrowLeft,
  IconArrowDown,
  IconChevronUp,
  IconChevronDown,
  IconChevronLeft,
  IconChevronRight,
  IconTrash,
  IconBolt,
  IconSettings,
} from "./icons";

// Modals and shared components
import { ConfigModal } from "./components/ConfigModal";
import { SearchHelpModal } from "./SearchHelpModal";
import { ValueDiffModal } from "./ValueDiffModal";
import { SnapshotDiffModal, CURRENT_STATE_ID } from "./SnapshotDiffModal";
import { TabBar, TabContent, FilterSeparator } from "./components/shared";
import {
  SignalKindFilters,
  SignalOptionFilters,
  EventKindFilters,
  SnapshotFilters,
} from "./components/filters";
import {
  parseSearchQuery,
  matchesSignalSearch,
  matchesTagSearch,
  matchesEventSearch,
  getSearchPlaceholder,
} from "./searchUtils";

export const DevToolsPanel = memo(
  function DevToolsPanel(): React.ReactElement | null {
    // Load initial config
    const initialConfig = useRef(loadConfig()).current;

    // Panel state
    const [isExpanded, setIsExpanded] = useState(initialConfig.expanded);
    const [position, setPosition] = useState<PanelPosition>(
      initialConfig.position
    );
    const [activeTab, setActiveTab] = useState<Tab>(initialConfig.activeTab);
    const [showAutoGenerated, setShowAutoGenerated] = useState(
      initialConfig.showAutoGenerated
    );
    const [sizeBottom, setSizeBottom] = useState<number | null>(
      initialConfig.sizeBottom
    );
    const [sizeLeft, setSizeLeft] = useState<number | null>(
      initialConfig.sizeLeft
    );
    const [isResizing, setIsResizing] = useState(false);
    const [isMobile, setIsMobile] = useState(
      () => typeof window !== "undefined" && window.innerWidth <= 768
    );

    // Data state
    const [signals, setSignals] = useState<Map<string, SignalInfo>>(new Map());
    const [tags, setTags] = useState<Map<string, TagInfo>>(new Map());
    const [events, setEvents] = useState<EventLogEntry[]>([]);
    const [stats, setStats] = useState({
      signalCount: 0,
      mutableCount: 0,
      computedCount: 0,
      tagCount: 0,
      totalChanges: 0,
      totalErrors: 0,
      signalsWithErrors: 0,
      disposedCount: 0,
    });
    const [enabled, setEnabled] = useState(false);

    // UI state
    const [expandedSignal, setExpandedSignal] = useState<string | null>(null);
    const [hoveredItem, setHoveredItem] = useState<string | null>(null);
    const [searchQuery, setSearchQuery] = useState("");
    const [editingSignal, setEditingSignal] = useState<string | null>(null);
    const [editValue, setEditValue] = useState("");
    const [editError, setEditError] = useState<string | null>(null);
    const [expandedEvents, setExpandedEvents] = useState<Set<number>>(
      new Set()
    );
    const [expandedTag, setExpandedTag] = useState<string | null>(null);
    const [showSearchHelp, setShowSearchHelp] = useState(false);
    const [bookmarkedSignals, setBookmarkedSignals] = useState<Set<string>>(
      () => loadBookmarks()
    );
    const [showBookmarksOnly, setShowBookmarksOnly] = useState(false);
    const [compareModal, setCompareModal] = useState<CompareModalState | null>(
      null
    );
    const [signalKindFilter, setSignalKindFilter] =
      useState<SignalKindFilter>("all");
    const [recentActivitySort, setRecentActivitySort] = useState(true);
    const [eventKindFilter, setEventKindFilter] =
      useState<EventKindFilter>("all");

    // Chain state
    const [chains, setChains] = useState<ChainReaction[]>([]);
    const [expandedChain, setExpandedChain] = useState<string | null>(null);
    const [chainFilter, setChainFilter] = useState("");

    // Snapshot config state
    const [snapshotOnInit, setSnapshotOnInit] = useState(
      initialConfig.snapshotOnInit
    );
    const [snapshotAutoInterval, setSnapshotAutoInterval] = useState(
      initialConfig.snapshotAutoInterval
    );
    const [snapshotBookmarkedOnly, setSnapshotBookmarkedOnly] = useState(
      initialConfig.snapshotBookmarkedOnly
    );
    const [snapshotDiffOpen, setSnapshotDiffOpen] = useState(false);
    const [snapshotDiff1Id, setSnapshotDiff1Id] = useState<string | null>(null);
    const [snapshotDiff2Id, setSnapshotDiff2Id] = useState<string | null>(null);

    // Config modal state
    const [isConfigModalOpen, setIsConfigModalOpen] = useState(false);
    const [autoRemoveDisposedTimer, setAutoRemoveDisposedTimer] = useState(
      initialConfig.autoRemoveDisposedTimer
    );
    const [autoSnapshotIntervalSeconds, setAutoSnapshotIntervalSeconds] =
      useState(initialConfig.autoSnapshotIntervalSeconds);
    const [signalHistoryLimit, setSignalHistoryLimit] = useState(
      initialConfig.signalHistoryLimit
    );

    // Refs
    const panelRef = useRef<HTMLDivElement>(null);
    const showAutoGeneratedRef = useRef(showAutoGenerated);
    showAutoGeneratedRef.current = showAutoGenerated;
    const eventIdRef = useRef(0);
    const disposalTimeoutsRef = useRef<Map<string, NodeJS.Timeout>>(new Map());

    // Flash hook
    const {
      flashingSignals,
      flashingTabs,
      flashAutoToggle,
      flashSignal,
      flashTab,
      setFlashAutoToggle,
      clearFlashAutoToggle,
      cleanup: cleanupFlash,
    } = useFlash();

    // Snapshots hook
    const {
      snapshots,
      expandedSnapshot,
      setExpandedSnapshot,
      editingSnapshotId,
      setEditingSnapshotId,
      editingSnapshotName,
      setEditingSnapshotName,
      snapshotSearch,
      setSnapshotSearch,
      takeSnapshot,
      takeSnapshotForTag,
      deleteSnapshot,
      renameSnapshot,
      revertSnapshot,
      revertSingleSignal,
      clearAllSnapshots,
      getCurrentStateSignals,
    } = useSnapshots({
      signals,
      bookmarkedSignals,
      snapshotBookmarkedOnly,
      snapshotOnInit,
      snapshotAutoInterval,
      autoSnapshotIntervalSeconds,
      enabled,
      flashTab,
    });

    // Mobile mode detection
    useEffect(() => {
      const checkMobile = () => {
        const mobile = window.innerWidth <= 768;
        setIsMobile(mobile);
        if (mobile) {
          setPosition((prev) => (prev !== "bottom" ? "bottom" : prev));
        }
      };

      checkMobile();
      window.addEventListener("resize", checkMobile);
      return () => window.removeEventListener("resize", checkMobile);
    }, []);

    // Persist config changes
    const togglePosition = useCallback(() => {
      setPosition((prev) => {
        const next = prev === "bottom" ? "left" : "bottom";
        saveConfig({ position: next });
        return next;
      });
    }, []);

    const updateActiveTab = useCallback((tab: Tab) => {
      setActiveTab(tab);
      saveConfig({ activeTab: tab });
    }, []);

    const updateShowAutoGenerated = useCallback((show: boolean) => {
      setShowAutoGenerated(show);
      saveConfig({ showAutoGenerated: show });
    }, []);

    const resetConfig = useCallback(() => {
      clearConfig();
      setIsExpanded(DEFAULT_CONFIG.expanded);
      setPosition(DEFAULT_CONFIG.position);
      setActiveTab(DEFAULT_CONFIG.activeTab);
      setShowAutoGenerated(DEFAULT_CONFIG.showAutoGenerated);
      setSizeBottom(DEFAULT_CONFIG.sizeBottom);
      setSizeLeft(DEFAULT_CONFIG.sizeLeft);
      setAutoRemoveDisposedTimer(DEFAULT_CONFIG.autoRemoveDisposedTimer);
      setAutoSnapshotIntervalSeconds(
        DEFAULT_CONFIG.autoSnapshotIntervalSeconds
      );
      setSignalHistoryLimit(DEFAULT_CONFIG.signalHistoryLimit);
      updateDevToolsConfig({ maxHistory: DEFAULT_CONFIG.signalHistoryLimit });
    }, []);

    const handleSettingsChange = useCallback(
      (settings: {
        autoRemoveDisposedTimer: number;
        autoSnapshotInterval: number;
        signalHistoryLimit: number;
      }) => {
        setAutoRemoveDisposedTimer(settings.autoRemoveDisposedTimer);
        setAutoSnapshotIntervalSeconds(settings.autoSnapshotInterval);
        setSignalHistoryLimit(settings.signalHistoryLimit);
        saveConfig({
          autoRemoveDisposedTimer: settings.autoRemoveDisposedTimer,
          autoSnapshotIntervalSeconds: settings.autoSnapshotInterval,
          signalHistoryLimit: settings.signalHistoryLimit,
        });
        updateDevToolsConfig({ maxHistory: settings.signalHistoryLimit });
      },
      []
    );

    const updateSnapshotOnInit = useCallback((value: boolean) => {
      setSnapshotOnInit(value);
      saveConfig({ snapshotOnInit: value });
    }, []);

    const updateSnapshotAutoInterval = useCallback((value: boolean) => {
      setSnapshotAutoInterval(value);
      saveConfig({ snapshotAutoInterval: value });
    }, []);

    const updateSnapshotBookmarkedOnly = useCallback((value: boolean) => {
      setSnapshotBookmarkedOnly(value);
      saveConfig({ snapshotBookmarkedOnly: value });
    }, []);

    const compareSnapshotWithCurrent = useCallback((snapshotId: string) => {
      setSnapshotDiff1Id(snapshotId);
      setSnapshotDiff2Id(CURRENT_STATE_ID);
      setSnapshotDiffOpen(true);
    }, []);

    // Resize handlers
    const handleResizeStart = useCallback(
      (e: React.MouseEvent | React.TouchEvent) => {
        e.preventDefault();
        e.stopPropagation();
        setIsResizing(true);

        const isTouch = "touches" in e;
        const startY = isTouch ? e.touches[0].clientY : e.clientY;
        const startX = isTouch ? e.touches[0].clientX : e.clientX;
        const startSize =
          position === "bottom"
            ? sizeBottom ?? styles.PANEL_SIZE_EXPANDED_BOTTOM
            : sizeLeft ?? styles.PANEL_SIZE_EXPANDED_LEFT;

        const handleMove = (moveEvent: MouseEvent | TouchEvent) => {
          const isTouchMove = "touches" in moveEvent;
          const currentY = isTouchMove
            ? moveEvent.touches[0].clientY
            : moveEvent.clientY;
          const currentX = isTouchMove
            ? moveEvent.touches[0].clientX
            : moveEvent.clientX;

          if (position === "bottom") {
            const delta = startY - currentY;
            const newSize = Math.max(
              styles.PANEL_MIN_SIZE_BOTTOM,
              Math.min(styles.PANEL_MAX_SIZE_BOTTOM, startSize + delta)
            );
            setSizeBottom(newSize);
          } else {
            const delta = currentX - startX;
            const newSize = Math.max(
              styles.PANEL_MIN_SIZE_LEFT,
              Math.min(styles.PANEL_MAX_SIZE_LEFT, startSize + delta)
            );
            setSizeLeft(newSize);
          }
        };

        const handleEnd = () => {
          setIsResizing(false);
          document.removeEventListener("mousemove", handleMove);
          document.removeEventListener("mouseup", handleEnd);
          document.removeEventListener("touchmove", handleMove);
          document.removeEventListener("touchend", handleEnd);
          document.removeEventListener("touchcancel", handleEnd);
          document.body.style.cursor = "";
          document.body.style.userSelect = "";

          if (position === "bottom") {
            saveConfig({ sizeBottom: sizeBottom });
          } else {
            saveConfig({ sizeLeft: sizeLeft });
          }
        };

        document.addEventListener("mousemove", handleMove);
        document.addEventListener("mouseup", handleEnd);
        document.addEventListener("touchmove", handleMove, { passive: false });
        document.addEventListener("touchend", handleEnd);
        document.addEventListener("touchcancel", handleEnd);
        document.body.style.cursor =
          position === "bottom" ? "ns-resize" : "ew-resize";
        document.body.style.userSelect = "none";
      },
      [position, sizeBottom, sizeLeft]
    );

    // Save size after resize ends
    useEffect(() => {
      if (!isResizing) {
        if (position === "bottom" && sizeBottom !== null) {
          saveConfig({ sizeBottom });
        } else if (position === "left" && sizeLeft !== null) {
          saveConfig({ sizeLeft });
        }
      }
    }, [isResizing, position, sizeBottom, sizeLeft]);

    // Manage body padding
    useEffect(() => {
      const updateBodyPadding = () => {
        if (position === "bottom" && isExpanded) {
          const height = sizeBottom ?? styles.PANEL_SIZE_EXPANDED_BOTTOM;
          document.body.style.paddingBottom = `${height}px`;
          document.body.style.paddingLeft = "";
        } else if (position === "left" && isExpanded) {
          const width = sizeLeft ?? styles.PANEL_SIZE_EXPANDED_LEFT;
          document.body.style.paddingLeft = `${width}px`;
          document.body.style.paddingBottom = "";
        } else {
          if (position === "bottom") {
            document.body.style.paddingBottom = `${styles.PANEL_SIZE_COLLAPSED}px`;
            document.body.style.paddingLeft = "";
          } else {
            document.body.style.paddingLeft = `${styles.PANEL_SIZE_COLLAPSED}px`;
            document.body.style.paddingBottom = "";
          }
        }
      };

      updateBodyPadding();

      return () => {
        document.body.style.paddingBottom = "";
        document.body.style.paddingLeft = "";
      };
    }, [position, isExpanded, sizeBottom, sizeLeft]);

    // Check if devtools is enabled
    useEffect(() => {
      const checkEnabled = () => {
        setEnabled(isDevToolsEnabled());
      };

      checkEnabled();
      const interval = setInterval(checkEnabled, 1000);
      return () => clearInterval(interval);
    }, []);

    // Refresh data periodically
    useEffect(() => {
      if (!enabled) return;

      const refresh = () => {
        const existingSignals = getSignals();
        const existingTags = getTags();
        const newStats = getStats();

        setSignals((prev) => {
          if (prev.size !== existingSignals.size)
            return new Map(existingSignals);
          return prev;
        });

        setTags((prev) => {
          if (prev.size !== existingTags.size) return new Map(existingTags);
          return prev;
        });

        setStats((prev) => {
          if (
            prev.mutableCount !== newStats.mutableCount ||
            prev.computedCount !== newStats.computedCount ||
            prev.disposedCount !== newStats.disposedCount ||
            prev.signalsWithErrors !== newStats.signalsWithErrors
          ) {
            return newStats;
          }
          return prev;
        });
      };

      refresh();
      const interval = setInterval(refresh, 500);
      return () => clearInterval(interval);
    }, [enabled]);

    // Auto-remove disposed signals
    useEffect(() => {
      if (!enabled) return;
      if (autoRemoveDisposedTimer < 0) return;

      const currentTimeouts = disposalTimeoutsRef.current;

      signals.forEach((signal, id) => {
        if (signal.disposed && !currentTimeouts.has(id)) {
          if (autoRemoveDisposedTimer === 0) {
            deleteSignal(id);
            setSignals((prev) => {
              const next = new Map(prev);
              next.delete(id);
              return next;
            });
          } else {
            const timeout = setTimeout(() => {
              deleteSignal(id);
              setSignals((prev) => {
                const next = new Map(prev);
                next.delete(id);
                return next;
              });
              currentTimeouts.delete(id);
            }, autoRemoveDisposedTimer * 1000);
            currentTimeouts.set(id, timeout);
          }
        }
      });

      currentTimeouts.forEach((timeout, id) => {
        const signal = signals.get(id);
        if (!signal || !signal.disposed) {
          clearTimeout(timeout);
          currentTimeouts.delete(id);
        }
      });
    }, [enabled, signals, autoRemoveDisposedTimer]);

    // Cleanup disposal timeouts on unmount
    useEffect(() => {
      return () => {
        disposalTimeoutsRef.current.forEach((timeout) => clearTimeout(timeout));
        disposalTimeoutsRef.current.clear();
      };
    }, []);

    // Subscribe to events
    useEffect(() => {
      if (!enabled) return;

      const unsubscribe = onDevToolsEvent((event) => {
        // Defer state updates to avoid "Cannot update a component while rendering"
        // This happens when signal reads during render trigger lazy computation
        queueMicrotask(() => {
          if (event.type === "signals:forget") {
            const forgottenIds = new Set(event.signalIds);
            setEvents((prev) =>
              prev.filter((e) => {
                if (e.type === "signal:create" || e.type === "tag:create") {
                  return true;
                }
                if (
                  "signalId" in e &&
                  typeof e.signalId === "string" &&
                  forgottenIds.has(e.signalId)
                )
                  return false;
                return true;
              })
            );
            setSignals((prev) => {
              const next = new Map(prev);
              for (const id of forgottenIds) {
                next.delete(id);
              }
              return next;
            });
            return;
          }

          let isError = false;
          if (event.type === "signal:error") {
            isError = true;
          } else if (
            event.type === "window:error" ||
            event.type === "window:unhandledrejection"
          ) {
            isError = true;
          } else if (event.type === "signal:change" && "signalId" in event) {
            const signalInfo = getSignals().get(event.signalId);
            if (signalInfo?.signal?.error?.()) {
              isError = true;
            }
          }

          const entry: EventLogEntry = {
            ...event,
            id: eventIdRef.current++,
            timestamp: Date.now(),
            isError,
          };

          setEvents((prev) => {
            const newEvents = [entry, ...prev];
            return newEvents.slice(0, 100);
          });

          if (isError) {
            flashTab("events");
          }

          if (event.type === "signal:change" && "signalId" in event) {
            flashSignal(event.signalId, "change");
            flashTab("signals");
          } else if (event.type === "signal:create" && "signal" in event) {
            flashSignal(event.signal.id, "create");

            if (
              isAutoGeneratedName(event.signal.name) &&
              !showAutoGeneratedRef.current
            ) {
              setFlashAutoToggle(true);
            }
          }
        }); // End queueMicrotask
      });

      return () => {
        unsubscribe();
        cleanupFlash();
      };
    }, [enabled, flashSignal, flashTab, setFlashAutoToggle, cleanupFlash]);

    // Chain tracking
    useEffect(() => {
      if (activeTab === "chains" && enabled) {
        enableChainTracking();
        const interval = setInterval(() => {
          setChains(getChainsList());
        }, 200);
        return () => {
          disableChainTracking();
          clearInterval(interval);
        };
      } else {
        disableChainTracking();
      }
    }, [activeTab, enabled]);

    const togglePanel = useCallback(() => {
      setIsExpanded((prev) => {
        const next = !prev;
        saveConfig({ expanded: next });
        return next;
      });
    }, []);

    const toggleBookmark = useCallback((signalId: string) => {
      setBookmarkedSignals((prev) => {
        const next = new Set(prev);
        if (next.has(signalId)) {
          next.delete(signalId);
        } else {
          next.add(signalId);
        }
        saveBookmarks(next);
        return next;
      });
    }, []);

    // Parse search query
    const parsedQuery = parseSearchQuery(searchQuery);

    // Filter signals
    const filteredSignals = Array.from(signals.values()).filter((s) => {
      if (showBookmarksOnly && !bookmarkedSignals.has(s.id)) {
        return false;
      }
      if (
        !parsedQuery.fields.has("kind") &&
        !parsedQuery.fields.has("error") &&
        !parsedQuery.fields.has("disposed")
      ) {
        if (signalKindFilter === "error") {
          if (s.errorCount === 0) return false;
        } else if (signalKindFilter === "disposed") {
          if (!s.disposed) return false;
        } else if (signalKindFilter !== "all" && s.kind !== signalKindFilter) {
          return false;
        }
      }

      return matchesSignalSearch(
        {
          name: s.name,
          id: s.id,
          kind: s.kind,
          signal: s.signal,
          source: s.source,
          tags: s.tags,
          errorCount: s.errorCount,
          disposed: s.disposed,
        },
        parsedQuery,
        isAutoGeneratedName,
        showAutoGenerated
      );
    });

    // Pre-compute dependents map
    const dependentsMap = useMemo(() => {
      const map = new Map<string, Array<{ id: string; name: string }>>();
      for (const [, info] of signals) {
        if (info.depIds) {
          for (const depId of info.depIds) {
            const existing = map.get(depId) || [];
            existing.push({ id: info.id, name: info.name });
            map.set(depId, existing);
          }
        }
      }
      return map;
    }, [signals]);

    // Filter tags
    const filteredTags = Array.from(tags.values()).filter((t) => {
      return matchesTagSearch(
        { id: t.id },
        parsedQuery,
        isAutoGeneratedName,
        showAutoGenerated
      );
    });

    // Count auto-generated signals
    const autoGeneratedCount = useMemo(() => {
      let count = 0;
      for (const s of signals.values()) {
        if (isAutoGeneratedName(s.name)) count++;
      }
      return count;
    }, [signals]);

    // Filter events
    const filteredEvents = events.filter((e) => {
      if (!parsedQuery.fields.has("kind")) {
        if (eventKindFilter === "error") {
          if (!(e.isError || e.type === "signal:error")) return false;
        } else if (eventKindFilter === "update") {
          if (e.type !== "signal:change") return false;
        } else if (eventKindFilter === "create") {
          if (e.type !== "signal:create" && e.type !== "tag:create")
            return false;
        } else if (eventKindFilter === "dispose") {
          if (e.type !== "signal:dispose") return false;
        }
      }

      const signalId = "signalId" in e ? String(e.signalId) : undefined;
      const tagId = "tagId" in e ? String(e.tagId) : undefined;
      const value = "value" in e ? e.value : undefined;

      return matchesEventSearch(
        {
          type: e.type,
          signalId,
          tagId,
          value,
        },
        parsedQuery,
        (id) => signals.get(id)?.name
      );
    });

    const clearEvents = useCallback(() => {
      setEvents([]);
    }, []);

    const refreshChains = useCallback(() => {
      setChains(getChainsList());
    }, []);

    // Render content based on active tab
    const renderContent = () => {
      if (!enabled) {
        return (
          <div style={styles.warningBoxStyles}>
            <div style={{ marginBottom: "4px" }}>⚠️ DevTools not enabled</div>
            <div style={{ fontSize: "10px", opacity: 0.8 }}>
              Call{" "}
              <code
                style={{
                  backgroundColor: "rgba(0,0,0,0.3)",
                  padding: "1px 4px",
                  borderRadius: "2px",
                }}
              >
                enableDevTools()
              </code>{" "}
              before creating signals
            </div>
          </div>
        );
      }

      switch (activeTab) {
        case "signals":
          return (
            <SignalsTab
              signals={signals}
              filteredSignals={filteredSignals}
              position={position}
              expandedSignal={expandedSignal}
              setExpandedSignal={setExpandedSignal}
              hoveredItem={hoveredItem}
              setHoveredItem={setHoveredItem}
              flashingSignals={flashingSignals}
              bookmarkedSignals={bookmarkedSignals}
              toggleBookmark={toggleBookmark}
              editingSignal={editingSignal}
              setEditingSignal={setEditingSignal}
              editValue={editValue}
              setEditValue={setEditValue}
              editError={editError}
              setEditError={setEditError}
              searchQuery={searchQuery}
              setSearchQuery={setSearchQuery}
              recentActivitySort={recentActivitySort}
              setSignalKindFilter={setSignalKindFilter}
              updateActiveTab={updateActiveTab}
              setCompareModal={setCompareModal}
              dependentsMap={dependentsMap}
              deleteSignal={deleteSignal}
            />
          );
        case "tags":
          return (
            <TagsTab
              tags={tags}
              filteredTags={filteredTags}
              signals={signals}
              position={position}
              searchQuery={searchQuery}
              expandedTag={expandedTag}
              setExpandedTag={setExpandedTag}
              hoveredItem={hoveredItem}
              setHoveredItem={setHoveredItem}
              setSearchQuery={setSearchQuery}
              setSignalKindFilter={setSignalKindFilter}
              updateActiveTab={updateActiveTab}
              takeSnapshotForTag={takeSnapshotForTag}
            />
          );
        case "events":
          return (
            <EventsTab
              events={events}
              filteredEvents={filteredEvents}
              signals={signals}
              expandedEvents={expandedEvents}
              setExpandedEvents={setExpandedEvents}
              setSearchQuery={setSearchQuery}
              setSignalKindFilter={setSignalKindFilter}
              updateActiveTab={updateActiveTab}
            />
          );
        case "chains":
          return (
            <ChainsTab
              chains={chains}
              signals={signals}
              chainFilter={chainFilter}
              expandedChain={expandedChain}
              setExpandedChain={setExpandedChain}
              setSearchQuery={setSearchQuery}
              setSignalKindFilter={setSignalKindFilter}
              updateActiveTab={updateActiveTab}
              deleteChain={deleteChain}
              refreshChains={refreshChains}
            />
          );
        case "snaps":
          return (
            <SnapshotsTab
              snapshots={snapshots}
              signals={signals}
              position={position}
              snapshotSearch={snapshotSearch}
              expandedSnapshot={expandedSnapshot}
              setExpandedSnapshot={setExpandedSnapshot}
              editingSnapshotId={editingSnapshotId}
              setEditingSnapshotId={setEditingSnapshotId}
              editingSnapshotName={editingSnapshotName}
              setEditingSnapshotName={setEditingSnapshotName}
              deleteSnapshot={deleteSnapshot}
              renameSnapshot={renameSnapshot}
              revertSnapshot={revertSnapshot}
              revertSingleSignal={revertSingleSignal}
              compareSnapshotWithCurrent={compareSnapshotWithCurrent}
              setSearchQuery={setSearchQuery}
              setSignalKindFilter={setSignalKindFilter}
              updateActiveTab={updateActiveTab}
              setCompareModal={setCompareModal}
            />
          );
      }
    };

    // Memoized tabs array
    const tabs = useMemo(
      () =>
        (["signals", "snaps", "tags", "events", "chains"] as Tab[]).map(
          (tab) => ({
            id: tab,
            label: getTabLabel(tab),
          })
        ),
      []
    );

    const handleTabChange = useCallback(
      (tabId: string) => updateActiveTab(tabId as Tab),
      [updateActiveTab]
    );

    const handleSearchHelpClick = useCallback(
      () => setShowSearchHelp(true),
      []
    );

    // Memoized searchBox props
    const searchBoxProps = useMemo(() => {
      if (activeTab === "chains") {
        return {
          value: chainFilter,
          onChange: setChainFilter,
          placeholder: "Filter by signal name...",
          showHelp: false,
          leftActions: undefined,
        };
      }
      if (activeTab === "snaps") {
        return {
          value: snapshotSearch,
          onChange: setSnapshotSearch,
          placeholder: "Search snapshots...",
          showHelp: false,
          leftActions: undefined,
        };
      }
      return {
        value: searchQuery,
        onChange: setSearchQuery,
        placeholder: getSearchPlaceholder(activeTab),
        showHelp: true,
        onHelpClick: handleSearchHelpClick,
      };
    }, [
      activeTab,
      chainFilter,
      snapshotSearch,
      searchQuery,
      handleSearchHelpClick,
    ]);

    const isLeftCollapsed = position === "left" && !isExpanded;
    const currentSize = position === "bottom" ? sizeBottom : sizeLeft;

    return (
      <>
        <style>
          {`
          @keyframes pulse-warning {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.05); }
          }
        `}
        </style>
        <div style={styles.panelContainerStyles(position)}>
          <div
            ref={panelRef}
            style={{
              ...styles.panelStyles(
                isExpanded,
                position,
                currentSize ?? undefined,
                isResizing
              ),
              position: "relative",
            }}
          >
            {/* Resize handle */}
            {isExpanded && (
              <div
                style={styles.resizeHandleStyles(position, isResizing)}
                onMouseDown={handleResizeStart}
                onTouchStart={handleResizeStart}
              >
                <div style={styles.resizeHandleGripStyles(position)} />
              </div>
            )}

            {/* Header */}
            <div
              style={styles.headerStyles(position, isExpanded)}
              onClick={togglePanel}
            >
              <h3 style={styles.titleStyles(isLeftCollapsed)}>
                <span style={{ color: "#fbbf24" }}>
                  <IconBolt size={18} />
                </span>
                {!isLeftCollapsed && <span>Rextive Devtools</span>}
              </h3>

              <div
                style={{
                  ...styles.headerRightStyles,
                  flexDirection: isLeftCollapsed ? "column" : "row",
                }}
              >
                {!isLeftCollapsed && (
                  <button
                    style={styles.positionButtonStyles}
                    onClick={(e) => {
                      e.stopPropagation();
                      setIsConfigModalOpen(true);
                    }}
                    title="DevTools settings"
                  >
                    <IconSettings size={14} />
                  </button>
                )}

                {!isLeftCollapsed && (
                  <button
                    style={styles.positionButtonStyles}
                    onClick={(e) => {
                      e.stopPropagation();
                      resetConfig();
                    }}
                    title="Reset DevTools settings"
                  >
                    <IconReset size={14} />
                  </button>
                )}

                {!isMobile && (
                  <button
                    style={styles.positionButtonStyles}
                    onClick={(e) => {
                      e.stopPropagation();
                      togglePosition();
                    }}
                    title={
                      position === "bottom" ? "Move to left" : "Move to bottom"
                    }
                  >
                    {position === "bottom" ? (
                      <IconArrowLeft />
                    ) : (
                      <IconArrowDown />
                    )}
                  </button>
                )}

                <button
                  style={styles.toggleButtonStyles}
                  onClick={(e) => {
                    e.stopPropagation();
                    togglePanel();
                  }}
                  title={isExpanded ? "Collapse" : "Expand"}
                >
                  {position === "bottom" ? (
                    isExpanded ? (
                      <IconChevronDown />
                    ) : (
                      <IconChevronUp />
                    )
                  ) : isExpanded ? (
                    <IconChevronLeft />
                  ) : (
                    <IconChevronRight />
                  )}
                </button>
              </div>
            </div>

            {/* Tabs + Content */}
            {isExpanded && (
              <>
                <TabBar
                  tabs={tabs}
                  activeTab={activeTab}
                  onTabChange={handleTabChange}
                  flashingTabs={flashingTabs}
                />

                <TabContent
                  searchBox={searchBoxProps}
                  filterBar={
                    activeTab === "signals" ? (
                      <>
                        <SignalKindFilters
                          filter={signalKindFilter}
                          setFilter={setSignalKindFilter}
                          stats={stats}
                          filteredSignals={filteredSignals}
                          signals={signals}
                          showAutoGenerated={showAutoGenerated}
                        />
                        <SignalOptionFilters
                          showBookmarksOnly={showBookmarksOnly}
                          setShowBookmarksOnly={setShowBookmarksOnly}
                          bookmarkedSignals={bookmarkedSignals}
                          recentActivitySort={recentActivitySort}
                          setRecentActivitySort={setRecentActivitySort}
                          flashAutoToggle={flashAutoToggle}
                          showAutoGenerated={showAutoGenerated}
                          updateShowAutoGenerated={updateShowAutoGenerated}
                          clearFlashAutoToggle={clearFlashAutoToggle}
                          autoGeneratedCount={autoGeneratedCount}
                        />
                      </>
                    ) : activeTab === "events" ? (
                      <>
                        <EventKindFilters
                          filter={eventKindFilter}
                          setFilter={setEventKindFilter}
                          events={events}
                        />
                        <FilterSeparator />
                        <button
                          style={{
                            padding: "3px 8px",
                            fontSize: "10px",
                            backgroundColor: styles.colors.bgHover,
                            border: `1px solid ${styles.colors.border}`,
                            borderRadius: "4px",
                            color: styles.colors.textMuted,
                            cursor:
                              events.length === 0 ? "not-allowed" : "pointer",
                            opacity: events.length === 0 ? 0.5 : 1,
                            fontFamily: "inherit",
                          }}
                          onClick={clearEvents}
                          disabled={events.length === 0}
                          title="Clear all events"
                        >
                          Clear
                        </button>
                      </>
                    ) : activeTab === "snaps" ? (
                      <SnapshotFilters
                        takeSnapshot={takeSnapshot}
                        snapshotBookmarkedOnly={snapshotBookmarkedOnly}
                        updateSnapshotBookmarkedOnly={
                          updateSnapshotBookmarkedOnly
                        }
                        bookmarkedSignals={bookmarkedSignals}
                        snapshots={snapshots}
                        setSnapshotDiffOpen={setSnapshotDiffOpen}
                        snapshotOnInit={snapshotOnInit}
                        updateSnapshotOnInit={updateSnapshotOnInit}
                        snapshotAutoInterval={snapshotAutoInterval}
                        updateSnapshotAutoInterval={updateSnapshotAutoInterval}
                        autoSnapshotIntervalSeconds={
                          autoSnapshotIntervalSeconds
                        }
                      />
                    ) : undefined
                  }
                  actionBar={
                    activeTab === "snaps" && snapshots.length > 0 ? (
                      <button
                        style={{
                          padding: "4px 10px",
                          fontSize: "10px",
                          backgroundColor: styles.colors.bgHover,
                          border: `1px solid ${styles.colors.border}`,
                          borderRadius: "4px",
                          color: styles.colors.textMuted,
                          cursor: "pointer",
                          fontFamily: "inherit",
                          display: "flex",
                          alignItems: "center",
                          gap: "4px",
                        }}
                        onClick={clearAllSnapshots}
                        title="Clear all snapshots"
                      >
                        <IconTrash size={12} /> Clear All
                      </button>
                    ) : activeTab === "signals" &&
                      signalKindFilter === "disposed" &&
                      stats.disposedCount > 0 ? (
                      <button
                        style={{
                          padding: "4px 10px",
                          fontSize: "10px",
                          backgroundColor: "#66666633",
                          border: `1px solid #666`,
                          borderRadius: "4px",
                          color: "#888",
                          cursor: "pointer",
                          fontFamily: "inherit",
                          display: "flex",
                          alignItems: "center",
                          gap: "4px",
                          whiteSpace: "nowrap",
                        }}
                        onClick={(e) => {
                          e.stopPropagation();
                          clearDisposed();
                        }}
                        title={`Clear all ${
                          stats.disposedCount
                        } disposed signal${
                          stats.disposedCount !== 1 ? "s" : ""
                        }`}
                      >
                        <IconTrash size={12} /> Clear All Disposed (
                        {stats.disposedCount})
                      </button>
                    ) : undefined
                  }
                >
                  {renderContent()}
                </TabContent>
              </>
            )}
          </div>
          <SearchHelpModal
            isOpen={showSearchHelp}
            onClose={() => setShowSearchHelp(false)}
          />
          {compareModal && (
            <ValueDiffModal
              isOpen={!!compareModal}
              onClose={() => setCompareModal(null)}
              signalName={
                signals.get(compareModal.signalId)?.name ||
                compareModal.signalId
              }
              currentValue={compareModal.currentValue}
              historyValue={compareModal.historyValue}
              historyTimestamp={compareModal.historyTimestamp}
              formatTime={formatTime}
            />
          )}
          <SnapshotDiffModal
            isOpen={snapshotDiffOpen}
            onClose={() => {
              setSnapshotDiffOpen(false);
              setSnapshotDiff1Id(null);
              setSnapshotDiff2Id(null);
            }}
            snapshots={snapshots}
            snapshot1Id={snapshotDiff1Id}
            snapshot2Id={snapshotDiff2Id}
            onSelectSnapshot1={setSnapshotDiff1Id}
            onSelectSnapshot2={setSnapshotDiff2Id}
            currentStateSignals={getCurrentStateSignals()}
          />
          <ConfigModal
            isOpen={isConfigModalOpen}
            onClose={() => setIsConfigModalOpen(false)}
            settings={{
              autoRemoveDisposedTimer,
              autoSnapshotInterval: autoSnapshotIntervalSeconds,
              signalHistoryLimit,
            }}
            onSettingsChange={handleSettingsChange}
          />
        </div>
      </>
    );
  }
);
