/**
 * DevTools Panel Component
 *
 * A bottom drawer panel for inspecting Rextive signals and tags.
 * Uses pure React state (no signals) to avoid circular dependencies.
 * Responsive design for mobile devices.
 */

import React, {
  useState,
  useEffect,
  useCallback,
  useRef,
  useMemo,
} from "react";
import type {
  SignalInfo,
  TagInfo,
  DevToolsEvent,
  ChainReaction,
} from "../devtools/types";
import {
  isDevToolsEnabled,
  getSignals,
  getTags,
  getStats,
  onDevToolsEvent,
  clearDisposed,
  deleteSignal,
  enableChainTracking,
  disableChainTracking,
  getChainsList,
  deleteChain,
  updateDevToolsConfig,
} from "../devtools";
import { isAutoGeneratedName } from "../utils/nameGenerator";
import { task } from "../utils/task";
import { batch } from "../batch";
import {
  IconReset,
  IconArrowLeft,
  IconArrowDown,
  IconChevronUp,
  IconChevronDown,
  IconChevronLeft,
  IconChevronRight,
  IconCopy,
  IconEdit,
  IconHistory,
  IconRefresh,
  IconTrash,
  IconClose,
  IconBolt,
  IconResetSmall,
  IconStar,
  IconCompare,
  IconRevert,
  IconUndo,
  IconRecord,
  IconCamera,
  IconSettings,
} from "./icons";
import { ConfigModal } from "./components/ConfigModal";
import { SearchHelpModal } from "./SearchHelpModal";
import { ValueDiffModal } from "./ValueDiffModal";
import { SnapshotDiffModal, CURRENT_STATE_ID } from "./SnapshotDiffModal";
import { SimpleTreeView } from "./components/SimpleTreeView";
import { buildDependencyGraph } from "../devtools";
import { isPromiseLike } from "../utils/isPromiseLike";
import * as styles from "./styles";
import type { PanelPosition } from "./styles";
import {
  TabBar,
  TabContent,
  FilterSeparator,
  FilterGroup,
} from "./components/shared";
import {
  parseSearchQuery,
  matchesSignalSearch,
  matchesTagSearch,
  matchesEventSearch,
  getSearchPlaceholder,
} from "./searchUtils";

type Tab = "signals" | "snaps" | "tags" | "events" | "chains" | "graph";

const STORAGE_KEY = "rextive-devtools-config";
const BOOKMARKS_STORAGE_KEY = "rextive-devtools-bookmarks";

interface DevToolsConfig {
  position: PanelPosition;
  expanded: boolean;
  activeTab: Tab;
  showAutoGenerated: boolean;
  sizeBottom: number | null;
  sizeLeft: number | null;
  snapshotOnInit: boolean;
  snapshotAutoInterval: boolean;
  snapshotBookmarkedOnly: boolean;
  /** Auto-remove disposed signals after X seconds. 0 = immediate, -1 = never */
  autoRemoveDisposedTimer: number;
  /** Auto snapshot interval in seconds. 0 = disabled */
  autoSnapshotIntervalSeconds: number;
  /** Maximum number of history entries per signal */
  signalHistoryLimit: number;
}

const DEFAULT_CONFIG: DevToolsConfig = {
  position: "left",
  expanded: false,
  activeTab: "signals",
  showAutoGenerated: false,
  sizeBottom: null,
  sizeLeft: null,
  snapshotOnInit: false,
  snapshotAutoInterval: false,
  snapshotBookmarkedOnly: false,
  autoRemoveDisposedTimer: 3,
  autoSnapshotIntervalSeconds: 5,
  signalHistoryLimit: 5,
};

// Snapshot types
// WeakRef type declaration for ES2020 compatibility
declare class WeakRef<T extends object> {
  constructor(target: T);
  deref(): T | undefined;
}

interface SnapshotSignal {
  id: string;
  name: string;
  value: unknown;
  signalRef: WeakRef<{ set: (value: unknown) => void }> | null;
}

interface Snapshot {
  id: string;
  timestamp: number;
  name: string;
  signals: SnapshotSignal[];
}

// Load config from localStorage
const loadConfig = (): DevToolsConfig => {
  try {
    const saved = localStorage.getItem(STORAGE_KEY);
    if (saved) {
      const parsed = JSON.parse(saved);
      return { ...DEFAULT_CONFIG, ...parsed };
    }
  } catch {
    // Ignore localStorage errors
  }
  return DEFAULT_CONFIG;
};

// Save config to localStorage
const saveConfig = (config: Partial<DevToolsConfig>) => {
  try {
    const current = loadConfig();
    localStorage.setItem(
      STORAGE_KEY,
      JSON.stringify({ ...current, ...config })
    );
  } catch {
    // Ignore localStorage errors
  }
};

// Clear all persisted config
const clearConfig = () => {
  try {
    localStorage.removeItem(STORAGE_KEY);
  } catch {
    // Ignore localStorage errors
  }
};

type EventLogEntry = DevToolsEvent & {
  id: number;
  timestamp: number;
  isError?: boolean;
};

export function DevToolsPanel(): React.ReactElement | null {
  // Load initial config
  const initialConfig = useRef(loadConfig()).current;

  const [isExpanded, setIsExpanded] = useState(initialConfig.expanded);
  const [position, setPosition] = useState<PanelPosition>(
    initialConfig.position
  );
  const [activeTab, setActiveTab] = useState<Tab>(initialConfig.activeTab);
  const [showAutoGenerated, setShowAutoGenerated] = useState(
    initialConfig.showAutoGenerated
  );
  const [sizeBottom, setSizeBottom] = useState<number | null>(
    initialConfig.sizeBottom
  );
  const [sizeLeft, setSizeLeft] = useState<number | null>(
    initialConfig.sizeLeft
  );
  const [isResizing, setIsResizing] = useState(false);
  const [isMobile, setIsMobile] = useState(
    () => typeof window !== "undefined" && window.innerWidth <= 768
  );

  const [signals, setSignals] = useState<Map<string, SignalInfo>>(new Map());
  const [tags, setTags] = useState<Map<string, TagInfo>>(new Map());
  const [events, setEvents] = useState<EventLogEntry[]>([]);
  const [stats, setStats] = useState({
    signalCount: 0,
    mutableCount: 0,
    computedCount: 0,
    tagCount: 0,
    totalChanges: 0,
    totalErrors: 0,
    signalsWithErrors: 0,
    disposedCount: 0,
  });
  const [enabled, setEnabled] = useState(false);
  const [expandedSignal, setExpandedSignal] = useState<string | null>(null);
  const [hoveredItem, setHoveredItem] = useState<string | null>(null);
  const [flashingSignals, setFlashingSignals] = useState<
    Map<string, "change" | "create">
  >(new Map());
  const [flashingTabs, setFlashingTabs] = useState<Set<string>>(new Set());
  const [searchQuery, setSearchQuery] = useState("");
  const [graphSearchQuery, setGraphSearchQuery] = useState("");
  const [editingSignal, setEditingSignal] = useState<string | null>(null);
  const [editValue, setEditValue] = useState("");
  const [editError, setEditError] = useState<string | null>(null);
  const [expandedEvents, setExpandedEvents] = useState<Set<number>>(new Set());
  const [expandedTag, setExpandedTag] = useState<string | null>(null);
  const [showSearchHelp, setShowSearchHelp] = useState(false);
  const [bookmarkedSignals, setBookmarkedSignals] = useState<Set<string>>(
    () => {
      try {
        const saved = localStorage.getItem(BOOKMARKS_STORAGE_KEY);
        if (saved) {
          return new Set(JSON.parse(saved));
        }
      } catch {
        // Ignore localStorage errors
      }
      return new Set<string>();
    }
  );
  const [showBookmarksOnly, setShowBookmarksOnly] = useState(false);
  const [graphExpandedNodes, setGraphExpandedNodes] = useState<Set<string>>(
    new Set()
  );
  const [graphSelectedNodeId, setGraphSelectedNodeId] = useState<string | null>(
    null
  );
  const [compareModal, setCompareModal] = useState<{
    signalId: string;
    currentValue: unknown;
    historyValue: unknown;
    historyTimestamp: number;
  } | null>(null);
  const [signalKindFilter, setSignalKindFilter] = useState<
    "all" | "mutable" | "computed" | "error" | "disposed"
  >("all");
  const [recentActivitySort, setRecentActivitySort] = useState(true);
  const [eventKindFilter, setEventKindFilter] = useState<
    "all" | "error" | "update" | "create" | "dispose"
  >("all");
  // Chain reaction state
  const [chains, setChains] = useState<ChainReaction[]>([]);
  const [expandedChain, setExpandedChain] = useState<string | null>(null);
  const [chainFilter, setChainFilter] = useState("");

  // Snapshot state
  const [snapshots, setSnapshots] = useState<Snapshot[]>([]);
  const [expandedSnapshot, setExpandedSnapshot] = useState<string | null>(null);
  const [snapshotOnInit, setSnapshotOnInit] = useState(
    initialConfig.snapshotOnInit
  );
  const [snapshotAutoInterval, setSnapshotAutoInterval] = useState(
    initialConfig.snapshotAutoInterval
  );
  const [snapshotBookmarkedOnly, setSnapshotBookmarkedOnly] = useState(
    initialConfig.snapshotBookmarkedOnly
  );
  const [editingSnapshotId, setEditingSnapshotId] = useState<string | null>(
    null
  );
  const [editingSnapshotName, setEditingSnapshotName] = useState("");
  const [snapshotSearch, setSnapshotSearch] = useState("");
  const [snapshotDiffOpen, setSnapshotDiffOpen] = useState(false);
  const [snapshotDiff1Id, setSnapshotDiff1Id] = useState<string | null>(null);
  const [snapshotDiff2Id, setSnapshotDiff2Id] = useState<string | null>(null);
  const snapshotCounterRef = useRef(1);
  const snapshotInitDoneRef = useRef(false);
  const snapshotIntervalRef = useRef<NodeJS.Timeout | null>(null);
  // Ref to store latest takeSnapshot function for interval (avoids restarting interval on every change)
  const takeSnapshotRef = useRef<
    (options?: { skipIfNoDiff?: boolean }) => void
  >(() => {});

  // Config modal state
  const [isConfigModalOpen, setIsConfigModalOpen] = useState(false);
  const [autoRemoveDisposedTimer, setAutoRemoveDisposedTimer] = useState(
    initialConfig.autoRemoveDisposedTimer
  );
  const [autoSnapshotIntervalSeconds, setAutoSnapshotIntervalSeconds] =
    useState(initialConfig.autoSnapshotIntervalSeconds);
  const [signalHistoryLimit, setSignalHistoryLimit] = useState(
    initialConfig.signalHistoryLimit
  );
  // Track pending disposal timeouts for cleanup
  const disposalTimeoutsRef = useRef<Map<string, NodeJS.Timeout>>(new Map());

  // Build dependency graph (memoized)
  const dependencyGraph = useMemo(
    () => buildDependencyGraph(signals, chains),
    [signals, chains]
  );

  // Memoize recentlyUpdatedNodes to avoid creating new Set on every render
  const recentlyUpdatedNodes = useMemo(
    () => new Set(flashingSignals.keys()),
    [flashingSignals]
  );

  // Flash the auto-generated toggle when hidden signals are created
  const [flashAutoToggle, setFlashAutoToggle] = useState(false);
  const showAutoGeneratedRef = useRef(showAutoGenerated);
  showAutoGeneratedRef.current = showAutoGenerated;
  const eventIdRef = useRef(0);
  const flashTimeoutsRef = useRef<Map<string, NodeJS.Timeout>>(new Map());
  const autoToggleFlashTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const tabFlashTimeoutsRef = useRef<Map<string, NodeJS.Timeout>>(new Map());
  const panelRef = useRef<HTMLDivElement>(null);

  // Flash tab header (only shows animation if not already on that tab)
  const flashTab = useCallback((tabId: string) => {
    const existingTimeout = tabFlashTimeoutsRef.current.get(tabId);
    if (existingTimeout) clearTimeout(existingTimeout);

    setFlashingTabs((prev) => new Set(prev).add(tabId));

    const timeout = setTimeout(() => {
      setFlashingTabs((prev) => {
        const next = new Set(prev);
        next.delete(tabId);
        return next;
      });
      tabFlashTimeoutsRef.current.delete(tabId);
    }, 1500); // Flash for 1.5s (3 animation cycles of 0.5s)

    tabFlashTimeoutsRef.current.set(tabId, timeout);
  }, []);

  // Mobile mode detection - force bottom position on small screens
  useEffect(() => {
    const checkMobile = () => {
      const mobile = window.innerWidth <= 768;
      setIsMobile(mobile);
      // Force bottom position in mobile mode (use functional form to avoid dependency)
      if (mobile) {
        setPosition((prev) => (prev !== "bottom" ? "bottom" : prev));
      }
    };

    checkMobile();
    window.addEventListener("resize", checkMobile);
    return () => window.removeEventListener("resize", checkMobile);
  }, []);

  // Persist config changes
  const togglePosition = useCallback(() => {
    setPosition((prev) => {
      const next = prev === "bottom" ? "left" : "bottom";
      saveConfig({ position: next });
      return next;
    });
  }, []);

  const updateActiveTab = useCallback((tab: Tab) => {
    setActiveTab(tab);
    saveConfig({ activeTab: tab });
  }, []);

  const updateShowAutoGenerated = useCallback((show: boolean) => {
    setShowAutoGenerated(show);
    saveConfig({ showAutoGenerated: show });
  }, []);

  const resetConfig = useCallback(() => {
    clearConfig();
    setIsExpanded(DEFAULT_CONFIG.expanded);
    setPosition(DEFAULT_CONFIG.position);
    setActiveTab(DEFAULT_CONFIG.activeTab);
    setShowAutoGenerated(DEFAULT_CONFIG.showAutoGenerated);
    setSizeBottom(DEFAULT_CONFIG.sizeBottom);
    setSizeLeft(DEFAULT_CONFIG.sizeLeft);
    setAutoRemoveDisposedTimer(DEFAULT_CONFIG.autoRemoveDisposedTimer);
    setAutoSnapshotIntervalSeconds(DEFAULT_CONFIG.autoSnapshotIntervalSeconds);
    setSignalHistoryLimit(DEFAULT_CONFIG.signalHistoryLimit);
    updateDevToolsConfig({ maxHistory: DEFAULT_CONFIG.signalHistoryLimit });
  }, []);

  // Handle settings change from config modal
  const handleSettingsChange = useCallback(
    (settings: {
      autoRemoveDisposedTimer: number;
      autoSnapshotInterval: number;
      signalHistoryLimit: number;
    }) => {
      setAutoRemoveDisposedTimer(settings.autoRemoveDisposedTimer);
      setAutoSnapshotIntervalSeconds(settings.autoSnapshotInterval);
      setSignalHistoryLimit(settings.signalHistoryLimit);
      saveConfig({
        autoRemoveDisposedTimer: settings.autoRemoveDisposedTimer,
        autoSnapshotIntervalSeconds: settings.autoSnapshotInterval,
        signalHistoryLimit: settings.signalHistoryLimit,
      });
      // Update devtools config for history limit
      updateDevToolsConfig({ maxHistory: settings.signalHistoryLimit });
    },
    []
  );

  // Snapshot functions
  // Helper to compare two snapshot signal lists for equality
  const snapshotsAreEqual = useCallback(
    (a: SnapshotSignal[], b: SnapshotSignal[]): boolean => {
      if (a.length !== b.length) return false;
      const aMap = new Map(a.map((s) => [s.id, s.value]));
      for (const sig of b) {
        const aVal = aMap.get(sig.id);
        if (aVal === undefined && !aMap.has(sig.id)) return false;
        try {
          if (JSON.stringify(aVal) !== JSON.stringify(sig.value)) return false;
        } catch {
          if (aVal !== sig.value) return false;
        }
      }
      return true;
    },
    []
  );

  const takeSnapshot = useCallback(
    (options?: { skipIfNoDiff?: boolean }) => {
      // Filter mutable signals, optionally by bookmarked only
      const mutableSignals = Array.from(signals.values()).filter(
        (s) =>
          s.kind === "mutable" &&
          !s.disposed &&
          !s.errorCount &&
          (!snapshotBookmarkedOnly || bookmarkedSignals.has(s.id))
      );

      // Don't create empty snapshot when bookmarked-only mode is on but no bookmarks
      if (snapshotBookmarkedOnly && mutableSignals.length === 0) {
        return;
      }

      const snapshotSignals: SnapshotSignal[] = mutableSignals.map((s) => {
        let value: unknown;
        try {
          value = s.signal?.get?.();
        } catch {
          value = "[error reading value]";
        }
        // Store WeakRef to allow GC of the signal
        const signalObj = s.signal as
          | { set?: (value: unknown) => void }
          | undefined;
        const signalRef = signalObj?.set
          ? new WeakRef(signalObj as { set: (value: unknown) => void })
          : null;
        return {
          id: s.id,
          name: s.name,
          value,
          signalRef,
        };
      });

      // Skip if no diff with latest snapshot (for auto-snapshot)
      if (options?.skipIfNoDiff && snapshots.length > 0) {
        const latestSnapshot = snapshots[0];
        if (snapshotsAreEqual(latestSnapshot.signals, snapshotSignals)) {
          return; // No changes, skip creating duplicate
        }
      }

      const newSnapshot: Snapshot = {
        id: `snapshot-${Date.now()}`,
        timestamp: Date.now(),
        name: `Snapshot #${snapshotCounterRef.current}`,
        signals: snapshotSignals,
      };

      snapshotCounterRef.current++;
      setSnapshots((prev) => [newSnapshot, ...prev]);
      flashTab("snaps"); // Flash Snaps tab when new snapshot is taken
    },
    [
      signals,
      snapshotBookmarkedOnly,
      bookmarkedSignals,
      snapshots,
      snapshotsAreEqual,
      flashTab,
    ]
  );

  // Keep ref updated with latest takeSnapshot (for interval to use without restarting)
  useEffect(() => {
    takeSnapshotRef.current = takeSnapshot;
  }, [takeSnapshot]);

  // Take snapshot for specific tag
  const takeSnapshotForTag = useCallback(
    (tagId: string, signalIds: string[]) => {
      const tagSignals = signalIds
        .map((id) => signals.get(id))
        .filter(
          (s): s is SignalInfo =>
            s !== undefined &&
            s.kind === "mutable" &&
            !s.disposed &&
            !s.errorCount
        );

      if (tagSignals.length === 0) return;

      const snapshotSignals: SnapshotSignal[] = tagSignals.map((s) => {
        let value: unknown;
        try {
          value = s.signal?.get?.();
        } catch {
          value = "[error reading value]";
        }
        const signalObj = s.signal as
          | { set?: (value: unknown) => void }
          | undefined;
        const signalRef = signalObj?.set
          ? new WeakRef(signalObj as { set: (value: unknown) => void })
          : null;
        return {
          id: s.id,
          name: s.name,
          value,
          signalRef,
        };
      });

      const newSnapshot: Snapshot = {
        id: `snapshot-${Date.now()}`,
        timestamp: Date.now(),
        name: `Tag: ${tagId} #${snapshotCounterRef.current}`,
        signals: snapshotSignals,
      };

      snapshotCounterRef.current++;
      setSnapshots((prev) => [newSnapshot, ...prev]);
      flashTab("snaps"); // Flash Snaps tab when new snapshot is taken
    },
    [signals, flashTab]
  );

  const deleteSnapshot = useCallback(
    (snapshotId: string) => {
      setSnapshots((prev) => prev.filter((s) => s.id !== snapshotId));
      if (expandedSnapshot === snapshotId) {
        setExpandedSnapshot(null);
      }
    },
    [expandedSnapshot]
  );

  const renameSnapshot = useCallback((snapshotId: string, newName: string) => {
    setSnapshots((prev) =>
      prev.map((s) => (s.id === snapshotId ? { ...s, name: newName } : s))
    );
    setEditingSnapshotId(null);
    setEditingSnapshotName("");
  }, []);

  const revertSnapshot = useCallback(
    (snapshot: Snapshot) => {
      batch(() => {
        for (const snapSignal of snapshot.signals) {
          const signalInfo = signals.get(snapSignal.id);
          const signalObj = signalInfo?.signal as
            | { set?: (value: unknown) => void }
            | undefined;
          if (signalObj?.set && !signalInfo?.disposed) {
            try {
              signalObj.set(snapSignal.value);
            } catch {
              // Ignore errors when reverting
            }
          }
        }
      });
    },
    [signals]
  );

  const revertSingleSignal = useCallback(
    (snapshotSignal: SnapshotSignal) => {
      // Try to use WeakRef first (allows GC)
      const signalFromRef = snapshotSignal.signalRef?.deref();
      if (signalFromRef) {
        try {
          signalFromRef.set(snapshotSignal.value);
          return;
        } catch {
          // Ignore errors when reverting
        }
      }
      // Fallback to looking up from signals map
      const signalInfo = signals.get(snapshotSignal.id);
      const signalObj = signalInfo?.signal as
        | { set?: (value: unknown) => void }
        | undefined;
      if (signalObj?.set && !signalInfo?.disposed) {
        try {
          signalObj.set(snapshotSignal.value);
        } catch {
          // Ignore errors when reverting
        }
      }
    },
    [signals]
  );

  const updateSnapshotOnInit = useCallback((enabled: boolean) => {
    setSnapshotOnInit(enabled);
    saveConfig({ snapshotOnInit: enabled });
  }, []);

  const updateSnapshotAutoInterval = useCallback((enabled: boolean) => {
    setSnapshotAutoInterval(enabled);
    saveConfig({ snapshotAutoInterval: enabled });
  }, []);

  const updateSnapshotBookmarkedOnly = useCallback((enabled: boolean) => {
    setSnapshotBookmarkedOnly(enabled);
    saveConfig({ snapshotBookmarkedOnly: enabled });
  }, []);

  const clearAllSnapshots = useCallback(() => {
    setSnapshots([]);
    setExpandedSnapshot(null);
    snapshotCounterRef.current = 1;
  }, []);

  // Get current state of mutable signals for comparison
  const getCurrentStateSignals = useCallback(() => {
    return Array.from(signals.values())
      .filter((s) => s.kind === "mutable" && !s.disposed && !s.errorCount)
      .map((s) => {
        let value: unknown;
        try {
          value = (s.signal as { get?: () => unknown })?.get?.();
        } catch {
          value = "[error reading value]";
        }
        return {
          id: s.id,
          name: s.name,
          value,
        };
      });
  }, [signals]);

  // Helper to compare a snapshot with current state
  const compareSnapshotWithCurrent = useCallback((snapshotId: string) => {
    setSnapshotDiff1Id(snapshotId);
    setSnapshotDiff2Id(CURRENT_STATE_ID);
    setSnapshotDiffOpen(true);
  }, []);

  // Resize handlers - supports both mouse and touch events
  const handleResizeStart = useCallback(
    (e: React.MouseEvent | React.TouchEvent) => {
      e.preventDefault();
      e.stopPropagation();
      setIsResizing(true);

      // Get initial position from mouse or touch event
      const isTouch = "touches" in e;
      const startY = isTouch ? e.touches[0].clientY : e.clientY;
      const startX = isTouch ? e.touches[0].clientX : e.clientX;
      const startSize =
        position === "bottom"
          ? sizeBottom ?? styles.PANEL_SIZE_EXPANDED_BOTTOM
          : sizeLeft ?? styles.PANEL_SIZE_EXPANDED_LEFT;

      const handleMove = (moveEvent: MouseEvent | TouchEvent) => {
        const isTouchMove = "touches" in moveEvent;
        const currentY = isTouchMove
          ? moveEvent.touches[0].clientY
          : moveEvent.clientY;
        const currentX = isTouchMove
          ? moveEvent.touches[0].clientX
          : moveEvent.clientX;

        if (position === "bottom") {
          // For bottom panel, dragging up increases size
          const delta = startY - currentY;
          const newSize = Math.max(
            styles.PANEL_MIN_SIZE_BOTTOM,
            Math.min(styles.PANEL_MAX_SIZE_BOTTOM, startSize + delta)
          );
          setSizeBottom(newSize);
        } else {
          // For left panel, dragging right increases size
          const delta = currentX - startX;
          const newSize = Math.max(
            styles.PANEL_MIN_SIZE_LEFT,
            Math.min(styles.PANEL_MAX_SIZE_LEFT, startSize + delta)
          );
          setSizeLeft(newSize);
        }
      };

      const handleEnd = () => {
        setIsResizing(false);
        document.removeEventListener("mousemove", handleMove);
        document.removeEventListener("mouseup", handleEnd);
        document.removeEventListener("touchmove", handleMove);
        document.removeEventListener("touchend", handleEnd);
        document.removeEventListener("touchcancel", handleEnd);
        document.body.style.cursor = "";
        document.body.style.userSelect = "";

        // Save the new size
        if (position === "bottom") {
          saveConfig({ sizeBottom: sizeBottom });
        } else {
          saveConfig({ sizeLeft: sizeLeft });
        }
      };

      // Add both mouse and touch event listeners
      document.addEventListener("mousemove", handleMove);
      document.addEventListener("mouseup", handleEnd);
      document.addEventListener("touchmove", handleMove, { passive: false });
      document.addEventListener("touchend", handleEnd);
      document.addEventListener("touchcancel", handleEnd);
      document.body.style.cursor =
        position === "bottom" ? "ns-resize" : "ew-resize";
      document.body.style.userSelect = "none";
    },
    [position, sizeBottom, sizeLeft]
  );

  // Save size after resize ends
  useEffect(() => {
    if (!isResizing) {
      if (position === "bottom" && sizeBottom !== null) {
        saveConfig({ sizeBottom });
      } else if (position === "left" && sizeLeft !== null) {
        saveConfig({ sizeLeft });
      }
    }
  }, [isResizing, position, sizeBottom, sizeLeft]);

  // Manage body padding to prevent content from being hidden by devtools
  useEffect(() => {
    const updateBodyPadding = () => {
      if (position === "bottom" && isExpanded) {
        // Add padding to bottom when panel is at bottom and expanded
        const height = sizeBottom ?? styles.PANEL_SIZE_EXPANDED_BOTTOM;
        document.body.style.paddingBottom = `${height}px`;
        document.body.style.paddingLeft = "";
      } else if (position === "left" && isExpanded) {
        // Add padding to left when panel is at left and expanded
        const width = sizeLeft ?? styles.PANEL_SIZE_EXPANDED_LEFT;
        document.body.style.paddingLeft = `${width}px`;
        document.body.style.paddingBottom = "";
      } else {
        // Remove padding when panel is collapsed
        if (position === "bottom") {
          document.body.style.paddingBottom = `${styles.PANEL_SIZE_COLLAPSED}px`;
          document.body.style.paddingLeft = "";
        } else {
          document.body.style.paddingLeft = `${styles.PANEL_SIZE_COLLAPSED}px`;
          document.body.style.paddingBottom = "";
        }
      }
    };

    updateBodyPadding();

    // Cleanup: remove padding when component unmounts
    return () => {
      document.body.style.paddingBottom = "";
      document.body.style.paddingLeft = "";
    };
  }, [position, isExpanded, sizeBottom, sizeLeft]);

  // Check if devtools is enabled
  useEffect(() => {
    const checkEnabled = () => {
      setEnabled(isDevToolsEnabled());
    };

    checkEnabled();
    const interval = setInterval(checkEnabled, 1000);
    return () => clearInterval(interval);
  }, []);

  // Refresh data periodically when enabled
  useEffect(() => {
    if (!enabled) return;

    const refresh = () => {
      const existingSignals = getSignals();
      const existingTags = getTags();

      setSignals(new Map(existingSignals));
      setTags(new Map(existingTags));
      setStats(getStats());
    };

    refresh();
    const interval = setInterval(refresh, 500);
    return () => clearInterval(interval);
  }, [enabled]);

  // Auto-remove disposed signals based on timer setting
  useEffect(() => {
    if (!enabled) return;
    // -1 means never auto-remove
    if (autoRemoveDisposedTimer < 0) return;

    // Check for newly disposed signals and schedule removal
    const currentTimeouts = disposalTimeoutsRef.current;

    signals.forEach((signal, id) => {
      if (signal.disposed && !currentTimeouts.has(id)) {
        // Signal is disposed and not yet scheduled for removal
        if (autoRemoveDisposedTimer === 0) {
          // Immediate removal
          deleteSignal(id);
          setSignals((prev) => {
            const next = new Map(prev);
            next.delete(id);
            return next;
          });
        } else {
          // Schedule removal after timer
          const timeout = setTimeout(() => {
            deleteSignal(id);
            setSignals((prev) => {
              const next = new Map(prev);
              next.delete(id);
              return next;
            });
            currentTimeouts.delete(id);
          }, autoRemoveDisposedTimer * 1000);
          currentTimeouts.set(id, timeout);
        }
      }
    });

    // Cleanup: clear timeouts for signals that are no longer disposed (shouldn't happen but be safe)
    currentTimeouts.forEach((timeout, id) => {
      const signal = signals.get(id);
      if (!signal || !signal.disposed) {
        clearTimeout(timeout);
        currentTimeouts.delete(id);
      }
    });
  }, [enabled, signals, autoRemoveDisposedTimer]);

  // Cleanup disposal timeouts on unmount
  useEffect(() => {
    return () => {
      disposalTimeoutsRef.current.forEach((timeout) => clearTimeout(timeout));
      disposalTimeoutsRef.current.clear();
    };
  }, []);

  // Subscribe to events (cached events will be automatically replayed)
  useEffect(() => {
    if (!enabled) return;

    const unsubscribe = onDevToolsEvent((event) => {
      // After initial subscription, process events normally
      // Handle signals:forget - remove events related to forgotten signals
      // BUT preserve create events as they are historical records
      if (event.type === "signals:forget") {
        const forgottenIds = new Set(event.signalIds);
        setEvents((prev) =>
          prev.filter((e) => {
            // Don't remove create events - they are historical records
            // even if the signal was later forgotten (e.g., React StrictMode)
            if (e.type === "signal:create" || e.type === "tag:create") {
              return true;
            }
            // Filter out other events related to forgotten signals
            if (
              "signalId" in e &&
              typeof e.signalId === "string" &&
              forgottenIds.has(e.signalId)
            )
              return false;
            return true;
          })
        );
        // Also update signals state to remove forgotten signals
        setSignals((prev) => {
          const next = new Map(prev);
          for (const id of forgottenIds) {
            next.delete(id);
          }
          return next;
        });
        return; // Don't log this event
      }

      // Check if this is an error event
      let isError = false;
      if (event.type === "signal:error") {
        // Explicit error event
        isError = true;
      } else if (
        event.type === "window:error" ||
        event.type === "window:unhandledrejection"
      ) {
        // Window error events
        isError = true;
      } else if (event.type === "signal:change" && "signalId" in event) {
        // Change event where signal has error
        const signalInfo = getSignals().get(event.signalId);
        if (signalInfo?.signal?.error?.()) {
          isError = true;
        }
      }

      const entry: EventLogEntry = {
        ...event,
        id: eventIdRef.current++,
        timestamp: Date.now(),
        isError,
      };

      // Use functional update to ensure we're working with latest state
      // This is especially important when replaying cached events
      setEvents((prev) => {
        // Check if this event would be immediately removed by a pending forget
        // (This shouldn't happen, but helps with race conditions during replay)
        const newEvents = [entry, ...prev];
        return newEvents.slice(0, 100);
      });

      // Flash Events tab on error
      if (isError) {
        flashTab("events");
      }

      const flashSignal = (signalId: string, type: "change" | "create") => {
        const existingTimeout = flashTimeoutsRef.current.get(signalId);
        if (existingTimeout) clearTimeout(existingTimeout);

        setFlashingSignals((prev) => new Map(prev).set(signalId, type));

        const timeout = setTimeout(() => {
          setFlashingSignals((prev) => {
            const next = new Map(prev);
            next.delete(signalId);
            return next;
          });
          flashTimeoutsRef.current.delete(signalId);
        }, 600);

        flashTimeoutsRef.current.set(signalId, timeout);
      };

      if (event.type === "signal:change" && "signalId" in event) {
        flashSignal(event.signalId, "change");
        flashTab("signals"); // Flash Signals tab on value change
      } else if (event.type === "signal:create" && "signal" in event) {
        flashSignal(event.signal.id, "create");

        // Flash the auto-toggle button if new auto-generated signal is hidden
        if (
          isAutoGeneratedName(event.signal.name) &&
          !showAutoGeneratedRef.current
        ) {
          // Clear any existing timeout
          if (autoToggleFlashTimeoutRef.current) {
            clearTimeout(autoToggleFlashTimeoutRef.current);
          }
          setFlashAutoToggle(true);
          autoToggleFlashTimeoutRef.current = setTimeout(() => {
            setFlashAutoToggle(false);
            autoToggleFlashTimeoutRef.current = null;
          }, 2000);
        }
      }
    });

    return () => {
      unsubscribe();
      flashTimeoutsRef.current.forEach((timeout) => clearTimeout(timeout));
      flashTimeoutsRef.current.clear();
      tabFlashTimeoutsRef.current.forEach((timeout) => clearTimeout(timeout));
      tabFlashTimeoutsRef.current.clear();
    };
  }, [enabled]);

  // Chain tracking - enable only when chains tab is active
  useEffect(() => {
    if (activeTab === "chains" && enabled) {
      enableChainTracking();
      // Refresh chains periodically
      const interval = setInterval(() => {
        setChains(getChainsList());
      }, 200);
      return () => {
        disableChainTracking();
        clearInterval(interval);
      };
    } else {
      disableChainTracking();
    }
  }, [activeTab, enabled]);

  // Snapshot on init - take snapshot when DevTools first loads with signals
  useEffect(() => {
    if (
      snapshotOnInit &&
      enabled &&
      signals.size > 0 &&
      !snapshotInitDoneRef.current
    ) {
      snapshotInitDoneRef.current = true;
      takeSnapshot();
    }
  }, [snapshotOnInit, enabled, signals.size, takeSnapshot]);

  // Auto snapshot interval
  // Uses takeSnapshotRef to avoid restarting interval when takeSnapshot changes
  useEffect(() => {
    if (snapshotAutoInterval && enabled && autoSnapshotIntervalSeconds > 0) {
      snapshotIntervalRef.current = setInterval(() => {
        takeSnapshotRef.current({ skipIfNoDiff: true }); // Skip if no changes
      }, autoSnapshotIntervalSeconds * 1000);
      return () => {
        if (snapshotIntervalRef.current) {
          clearInterval(snapshotIntervalRef.current);
          snapshotIntervalRef.current = null;
        }
      };
    } else {
      if (snapshotIntervalRef.current) {
        clearInterval(snapshotIntervalRef.current);
        snapshotIntervalRef.current = null;
      }
    }
  }, [snapshotAutoInterval, enabled, autoSnapshotIntervalSeconds]);

  const togglePanel = useCallback(() => {
    setIsExpanded((prev) => {
      const next = !prev;
      saveConfig({ expanded: next });
      return next;
    });
  }, []);

  const formatValue = (value: unknown, maxLength = 40): string => {
    if (value === undefined) return "undefined";
    if (value === null) return "null";
    if (typeof value === "function") return "[Function]";
    if (typeof value === "symbol") return value.toString();
    try {
      const str = JSON.stringify(value);
      return str.length > maxLength ? str.slice(0, maxLength) + "‚Ä¶" : str;
    } catch {
      return String(value);
    }
  };

  const formatValueFull = (value: unknown): string => {
    if (value === undefined) return "undefined";
    if (value === null) return "null";
    if (typeof value === "function") return "[Function]";
    if (typeof value === "symbol") return value.toString();
    try {
      return JSON.stringify(value, null, 2);
    } catch {
      return String(value);
    }
  };

  const formatTime = (timestamp: number): string => {
    const date = new Date(timestamp);
    return date.toLocaleTimeString("en-US", {
      hour12: false,
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
    });
  };

  // Toggle bookmark
  const toggleBookmark = useCallback((signalId: string) => {
    setBookmarkedSignals((prev) => {
      const next = new Set(prev);
      if (next.has(signalId)) {
        next.delete(signalId);
      } else {
        next.add(signalId);
      }
      // Persist to localStorage
      try {
        localStorage.setItem(
          BOOKMARKS_STORAGE_KEY,
          JSON.stringify(Array.from(next))
        );
      } catch {
        // Ignore localStorage errors
      }
      return next;
    });
  }, []);

  // Parse search query
  const parsedQuery = parseSearchQuery(searchQuery);

  // Filter signals using advanced search
  const filteredSignals = Array.from(signals.values()).filter((s) => {
    // Filter by bookmarks
    if (showBookmarksOnly && !bookmarkedSignals.has(s.id)) {
      return false;
    }
    // Apply kind filter (if not overridden by search query)
    if (
      !parsedQuery.fields.has("kind") &&
      !parsedQuery.fields.has("error") &&
      !parsedQuery.fields.has("disposed")
    ) {
      if (signalKindFilter === "error") {
        if (s.errorCount === 0) return false;
      } else if (signalKindFilter === "disposed") {
        if (!s.disposed) return false;
      } else if (signalKindFilter !== "all" && s.kind !== signalKindFilter) {
        return false;
      }
    }

    // Apply advanced search
    return matchesSignalSearch(
      {
        name: s.name,
        id: s.id,
        kind: s.kind,
        signal: s.signal,
        source: s.source,
        tags: s.tags,
        errorCount: s.errorCount,
        disposed: s.disposed,
      },
      parsedQuery,
      isAutoGeneratedName,
      showAutoGenerated
    );
  });

  // Filter tags using advanced search
  const filteredTags = Array.from(tags.values()).filter((t) => {
    return matchesTagSearch(
      { id: t.id },
      parsedQuery,
      isAutoGeneratedName,
      showAutoGenerated
    );
  });

  // Count auto-generated signals
  const autoGeneratedCount = useMemo(() => {
    let count = 0;
    for (const s of signals.values()) {
      if (isAutoGeneratedName(s.name)) count++;
    }
    return count;
  }, [signals]);

  // Filter events by search query and kind filter
  const filteredEvents = events.filter((e) => {
    // Apply event kind filter (if not overridden by search query)
    if (!parsedQuery.fields.has("kind")) {
      if (eventKindFilter === "error") {
        if (!(e.isError || e.type === "signal:error")) return false;
      } else if (eventKindFilter === "update") {
        if (e.type !== "signal:change") return false;
      } else if (eventKindFilter === "create") {
        if (e.type !== "signal:create" && e.type !== "tag:create") return false;
      } else if (eventKindFilter === "dispose") {
        if (e.type !== "signal:dispose") return false;
      }
    }

    // Apply advanced search
    const signalId = "signalId" in e ? String(e.signalId) : undefined;
    const tagId = "tagId" in e ? String(e.tagId) : undefined;
    const value = "value" in e ? e.value : undefined;

    return matchesEventSearch(
      {
        type: e.type,
        signalId,
        tagId,
        value,
      },
      parsedQuery,
      (id) => signals.get(id)?.name
    );
  });

  const renderSignals = () => {
    if (signals.size === 0) {
      return <div style={styles.emptyStateStyles}>No signals tracked</div>;
    }

    if (filteredSignals.length === 0) {
      if (searchQuery.trim()) {
        return (
          <div style={styles.emptyStateStyles}>
            No signals match "{searchQuery}"
          </div>
        );
      }
      return (
        <div style={styles.emptyStateStyles}>
          No user-named signals
          <div style={{ fontSize: "9px", marginTop: "4px", opacity: 0.7 }}>
            Check "Show #auto" to see {signals.size} auto-generated
          </div>
        </div>
      );
    }

    // Sort signals based on mode
    const sortedSignals = [...filteredSignals].sort((a, b) => {
      if (recentActivitySort) {
        // Sort by last activity time (updatedAt), latest first
        return b.updatedAt - a.updatedAt;
      }
      // Default: active signals first, then disposed
      if (a.disposed !== b.disposed) return a.disposed ? 1 : -1;
      return 0;
    });

    return (
      <div style={styles.contentGridStyles(position)}>
        {sortedSignals.map((info) => {
          let currentValue: unknown;
          let signalError: unknown = undefined;

          if (info.disposed) {
            // Format disposal time
            const disposedTime = info.disposedAt
              ? new Date(info.disposedAt).toLocaleTimeString("en-GB", {
                  hour12: false,
                })
              : "";
            currentValue = disposedTime
              ? `[disposed at ${disposedTime}]`
              : "[disposed]";
          } else {
            // Check for error first (works for both sync and async signals)
            signalError = info.signal.error();
            if (signalError) {
              currentValue = signalError;
            } else {
              currentValue = info.signal.tryGet();
              // For async signals, show the resolved/rejected value from task
              if (isPromiseLike(currentValue)) {
                const state = task.from(currentValue);
                if (state.status === "success") {
                  currentValue = state.value;
                } else if (state.status === "error") {
                  signalError = state.error;
                  currentValue = state.error;
                } else {
                  // Loading state - show "[async]"
                  currentValue = "[async]";
                }
              }
            }
          }

          const isExpanded = expandedSignal === info.id;
          const isHovered = hoveredItem === `signal-${info.id}`;
          const flashType = flashingSignals.get(info.id) || null;
          const hasError = !info.disposed && signalError !== undefined;

          // Build hover tooltip with full name, UID, and source location
          const hoverTitle = [
            info.name,
            `UID: ${info.id}`,
            info.source
              ? `üìç ${info.source.file}:${info.source.line}${
                  info.source.functionName
                    ? ` (${info.source.functionName})`
                    : ""
                }`
              : null,
          ]
            .filter(Boolean)
            .join("\n");

          return (
            <div
              key={info.id}
              style={{
                ...styles.itemStyles(isHovered, flashType, hasError),
                ...(info.disposed && {
                  opacity: 0.6,
                  borderLeft: `3px solid #666`,
                  backgroundColor: "#2a2a2a",
                  filter: "grayscale(100%)",
                }),
              }}
              title={hoverTitle}
              onClick={() => setExpandedSignal(isExpanded ? null : info.id)}
              onMouseEnter={() => setHoveredItem(`signal-${info.id}`)}
              onMouseLeave={() => setHoveredItem(null)}
            >
              <div style={styles.itemHeaderStyles}>
                <span style={styles.itemNameStyles}>
                  <span
                    style={{
                      ...styles.badgeStyles(info.kind),
                      ...(info.disposed && {
                        backgroundColor: "#444",
                        color: "#888",
                      }),
                    }}
                  >
                    {info.disposed ? "‚úï" : info.kind === "mutable" ? "M" : "C"}
                  </span>
                  <span
                    style={{
                      overflow: "hidden",
                      textOverflow: "ellipsis",
                      ...(info.disposed && {
                        textDecoration: "line-through",
                        color: "#666",
                      }),
                    }}
                  >
                    {info.name}
                  </span>
                  {info.disposed && (
                    <span
                      style={{
                        color: "#888",
                        fontSize: "9px",
                        marginLeft: "6px",
                        flexShrink: 0,
                        backgroundColor: "#333",
                        padding: "1px 4px",
                        borderRadius: "3px",
                      }}
                    >
                      disposed
                    </span>
                  )}
                </span>
                <div style={styles.signalActionsContainerStyles}>
                  {/* Bookmark button */}
                  <button
                    style={{
                      ...styles.signalActionButtonStyles,
                      color: bookmarkedSignals.has(info.id)
                        ? styles.colors.warning
                        : styles.colors.textMuted,
                    }}
                    onClick={(e) => {
                      e.stopPropagation();
                      toggleBookmark(info.id);
                    }}
                    title={
                      bookmarkedSignals.has(info.id)
                        ? "Remove bookmark"
                        : "Bookmark signal"
                    }
                  >
                    <IconStar
                      size={12}
                      filled={bookmarkedSignals.has(info.id)}
                    />
                  </button>
                  {/* View events button */}
                  <button
                    style={styles.signalActionButtonStyles}
                    onClick={(e) => {
                      e.stopPropagation();
                      setSearchQuery(info.name);
                      setEventKindFilter("all");
                      updateActiveTab("events");
                    }}
                    title="View events for this signal"
                  >
                    <IconHistory size={12} />
                  </button>
                  {/* Reset button for mutable signals */}
                  {!info.disposed && info.kind === "mutable" && (
                    <button
                      style={styles.signalActionButtonStyles}
                      onClick={(e) => {
                        e.stopPropagation();
                        try {
                          (info.signal as any).reset();
                        } catch (err) {
                          console.error("Reset failed:", err);
                        }
                      }}
                      title="Reset to initial value"
                    >
                      <IconResetSmall size={12} />
                    </button>
                  )}
                  {/* Refresh button for computed signals */}
                  {!info.disposed && info.kind === "computed" && (
                    <button
                      style={styles.signalActionButtonStyles}
                      onClick={(e) => {
                        e.stopPropagation();
                        try {
                          const sig = info.signal as any;
                          if (sig.paused?.()) {
                            sig.resume();
                          } else {
                            // Force re-read to refresh
                            sig();
                          }
                        } catch (err) {
                          console.error("Refresh failed:", err);
                        }
                      }}
                      title="Refresh / Resume if paused"
                    >
                      <IconRefresh size={12} />
                    </button>
                  )}
                  {/* Delete button for disposed signals */}
                  {info.disposed && (
                    <button
                      style={{
                        ...styles.signalActionButtonStyles,
                        color: "#888",
                      }}
                      onClick={(e) => {
                        e.stopPropagation();
                        deleteSignal(info.id);
                      }}
                      title="Remove from devtools"
                    >
                      <IconTrash size={12} />
                    </button>
                  )}
                </div>
              </div>
              <div
                style={{
                  ...styles.valueStyles,
                  ...(info.disposed && { color: "#555" }),
                  ...(hasError && { color: styles.colors.errorText }),
                }}
              >
                {!info.disposed && (
                  <span
                    style={{
                      color: styles.colors.textMuted,
                      marginRight: "4px",
                    }}
                  >
                    {info.changeCount}√ó
                  </span>
                )}
                {hasError
                  ? `‚ö† ${String(currentValue)}`
                  : formatValue(currentValue)}
              </div>

              {isExpanded && (
                <div
                  style={{
                    marginTop: "6px",
                    paddingTop: "6px",
                    borderTop: `1px solid ${styles.colors.border}`,
                  }}
                >
                  {/* Full signal name */}
                  <div
                    style={{
                      fontSize: "10px",
                      color: styles.colors.text,
                      marginBottom: "4px",
                      wordBreak: "break-all",
                      fontFamily: styles.fontMono,
                    }}
                  >
                    <span
                      style={{
                        color: styles.colors.textMuted,
                        fontSize: "9px",
                      }}
                    >
                      Name:{" "}
                    </span>
                    {info.name}
                  </div>

                  {/* Signal UID */}
                  <div
                    style={{
                      fontSize: "10px",
                      color: styles.colors.textMuted,
                      marginBottom: "8px",
                      fontFamily: styles.fontMono,
                    }}
                  >
                    <span
                      style={{
                        fontSize: "9px",
                      }}
                    >
                      UID:{" "}
                    </span>
                    {info.id}
                  </div>

                  {/* Edit form for mutable signals - replaces readonly value display */}
                  {editingSignal === info.id && info.kind === "mutable" && (
                    <div
                      style={{
                        marginBottom: "8px",
                      }}
                      onClick={(e) => e.stopPropagation()}
                    >
                      <div
                        style={{
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "space-between",
                          marginBottom: "4px",
                        }}
                      >
                        <span
                          style={{
                            fontSize: "9px",
                            color: styles.colors.textMuted,
                          }}
                        >
                          Value:
                        </span>
                      </div>
                      <textarea
                        value={editValue}
                        onChange={(e) => {
                          setEditValue(e.target.value);
                          setEditError(null);
                        }}
                        style={{
                          width: "100%",
                          minHeight: "150px",
                          backgroundColor: styles.colors.bg,
                          border: editError
                            ? `1px solid ${styles.colors.error}`
                            : `1px solid ${styles.colors.border}`,
                          borderRadius: "4px",
                          color: styles.colors.text,
                          fontSize: "10px",
                          fontFamily: styles.fontMono,
                          padding: "6px",
                          resize: "vertical",
                          outline: "none",
                          overflow: "auto",
                          whiteSpace: "pre",
                          wordBreak: "normal",
                        }}
                        placeholder="Enter JSON value..."
                        autoFocus
                      />
                      {editError && (
                        <div
                          style={{
                            color: styles.colors.error,
                            fontSize: "9px",
                            marginTop: "4px",
                          }}
                        >
                          {editError}
                        </div>
                      )}
                      <div
                        style={{
                          display: "flex",
                          gap: "6px",
                          marginTop: "6px",
                          justifyContent: "flex-end",
                          flexWrap: "nowrap",
                        }}
                      >
                        <button
                          style={{
                            ...styles.signalActionButtonStyles,
                            width: "auto",
                            height: "auto",
                            padding: "4px 10px",
                            whiteSpace: "nowrap",
                          }}
                          onClick={() => {
                            setEditingSignal(null);
                            setEditError(null);
                          }}
                        >
                          Cancel
                        </button>
                        <button
                          style={{
                            ...styles.signalActionButtonStyles,
                            width: "auto",
                            height: "auto",
                            padding: "4px 10px",
                            backgroundColor: styles.colors.mutable + "33",
                            color: styles.colors.mutable,
                            whiteSpace: "nowrap",
                          }}
                          onClick={() => {
                            try {
                              const parsed = JSON.parse(editValue);
                              (info.signal as any).set(parsed);
                              setEditingSignal(null);
                              setEditError(null);
                            } catch (err) {
                              setEditError(
                                err instanceof Error
                                  ? err.message
                                  : "Invalid JSON"
                              );
                            }
                          }}
                        >
                          Set Value
                        </button>
                      </div>
                    </div>
                  )}

                  {/* Full value with actions - hide when editing */}
                  {!info.disposed && editingSignal !== info.id && (
                    <div style={{ marginBottom: "8px" }}>
                      <div
                        style={{
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "space-between",
                          marginBottom: "4px",
                        }}
                      >
                        <span
                          style={{
                            fontSize: "9px",
                            color: styles.colors.textMuted,
                          }}
                        >
                          Value:
                        </span>
                        <div style={{ display: "flex", gap: "4px" }}>
                          {/* Copy button */}
                          <button
                            style={styles.signalActionButtonStyles}
                            onClick={(e) => {
                              e.stopPropagation();
                              try {
                                if (hasError) {
                                  navigator.clipboard.writeText(
                                    String(signalError)
                                  );
                                } else {
                                  const value = info.signal.tryGet();
                                  const json = JSON.stringify(value, null, 2);
                                  navigator.clipboard.writeText(json);
                                }
                              } catch (err) {
                                console.error("Copy failed:", err);
                              }
                            }}
                            title={
                              hasError
                                ? "Copy error message"
                                : "Copy JSON value"
                            }
                          >
                            <IconCopy size={12} />
                          </button>
                          {/* Edit button for mutable signals */}
                          {info.kind === "mutable" && !hasError && (
                            <button
                              style={styles.signalActionButtonStyles}
                              onClick={(e) => {
                                e.stopPropagation();
                                try {
                                  const value = info.signal.tryGet();
                                  setEditValue(JSON.stringify(value, null, 2));
                                  setEditError(null);
                                  setEditingSignal(info.id);
                                } catch (err) {
                                  console.error("Edit failed:", err);
                                }
                              }}
                              title="Edit value (JSON)"
                            >
                              <IconEdit size={12} />
                            </button>
                          )}
                        </div>
                      </div>
                      <pre
                        style={{
                          margin: 0,
                          padding: "6px",
                          backgroundColor: styles.colors.bg,
                          borderRadius: "4px",
                          fontSize: "9px",
                          color: hasError
                            ? styles.colors.errorText
                            : styles.colors.text,
                          overflow: "auto",
                          maxHeight: "150px",
                          whiteSpace: "pre-wrap",
                          wordBreak: "break-all",
                          fontFamily: styles.fontMono,
                        }}
                      >
                        {hasError
                          ? `‚ö† ${String(signalError)}`
                          : formatValueFull(currentValue)}
                      </pre>
                    </div>
                  )}

                  {/* Source location */}
                  {info.source && (
                    <div
                      style={{
                        fontSize: "9px",
                        color: styles.colors.textMuted,
                        marginBottom: info.history.length > 0 ? "6px" : 0,
                      }}
                    >
                      <span style={{ opacity: 0.6 }}>üìç</span>{" "}
                      <span
                        style={{ color: styles.colors.textDim }}
                        title={info.source.functionName || undefined}
                      >
                        {info.source.file}:{info.source.line}
                      </span>
                      {info.source.functionName && (
                        <span style={{ opacity: 0.6 }}>
                          {" "}
                          ({info.source.functionName})
                        </span>
                      )}
                    </div>
                  )}
                  {/* History */}
                  {info.history.length > 0 && (
                    <div style={{ marginTop: "6px" }}>
                      <div
                        style={{
                          fontSize: "9px",
                          color: styles.colors.textMuted,
                          marginBottom: "4px",
                        }}
                      >
                        History:
                      </div>
                      {info.history.slice(0, 5).map((entry, i) => {
                        const isCurrentValue = i === 0;
                        let currentValue: unknown;
                        try {
                          currentValue = info.signal.get();
                        } catch {
                          currentValue = undefined;
                        }
                        return (
                          <div
                            key={i}
                            style={{
                              display: "flex",
                              alignItems: "center",
                              gap: "4px",
                              fontSize: "9px",
                              color: styles.colors.textDim,
                              marginBottom: "2px",
                            }}
                          >
                            <span style={{ color: styles.colors.textMuted }}>
                              {formatTime(entry.timestamp)}
                            </span>
                            <span
                              style={{
                                flex: 1,
                                overflow: "hidden",
                                textOverflow: "ellipsis",
                                whiteSpace: "nowrap",
                              }}
                            >
                              ‚Üí {formatValue(entry.value)}
                            </span>
                            {/* Compare button */}
                            {!isCurrentValue && (
                              <button
                                style={{
                                  ...styles.signalActionButtonStyles,
                                  width: "18px",
                                  height: "18px",
                                  flexShrink: 0,
                                }}
                                onClick={(e) => {
                                  e.stopPropagation();
                                  setCompareModal({
                                    signalId: info.id,
                                    currentValue,
                                    historyValue: entry.value,
                                    historyTimestamp: entry.timestamp,
                                  });
                                }}
                                title="Compare with current value"
                              >
                                <IconCompare size={10} />
                              </button>
                            )}
                            {/* Revert button for mutable signals */}
                            {!info.disposed &&
                              info.kind === "mutable" &&
                              !isCurrentValue && (
                                <button
                                  style={{
                                    ...styles.signalActionButtonStyles,
                                    width: "18px",
                                    height: "18px",
                                    flexShrink: 0,
                                  }}
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    try {
                                      (info.signal as any).set(entry.value);
                                    } catch (err) {
                                      console.error("Revert failed:", err);
                                    }
                                  }}
                                  title="Revert to this value"
                                >
                                  <IconRevert size={10} />
                                </button>
                              )}
                            <button
                              style={{
                                ...styles.signalActionButtonStyles,
                                width: "18px",
                                height: "18px",
                                flexShrink: 0,
                              }}
                              onClick={(e) => {
                                e.stopPropagation();
                                try {
                                  const json = JSON.stringify(
                                    entry.value,
                                    null,
                                    2
                                  );
                                  navigator.clipboard.writeText(json);
                                } catch (err) {
                                  console.error("Copy failed:", err);
                                }
                              }}
                              title="Copy value"
                            >
                              <IconCopy size={10} />
                            </button>
                          </div>
                        );
                      })}
                    </div>
                  )}
                </div>
              )}
            </div>
          );
        })}
      </div>
    );
  };

  const renderTags = () => {
    if (tags.size === 0) {
      return <div style={styles.emptyStateStyles}>No tags tracked</div>;
    }

    if (filteredTags.length === 0) {
      if (searchQuery.trim()) {
        return (
          <div style={styles.emptyStateStyles}>
            No tags match "{searchQuery}"
          </div>
        );
      }
      return (
        <div style={styles.emptyStateStyles}>
          No user-named tags
          <div style={{ fontSize: "9px", marginTop: "4px", opacity: 0.7 }}>
            Check "Show #auto" to see {tags.size} auto-generated
          </div>
        </div>
      );
    }

    return (
      <div style={styles.contentGridStyles(position)}>
        {filteredTags.map((info) => {
          const isHovered = hoveredItem === `tag-${info.id}`;
          const isExpanded = expandedTag === info.id;
          const signalIds = Array.from(info.signals);

          return (
            <div
              key={info.id}
              style={styles.itemStyles(isHovered)}
              onMouseEnter={() => setHoveredItem(`tag-${info.id}`)}
              onMouseLeave={() => setHoveredItem(null)}
              onClick={() => setExpandedTag(isExpanded ? null : info.id)}
            >
              <div style={styles.itemHeaderStyles}>
                <span style={styles.itemNameStyles}>
                  <span style={styles.badgeStyles("tag")}>T</span>
                  <span
                    style={{ overflow: "hidden", textOverflow: "ellipsis" }}
                  >
                    {info.id}
                  </span>
                </span>
                <div
                  style={{ display: "flex", alignItems: "center", gap: "6px" }}
                >
                  <span
                    style={{ color: styles.colors.textDim, fontSize: "9px" }}
                  >
                    {info.signals.size} sig
                  </span>
                  {info.signals.size > 0 && (
                    <button
                      style={{
                        ...styles.signalActionButtonStyles,
                        color: styles.colors.error,
                      }}
                      onClick={(e) => {
                        e.stopPropagation();
                        takeSnapshotForTag(info.id, signalIds);
                      }}
                      title={`Take snapshot of signals in "${info.id}"`}
                    >
                      <IconCamera size={12} />
                    </button>
                  )}
                  <span
                    style={{
                      color: styles.colors.textMuted,
                      fontSize: "8px",
                      transition: "transform 0.2s",
                      transform: isExpanded ? "rotate(90deg)" : "rotate(0deg)",
                    }}
                  >
                    ‚ñ∂
                  </span>
                </div>
              </div>

              {/* Collapsed preview */}
              {!isExpanded && info.signals.size > 0 && (
                <div style={styles.valueStyles}>
                  {signalIds
                    .slice(0, 3)
                    .map((id) => signals.get(id)?.name || id)
                    .join(", ")}
                  {info.signals.size > 3 && ` +${info.signals.size - 3}`}
                </div>
              )}

              {/* Expanded details box */}
              {isExpanded && (
                <div
                  style={{
                    marginTop: "8px",
                    paddingTop: "8px",
                    borderTop: `1px solid ${styles.colors.border}`,
                  }}
                  onClick={(e) => e.stopPropagation()}
                >
                  <div
                    style={{
                      fontSize: "9px",
                      color: styles.colors.textMuted,
                      marginBottom: "6px",
                      fontWeight: 600,
                    }}
                  >
                    Signals ({info.signals.size})
                  </div>
                  {info.signals.size === 0 ? (
                    <div
                      style={{
                        fontSize: "10px",
                        color: styles.colors.textDim,
                        fontStyle: "italic",
                      }}
                    >
                      No signals in this tag
                    </div>
                  ) : (
                    <div
                      style={{
                        display: "flex",
                        flexDirection: "column",
                        gap: "4px",
                        maxHeight: "200px",
                        overflowY: "auto",
                      }}
                    >
                      {signalIds.map((signalId) => {
                        const signalInfo = signals.get(signalId);
                        const isDisposed = signalInfo?.disposed;

                        return (
                          <div
                            key={signalId}
                            style={{
                              display: "flex",
                              alignItems: "center",
                              gap: "6px",
                              padding: "4px 6px",
                              backgroundColor: styles.colors.bgHover,
                              borderRadius: "4px",
                              cursor: "pointer",
                              ...(isDisposed && {
                                opacity: 0.5,
                                textDecoration: "line-through",
                              }),
                            }}
                            onClick={(e) => {
                              e.stopPropagation();
                              setSearchQuery(signalInfo?.name || signalId);
                              setSignalKindFilter("all");
                              updateActiveTab("signals");
                            }}
                            title={`${
                              signalInfo?.name || signalId
                            }\nUID: ${signalId}`}
                          >
                            <span
                              style={{
                                ...styles.badgeStyles(
                                  signalInfo?.kind || "mutable"
                                ),
                                ...(isDisposed && {
                                  backgroundColor: "#444",
                                  color: "#888",
                                }),
                              }}
                            >
                              {isDisposed
                                ? "‚úï"
                                : signalInfo?.kind === "computed"
                                ? "C"
                                : "M"}
                            </span>
                            <span
                              style={{
                                fontSize: "10px",
                                color: styles.colors.text,
                                flex: 1,
                                overflow: "hidden",
                                textOverflow: "ellipsis",
                                whiteSpace: "nowrap",
                              }}
                            >
                              {signalInfo?.name || signalId}
                            </span>
                            {signalInfo && !isDisposed && (
                              <span
                                style={{
                                  fontSize: "9px",
                                  color: styles.colors.textDim,
                                  maxWidth: "100px",
                                  overflow: "hidden",
                                  textOverflow: "ellipsis",
                                  whiteSpace: "nowrap",
                                }}
                              >
                                {(() => {
                                  const val = signalInfo.signal.tryGet();
                                  if (isPromiseLike(val)) {
                                    const state = task.from(val);
                                    if (state.status === "success")
                                      return formatValue(state.value);
                                    if (state.status === "error")
                                      return `‚ö† ${String(state.error)}`;
                                    return "[async]";
                                  }
                                  return formatValue(val);
                                })()}
                              </span>
                            )}
                          </div>
                        );
                      })}
                    </div>
                  )}
                </div>
              )}
            </div>
          );
        })}
      </div>
    );
  };

  const clearEvents = () => {
    setEvents([]);
  };

  const renderEvents = () => {
    return (
      <div style={{ display: "flex", flexDirection: "column", height: "100%" }}>
        {filteredEvents.length === 0 ? (
          <div style={styles.emptyStateStyles}>
            {events.length === 0 ? "No events yet" : "No matching events"}
          </div>
        ) : (
          <div
            style={{
              ...styles.eventLogStyles,
              flex: 1,
              overflowY: "auto",
              maxHeight: "none",
            }}
          >
            {filteredEvents.map((event) => {
              // Get signal name and UID for display
              let signalName: string | null = null;
              let signalUid: string | null = null;
              if ("signal" in event && event.signal) {
                signalName =
                  (event.signal as any).name || (event.signal as any).id;
                signalUid = (event.signal as any).id || null;
              } else if ("signalId" in event) {
                signalUid = String(event.signalId);
                const info = signals.get(signalUid);
                signalName = info?.name || signalUid;
              }
              const tagId = "tagId" in event ? String(event.tagId) : null;
              const isEventExpanded = expandedEvents.has(event.id);

              // Handle both value and error events
              let valueStr: string | null = null;
              let errorContext: string | null = null;
              let errorPreview: string | null = null; // For first line display

              if (event.type === "window:error") {
                // Window error event
                const winError = event as any;
                const errorMsg =
                  winError.message || String(winError.error || "Unknown error");
                errorPreview = errorMsg; // Show in first line
                if (winError.source) {
                  errorContext = `${winError.source}:${
                    winError.lineno || "?"
                  }:${winError.colno || "?"}`;
                }
                // Serialize full error object
                try {
                  if (winError.error) {
                    // Create a serializable error object
                    const errorObj: any = {
                      message: winError.error.message || winError.message,
                      name: winError.error.name,
                      stack: winError.error.stack,
                    };
                    // Add any additional properties
                    Object.getOwnPropertyNames(winError.error).forEach(
                      (key) => {
                        if (!["message", "name", "stack"].includes(key)) {
                          try {
                            errorObj[key] = (winError.error as any)[key];
                          } catch {
                            // Skip non-serializable properties
                          }
                        }
                      }
                    );
                    valueStr = JSON.stringify(errorObj, null, 2);
                  } else {
                    valueStr = JSON.stringify({ message: errorMsg }, null, 2);
                  }
                } catch {
                  // Fallback to message if serialization fails
                  valueStr = JSON.stringify({ message: errorMsg }, null, 2);
                }
              } else if (event.type === "window:unhandledrejection") {
                // Unhandled promise rejection
                const rejection = event as any;
                // Access reason directly from event (it's at the top level)
                const reason = rejection.reason ?? (event as any).reason;
                if (reason !== undefined && reason !== null) {
                  if (reason instanceof Error) {
                    errorPreview = reason.message || reason.toString();
                    try {
                      // Serialize Error object with all properties
                      const errorObj: any = {
                        message: reason.message,
                        name: reason.name,
                        stack: reason.stack,
                      };
                      Object.getOwnPropertyNames(reason).forEach((key) => {
                        if (!["message", "name", "stack"].includes(key)) {
                          try {
                            errorObj[key] = (reason as any)[key];
                          } catch {
                            // Skip non-serializable properties
                          }
                        }
                      });
                      valueStr = JSON.stringify(errorObj, null, 2);
                    } catch {
                      valueStr = JSON.stringify(
                        { message: reason.message || String(reason) },
                        null,
                        2
                      );
                    }
                  } else {
                    // For non-Error reasons (strings, objects, etc.), show them directly
                    errorPreview = String(reason);
                    try {
                      // For strings, just use the string directly (no JSON.stringify to avoid double quotes)
                      if (typeof reason === "string") {
                        valueStr = reason;
                      } else {
                        // For objects/arrays, stringify them
                        valueStr = JSON.stringify(reason, null, 2);
                      }
                    } catch {
                      // If stringification fails, just use the string representation
                      valueStr = String(reason);
                    }
                  }
                } else {
                  errorPreview =
                    "Unhandled promise rejection (no reason provided)";
                  valueStr = JSON.stringify(
                    {
                      message:
                        "Unhandled promise rejection (no reason provided)",
                    },
                    null,
                    2
                  );
                }
              } else if ("value" in event) {
                valueStr = JSON.stringify(event.value, null, 2);
              } else if ("error" in event && event.error) {
                const err = event.error as any;
                errorPreview = err.message || String(err.error);
                valueStr = err.message || String(err.error);
                // Show error context (when/async)
                if (err.context) {
                  errorContext = `${err.context.when}${
                    err.context.async ? " (async)" : ""
                  }`;
                }
              }

              return (
                <div
                  key={event.id}
                  style={{
                    ...styles.eventItemStyles,
                    cursor: valueStr ? "pointer" : "default",
                    flexDirection: "column",
                    alignItems: "flex-start",
                    gap: "4px",
                    ...(event.isError && {
                      backgroundColor: `${styles.colors.error}15`,
                      borderLeft: `3px solid ${styles.colors.error}`,
                    }),
                  }}
                  onClick={() => {
                    if (valueStr) {
                      setExpandedEvents((prev) => {
                        const next = new Set(prev);
                        if (next.has(event.id)) {
                          next.delete(event.id);
                        } else {
                          next.add(event.id);
                        }
                        return next;
                      });
                    }
                  }}
                >
                  <div
                    style={{
                      display: "flex",
                      alignItems: "center",
                      gap: "6px",
                      width: "100%",
                      flex: 1,
                      minWidth: 0,
                      overflow: "hidden",
                    }}
                  >
                    <span
                      style={{
                        color: styles.colors.textMuted,
                        fontSize: "8px",
                        minWidth: "50px",
                        flexShrink: 0,
                      }}
                    >
                      {formatTime(event.timestamp)}
                    </span>
                    <span
                      style={styles.eventTypeStyles(event.type, event.isError)}
                    >
                      {event.type === "window:error"
                        ? "window error"
                        : event.type === "window:unhandledrejection"
                        ? "unhandled rejection"
                        : event.type.split(":")[1] === "change"
                        ? "update"
                        : event.type.split(":")[1]}
                    </span>
                    {errorContext && (
                      <span
                        style={{
                          fontSize: "8px",
                          padding: "1px 4px",
                          borderRadius: "3px",
                          backgroundColor: `${styles.colors.error}30`,
                          color: styles.colors.errorText,
                          fontFamily: styles.fontMono,
                        }}
                        title="Error context: when the error occurred"
                      >
                        {errorContext}
                      </span>
                    )}
                    <span
                      style={{
                        color: styles.colors.textDim,
                        flex: 1,
                        overflow: "hidden",
                        textOverflow: "ellipsis",
                        whiteSpace: "nowrap",
                      }}
                    >
                      {signalName && (
                        <span
                          style={{
                            cursor: "pointer",
                            textDecoration: "underline",
                            textDecorationStyle: "dotted",
                          }}
                          onClick={(e) => {
                            e.stopPropagation();
                            setSearchQuery(signalName);
                            setSignalKindFilter("all");
                            updateActiveTab("signals");
                          }}
                          title={
                            signalUid
                              ? `${signalName}\nUID: ${signalUid}`
                              : signalName!
                          }
                        >
                          {signalName}
                        </span>
                      )}
                      {tagId && (
                        <span
                          style={{
                            cursor: "pointer",
                            textDecoration: "underline",
                            textDecorationStyle: "dotted",
                          }}
                          onClick={(e) => {
                            e.stopPropagation();
                            setSearchQuery(tagId);
                            updateActiveTab("tags");
                          }}
                          title={`Go to tag: ${tagId}`}
                        >
                          {tagId}
                        </span>
                      )}
                      {/* Show error/reason preview for window errors and rejections */}
                      {errorPreview &&
                        (event.type === "window:error" ||
                          event.type === "window:unhandledrejection") && (
                          <span
                            style={{
                              color: styles.colors.errorText,
                              fontFamily: styles.fontMono,
                              fontSize: "9px",
                              marginLeft: signalName || tagId ? "8px" : "0",
                              fontWeight: 500,
                            }}
                            title={
                              errorPreview.length > 60
                                ? errorPreview
                                : undefined
                            }
                          >
                            {errorPreview.length > 60
                              ? errorPreview.slice(0, 57) + "..."
                              : errorPreview}
                          </span>
                        )}
                      {/* Always show reason for unhandled rejections, even if errorPreview wasn't set */}
                      {event.type === "window:unhandledrejection" &&
                        !errorPreview && (
                          <span
                            style={{
                              color: styles.colors.errorText,
                              fontFamily: styles.fontMono,
                              fontSize: "9px",
                              marginLeft: signalName || tagId ? "8px" : "0",
                              fontWeight: 500,
                            }}
                          >
                            {(event as any).reason !== undefined &&
                            (event as any).reason !== null
                              ? String((event as any).reason)
                              : "(no reason)"}
                          </span>
                        )}
                    </span>
                    {valueStr && (
                      <button
                        style={{
                          ...styles.signalActionButtonStyles,
                          flexShrink: 0,
                        }}
                        onClick={(e) => {
                          e.stopPropagation();
                          try {
                            navigator.clipboard.writeText(valueStr);
                          } catch (err) {
                            console.error("Copy failed:", err);
                          }
                        }}
                        title="Copy value"
                      >
                        <IconCopy size={12} />
                      </button>
                    )}
                    {valueStr && (
                      <span
                        style={{
                          color: styles.colors.textMuted,
                          flexShrink: 0,
                          display: "flex",
                          alignItems: "center",
                        }}
                      >
                        {isEventExpanded ? (
                          <IconChevronDown size={12} />
                        ) : (
                          <IconChevronRight size={12} />
                        )}
                      </span>
                    )}
                  </div>
                  {/* Value on second line - aligned with the tag */}
                  {valueStr && !isEventExpanded && (
                    <div
                      style={{
                        fontSize: "9px",
                        color:
                          event.type === "window:error" ||
                          event.type === "window:unhandledrejection"
                            ? styles.colors.errorText
                            : styles.colors.textMuted,
                        overflow: "hidden",
                        textOverflow: "ellipsis",
                        whiteSpace: "nowrap",
                        width: "100%",
                        fontFamily: styles.fontMono,
                        paddingLeft: "56px", // Align with tag (50px time + 6px gap)
                      }}
                    >
                      {event.type === "window:error" ||
                      event.type === "window:unhandledrejection"
                        ? formatValue(valueStr, 100) // Longer preview for errors
                        : formatValue((event as any).value)}
                    </div>
                  )}
                  {isEventExpanded && valueStr && (
                    <pre
                      style={{
                        margin: "6px 0 0 0",
                        marginLeft: "56px", // Align with tag (50px time + 6px gap)
                        padding: "6px",
                        backgroundColor: styles.colors.bg,
                        borderRadius: "4px",
                        fontSize: "9px",
                        color: styles.colors.text,
                        overflow: "auto",
                        maxHeight: "200px",
                        width: "calc(100% - 56px)",
                        whiteSpace: "pre-wrap",
                        wordBreak: "break-all",
                      }}
                    >
                      {valueStr}
                    </pre>
                  )}
                </div>
              );
            })}
          </div>
        )}
      </div>
    );
  };

  // Render chains tab
  const renderChains = () => {
    // Filter chains by signal name (look up name from ID)
    const filteredChains = chainFilter
      ? chains.filter((chain) =>
          chain.path.some((signalId) => {
            const signalInfo = signals.get(signalId);
            const signalName = signalInfo?.name || signalId;
            return signalName.toLowerCase().includes(chainFilter.toLowerCase());
          })
        )
      : chains;

    if (chains.length === 0) {
      return (
        <div
          style={{
            ...styles.emptyStateStyles,
            textAlign: "center",
            padding: "32px",
          }}
        >
          <div style={{ fontSize: "24px", marginBottom: "4px" }}>üîó</div>
          <div style={{ marginBottom: "4px" }}>
            No chain reactions detected yet
          </div>
          <div style={{ fontSize: "11px", color: styles.colors.textMuted }}>
            Chain reactions with 2+ signals will appear here
          </div>
        </div>
      );
    }

    if (filteredChains.length === 0) {
      return (
        <div
          style={{
            ...styles.emptyStateStyles,
            textAlign: "center",
            padding: "32px",
          }}
        >
          <div style={{ marginBottom: "8px" }}>No chains match filter</div>
          <div style={{ fontSize: "11px", color: styles.colors.textMuted }}>
            {chains.length} chain{chains.length !== 1 ? "s" : ""} total
          </div>
        </div>
      );
    }

    return (
      <div style={{ display: "flex", flexDirection: "column", gap: "6px" }}>
        {filteredChains.map((chain) => {
          const isExpanded = expandedChain === chain.id;
          const occurrenceCount = chain.occurrences.length;

          return (
            <div
              key={chain.id}
              style={{
                backgroundColor: styles.colors.bgLight,
                borderRadius: "6px",
                border: `1px solid ${styles.colors.border}`,
                overflow: "hidden",
              }}
            >
              {/* Chain header */}
              <div
                style={{
                  padding: "10px 12px",
                  display: "flex",
                  alignItems: "center",
                  gap: "8px",
                  cursor: "pointer",
                  backgroundColor: isExpanded
                    ? styles.colors.bgHover
                    : "transparent",
                }}
                onClick={() => setExpandedChain(isExpanded ? null : chain.id)}
              >
                {/* Expand arrow */}
                <span
                  style={{
                    fontSize: "10px",
                    color: styles.colors.textMuted,
                    transition: "transform 0.15s",
                    transform: isExpanded ? "rotate(90deg)" : "rotate(0deg)",
                  }}
                >
                  ‚ñ∂
                </span>

                {/* Chain path */}
                <div
                  style={{
                    flex: 1,
                    fontSize: "11px",
                    fontFamily: styles.fontMono,
                    display: "flex",
                    flexWrap: "wrap",
                    alignItems: "center",
                    gap: "4px",
                  }}
                >
                  {chain.path.map((signalId, idx) => {
                    // Look up signal name for display
                    const signalInfo = signals.get(signalId);
                    const signalName = signalInfo?.name || signalId;
                    return (
                      <React.Fragment key={idx}>
                        <span
                          style={{
                            color: chain.asyncSignals.has(signalId)
                              ? styles.colors.warning
                              : styles.colors.text,
                            cursor: "pointer",
                          }}
                          onClick={(e) => {
                            e.stopPropagation();
                            setSearchQuery(signalName);
                            setSignalKindFilter("all");
                            updateActiveTab("signals");
                          }}
                          title={`${signalName}\nUID: ${signalId}`}
                        >
                          {signalName}
                          {chain.asyncSignals.has(signalId) && (
                            <span
                              style={{
                                fontSize: "8px",
                                marginLeft: "2px",
                                color: styles.colors.warning,
                              }}
                            >
                              [async]
                            </span>
                          )}
                        </span>
                        {idx < chain.path.length - 1 && (
                          <span style={{ color: styles.colors.textMuted }}>
                            ‚Üí
                          </span>
                        )}
                      </React.Fragment>
                    );
                  })}
                </div>

                {/* Occurrence count */}
                <span
                  style={{
                    fontSize: "10px",
                    color: styles.colors.textMuted,
                    backgroundColor: styles.colors.bgHover,
                    padding: "2px 6px",
                    borderRadius: "10px",
                  }}
                >
                  √ó{occurrenceCount}
                </span>

                {/* Delete button */}
                <button
                  style={{
                    ...styles.signalActionButtonStyles,
                    padding: "2px 6px",
                    fontSize: "10px",
                  }}
                  onClick={(e) => {
                    e.stopPropagation();
                    deleteChain(chain.id);
                    setChains(getChainsList());
                  }}
                  title="Delete chain"
                >
                  <IconClose size={12} />
                </button>
              </div>

              {/* Expanded: occurrence history */}
              {isExpanded && (
                <div
                  style={{
                    borderTop: `1px solid ${styles.colors.border}`,
                    padding: "8px 12px",
                    maxHeight: "200px",
                    overflowY: "auto",
                  }}
                >
                  <div
                    style={{
                      fontSize: "10px",
                      color: styles.colors.textMuted,
                      marginBottom: "8px",
                    }}
                  >
                    Recent occurrences:
                  </div>
                  {chain.occurrences.slice(0, 20).map((occ, idx) => (
                    <div
                      key={idx}
                      style={{
                        display: "flex",
                        alignItems: "center",
                        gap: "8px",
                        fontSize: "10px",
                        padding: "4px 0",
                        borderBottom:
                          idx < chain.occurrences.length - 1
                            ? `1px solid ${styles.colors.border}`
                            : "none",
                      }}
                    >
                      <span style={{ color: styles.colors.textDim }}>
                        {new Date(occ.startTime).toLocaleTimeString("en-GB", {
                          hour12: false,
                        })}
                      </span>
                      {occ.duration !== undefined && (
                        <span
                          style={{
                            color: styles.colors.textMuted,
                            backgroundColor: styles.colors.bgHover,
                            padding: "1px 4px",
                            borderRadius: "3px",
                          }}
                        >
                          {occ.duration}ms
                        </span>
                      )}
                      <span
                        style={{
                          color:
                            occ.status === "complete"
                              ? styles.colors.success
                              : occ.status === "interrupted"
                              ? styles.colors.error
                              : styles.colors.warning,
                        }}
                      >
                        {occ.status === "complete"
                          ? "‚úì"
                          : occ.status === "interrupted"
                          ? "‚úï"
                          : "‚è≥"}
                      </span>
                    </div>
                  ))}
                  {chain.occurrences.length > 20 && (
                    <div
                      style={{
                        fontSize: "9px",
                        color: styles.colors.textMuted,
                        textAlign: "center",
                        marginTop: "8px",
                      }}
                    >
                      ... and {chain.occurrences.length - 20} more
                    </div>
                  )}
                </div>
              )}
            </div>
          );
        })}
      </div>
    );
  };

  // Get all graph nodes with children (for expand all)
  const getGraphNodesWithChildren = useCallback(() => {
    const nodes = new Set<string>();
    for (const edge of dependencyGraph.edges) {
      nodes.add(edge.from);
    }
    return nodes;
  }, [dependencyGraph.edges]);

  // Auto-expand all nodes only on initial mount (not on every graph change)
  const hasInitialGraphExpand = useRef(false);
  useEffect(() => {
    if (hasInitialGraphExpand.current) return;
    const nodesWithChildren = getGraphNodesWithChildren();
    if (nodesWithChildren.size > 0) {
      hasInitialGraphExpand.current = true;
      setGraphExpandedNodes(nodesWithChildren);
    }
  }, [getGraphNodesWithChildren]);

  const handleGraphExpandAll = useCallback(() => {
    setGraphExpandedNodes(getGraphNodesWithChildren());
  }, [getGraphNodesWithChildren]);

  const handleGraphCollapseAll = useCallback(() => {
    setGraphExpandedNodes(new Set());
  }, []);

  const handleGraphNodeClick = useCallback(
    (nodeId: string) => {
      setGraphSelectedNodeId(nodeId === graphSelectedNodeId ? null : nodeId);
      const node = dependencyGraph.nodes.get(nodeId);
      if (node) {
        setSearchQuery(node.name);
        setSignalKindFilter("all");
        updateActiveTab("signals");
      }
    },
    [graphSelectedNodeId, dependencyGraph.nodes, updateActiveTab]
  );

  const renderGraph = () => {
    // Legend items for status colors (consistent with Signals tab)
    const legendItems = [
      { color: styles.colors.change, label: "Updated" },
      { color: styles.colors.error, label: "Error" },
      { color: styles.colors.textMuted, label: "Disposed" },
    ];

    return (
      <div
        style={{
          display: "flex",
          flexDirection: "column",
          height: "100%",
          overflow: "hidden",
        }}
      >
        {/* Status Legend */}
        <div
          style={{
            display: "flex",
            alignItems: "center",
            gap: "12px",
            padding: "6px 12px",
            borderBottom: `1px solid ${styles.colors.border}`,
            backgroundColor: styles.colors.bgLight,
            fontSize: "10px",
            color: styles.colors.textMuted,
            flexShrink: 0,
          }}
        >
          <span>Status:</span>
          {legendItems.map(({ color, label }) => (
            <div
              key={label}
              style={{
                display: "flex",
                alignItems: "center",
                gap: "4px",
              }}
            >
              <span
                style={{
                  width: "6px",
                  height: "6px",
                  borderRadius: "50%",
                  backgroundColor: color,
                  boxShadow:
                    label === "Updated" ? `0 0 4px ${color}` : undefined,
                }}
              />
              <span>{label}</span>
            </div>
          ))}
        </div>
        <SimpleTreeView
          graph={dependencyGraph}
          onNodeClick={handleGraphNodeClick}
          selectedNodeId={graphSelectedNodeId}
          expandedNodes={graphExpandedNodes}
          onExpandedNodesChange={setGraphExpandedNodes}
          recentlyUpdatedNodes={recentlyUpdatedNodes}
          searchQuery={graphSearchQuery}
        />
      </div>
    );
  };

  const formatSnapshotTime = (timestamp: number) => {
    return new Date(timestamp).toLocaleTimeString("en-GB", { hour12: false });
  };

  const getSignalPreview = (
    snapshotSignals: SnapshotSignal[],
    maxNames = 3
  ) => {
    const names = snapshotSignals.slice(0, maxNames).map((s) => s.name);
    const remaining = snapshotSignals.length - maxNames;
    if (remaining > 0) {
      return `${names.join(", ")}... +${remaining}`;
    }
    return names.join(", ");
  };

  const renderSnapshots = () => {
    // Filter snapshots by search
    const filteredSnapshots = snapshotSearch.trim()
      ? snapshots.filter((snapshot) => {
          const searchLower = snapshotSearch.toLowerCase();
          // Match snapshot name
          if (snapshot.name.toLowerCase().includes(searchLower)) return true;
          // Match signal names in snapshot
          if (
            snapshot.signals.some((s) =>
              s.name.toLowerCase().includes(searchLower)
            )
          )
            return true;
          return false;
        })
      : snapshots;

    if (snapshots.length === 0) {
      return (
        <div style={styles.emptyStateStyles}>
          No snapshots yet
          <div style={{ fontSize: "9px", marginTop: "4px", opacity: 0.7 }}>
            Click "Take Snapshot" to capture mutable signal states
          </div>
        </div>
      );
    }

    if (filteredSnapshots.length === 0) {
      return (
        <div style={styles.emptyStateStyles}>
          No snapshots match "{snapshotSearch}"
        </div>
      );
    }

    return (
      <div style={styles.contentGridStyles(position)}>
        {filteredSnapshots.map((snapshot) => {
          const isExpanded = expandedSnapshot === snapshot.id;
          const isEditing = editingSnapshotId === snapshot.id;

          return (
            <div
              key={snapshot.id}
              style={{
                backgroundColor: styles.colors.bgLight,
                borderRadius: "6px",
                border: `1px solid ${styles.colors.border}`,
                overflow: "hidden",
              }}
            >
              {/* Snapshot header */}
              <div
                style={{
                  display: "flex",
                  alignItems: "center",
                  gap: "8px",
                  padding: "8px 10px",
                  cursor: "pointer",
                  backgroundColor: isExpanded
                    ? styles.colors.bgHover
                    : "transparent",
                }}
                onClick={() =>
                  setExpandedSnapshot(isExpanded ? null : snapshot.id)
                }
              >
                {/* Expand/collapse indicator */}
                <span
                  style={{
                    fontSize: "10px",
                    color: styles.colors.textMuted,
                    width: "12px",
                  }}
                >
                  {isExpanded ? "‚ñº" : "‚ñ∂"}
                </span>

                {/* Timestamp */}
                <span
                  style={{
                    fontSize: "10px",
                    color: styles.colors.textMuted,
                    fontFamily: styles.fontMono,
                  }}
                >
                  {formatSnapshotTime(snapshot.timestamp)}
                </span>

                {/* Name (editable) */}
                {isEditing ? (
                  <input
                    type="text"
                    value={editingSnapshotName}
                    onChange={(e) => setEditingSnapshotName(e.target.value)}
                    onKeyDown={(e) => {
                      if (e.key === "Enter") {
                        renameSnapshot(snapshot.id, editingSnapshotName);
                      } else if (e.key === "Escape") {
                        setEditingSnapshotId(null);
                        setEditingSnapshotName("");
                      }
                    }}
                    onBlur={() => {
                      if (editingSnapshotName.trim()) {
                        renameSnapshot(snapshot.id, editingSnapshotName);
                      } else {
                        setEditingSnapshotId(null);
                        setEditingSnapshotName("");
                      }
                    }}
                    onClick={(e) => e.stopPropagation()}
                    autoFocus
                    style={{
                      flex: 1,
                      fontSize: "11px",
                      fontWeight: 600,
                      color: styles.colors.text,
                      backgroundColor: styles.colors.bg,
                      border: `1px solid ${styles.colors.accent}`,
                      borderRadius: "3px",
                      padding: "2px 6px",
                      outline: "none",
                      fontFamily: "inherit",
                    }}
                  />
                ) : (
                  <span
                    style={{
                      flex: 1,
                      fontSize: "11px",
                      fontWeight: 600,
                      color: styles.colors.text,
                    }}
                  >
                    {snapshot.name}
                  </span>
                )}

                {/* Action buttons */}
                <div
                  style={{ display: "flex", gap: "4px" }}
                  onClick={(e) => e.stopPropagation()}
                >
                  {/* Rename */}
                  <button
                    style={{
                      padding: "3px 6px",
                      fontSize: "10px",
                      backgroundColor: styles.colors.bgHover,
                      border: `1px solid ${styles.colors.border}`,
                      borderRadius: "3px",
                      color: styles.colors.textMuted,
                      cursor: "pointer",
                      display: "flex",
                      alignItems: "center",
                    }}
                    onClick={() => {
                      setEditingSnapshotId(snapshot.id);
                      setEditingSnapshotName(snapshot.name);
                    }}
                    title="Rename snapshot"
                  >
                    <IconEdit size={10} />
                  </button>
                  {/* Compare with current */}
                  <button
                    style={{
                      padding: "3px 6px",
                      fontSize: "10px",
                      backgroundColor: styles.colors.bgHover,
                      border: `1px solid ${styles.colors.border}`,
                      borderRadius: "3px",
                      color: styles.colors.computed,
                      cursor: "pointer",
                      display: "flex",
                      alignItems: "center",
                    }}
                    onClick={() => compareSnapshotWithCurrent(snapshot.id)}
                    title="Compare with current state"
                  >
                    <IconCompare size={10} />
                  </button>
                  {/* Revert all */}
                  <button
                    style={{
                      padding: "3px 6px",
                      fontSize: "10px",
                      backgroundColor: styles.colors.bgHover,
                      border: `1px solid ${styles.colors.border}`,
                      borderRadius: "3px",
                      color: styles.colors.warning,
                      cursor: "pointer",
                      display: "flex",
                      alignItems: "center",
                    }}
                    onClick={() => revertSnapshot(snapshot)}
                    title="Revert all signals to this snapshot"
                  >
                    <IconUndo size={10} />
                  </button>
                  {/* Delete */}
                  <button
                    style={{
                      padding: "3px 6px",
                      fontSize: "10px",
                      backgroundColor: styles.colors.bgHover,
                      border: `1px solid ${styles.colors.border}`,
                      borderRadius: "3px",
                      color: styles.colors.error,
                      cursor: "pointer",
                      display: "flex",
                      alignItems: "center",
                    }}
                    onClick={() => deleteSnapshot(snapshot.id)}
                    title="Delete snapshot"
                  >
                    <IconTrash size={10} />
                  </button>
                </div>
              </div>

              {/* Simple view (collapsed) */}
              {!isExpanded && (
                <div
                  style={{
                    padding: "4px 10px 8px 30px",
                    fontSize: "10px",
                    color: styles.colors.textMuted,
                  }}
                >
                  <span style={{ color: styles.colors.mutable }}>
                    {snapshot.signals.length}
                  </span>{" "}
                  {getSignalPreview(snapshot.signals)}
                </div>
              )}

              {/* Detailed view (expanded) */}
              {isExpanded && (
                <div
                  style={{
                    borderTop: `1px solid ${styles.colors.border}`,
                    maxHeight: "300px",
                    overflowY: "auto",
                  }}
                >
                  {snapshot.signals.length === 0 ? (
                    <div
                      style={{
                        padding: "12px",
                        fontSize: "10px",
                        color: styles.colors.textMuted,
                        textAlign: "center",
                      }}
                    >
                      No mutable signals captured
                    </div>
                  ) : (
                    snapshot.signals.map((sig) => {
                      const currentSignal = signals.get(sig.id);
                      // Check if signal is disposed (via WeakRef or signals map)
                      const signalFromRef = sig.signalRef?.deref();
                      const isDisposed =
                        !signalFromRef && currentSignal?.disposed !== false;
                      let currentValue: unknown;
                      try {
                        currentValue = currentSignal?.signal?.get?.();
                      } catch {
                        currentValue = "[error]";
                      }
                      const hasChanged =
                        JSON.stringify(currentValue) !==
                        JSON.stringify(sig.value);
                      const canRevert = hasChanged && !isDisposed;

                      return (
                        <div
                          key={sig.id}
                          style={{
                            display: "flex",
                            alignItems: "center",
                            gap: "8px",
                            padding: "6px 10px",
                            borderBottom: `1px solid ${styles.colors.border}`,
                            fontSize: "10px",
                            opacity: isDisposed ? 0.5 : 1,
                          }}
                        >
                          {/* Signal name (clickable) */}
                          <span
                            style={{
                              color: isDisposed
                                ? styles.colors.textMuted
                                : styles.colors.mutable,
                              cursor: isDisposed ? "default" : "pointer",
                              fontWeight: 500,
                              minWidth: "80px",
                              textDecoration: isDisposed
                                ? "line-through"
                                : "none",
                            }}
                            onClick={() => {
                              if (!isDisposed) {
                                setSearchQuery(sig.name);
                                setSignalKindFilter("mutable");
                                updateActiveTab("signals");
                              }
                            }}
                            title={
                              isDisposed ? "Signal disposed" : "Jump to signal"
                            }
                          >
                            {sig.name}
                          </span>
                          {/* Value */}
                          <span
                            style={{
                              flex: 1,
                              color: hasChanged
                                ? styles.colors.warning
                                : styles.colors.text,
                              fontFamily: styles.fontMono,
                              fontSize: "9px",
                              overflow: "hidden",
                              textOverflow: "ellipsis",
                              whiteSpace: "nowrap",
                            }}
                            title={JSON.stringify(sig.value, null, 2)}
                          >
                            {JSON.stringify(sig.value)}
                          </span>
                          {/* Actions */}
                          <div style={{ display: "flex", gap: "2px" }}>
                            {/* Copy */}
                            <button
                              style={{
                                padding: "2px 4px",
                                fontSize: "9px",
                                backgroundColor: "transparent",
                                border: "none",
                                color: styles.colors.textMuted,
                                cursor: "pointer",
                              }}
                              onClick={() => {
                                navigator.clipboard.writeText(
                                  JSON.stringify(sig.value, null, 2)
                                );
                              }}
                              title="Copy value"
                            >
                              <IconCopy size={10} />
                            </button>
                            {/* Compare */}
                            {hasChanged && !isDisposed && (
                              <button
                                style={{
                                  padding: "2px 4px",
                                  fontSize: "9px",
                                  backgroundColor: "transparent",
                                  border: "none",
                                  color: styles.colors.warning,
                                  cursor: "pointer",
                                }}
                                onClick={() => {
                                  setCompareModal({
                                    signalId: sig.id,
                                    currentValue,
                                    historyValue: sig.value,
                                    historyTimestamp: snapshot.timestamp,
                                  });
                                }}
                                title="Compare with current"
                              >
                                <IconCompare size={10} />
                              </button>
                            )}
                            {/* Revert single */}
                            <button
                              style={{
                                padding: "2px 4px",
                                fontSize: "9px",
                                backgroundColor: "transparent",
                                border: "none",
                                color: canRevert
                                  ? styles.colors.warning
                                  : styles.colors.textMuted,
                                cursor: canRevert ? "pointer" : "not-allowed",
                                opacity: canRevert ? 1 : 0.5,
                              }}
                              onClick={() => {
                                if (canRevert) {
                                  revertSingleSignal(sig);
                                }
                              }}
                              disabled={!canRevert}
                              title={
                                isDisposed
                                  ? "Signal disposed"
                                  : "Revert this signal"
                              }
                            >
                              <IconUndo size={10} />
                            </button>
                          </div>
                        </div>
                      );
                    })
                  )}
                </div>
              )}
            </div>
          );
        })}
      </div>
    );
  };

  const renderContent = () => {
    if (!enabled) {
      return (
        <div style={styles.warningBoxStyles}>
          <div style={{ marginBottom: "4px" }}>‚ö†Ô∏è DevTools not enabled</div>
          <div style={{ fontSize: "10px", opacity: 0.8 }}>
            Call{" "}
            <code
              style={{
                backgroundColor: "rgba(0,0,0,0.3)",
                padding: "1px 4px",
                borderRadius: "2px",
              }}
            >
              enableDevTools()
            </code>{" "}
            before creating signals
          </div>
        </div>
      );
    }

    switch (activeTab) {
      case "signals":
        return renderSignals();
      case "tags":
        return renderTags();
      case "events":
        return renderEvents();
      case "chains":
        return renderChains();
      case "graph":
        return renderGraph();
      case "snaps":
        return renderSnapshots();
    }
  };

  // Helper to render signal kind filter buttons
  const renderSignalKindFilters = () => {
    return (
      <>
        {(["all", "mutable", "computed", "error", "disposed"] as const).map(
          (kind) => {
            const isActive = signalKindFilter === kind;
            const label =
              kind === "all"
                ? "A"
                : kind === "mutable"
                ? "M"
                : kind === "computed"
                ? "C"
                : kind === "error"
                ? "E"
                : "D";
            const color =
              kind === "mutable"
                ? styles.colors.mutable
                : kind === "computed"
                ? styles.colors.computed
                : kind === "error"
                ? styles.colors.error
                : kind === "disposed"
                ? "#666"
                : styles.colors.text;
            // For "All" filter, show user-named/total when not showing auto-generated
            const countDisplay =
              kind === "all"
                ? !showAutoGenerated && filteredSignals.length !== signals.size
                  ? `${filteredSignals.length} / ${signals.size}`
                  : `${signals.size}`
                : kind === "mutable"
                ? `${stats.mutableCount}`
                : kind === "computed"
                ? `${stats.computedCount}`
                : kind === "error"
                ? `${stats.signalsWithErrors}`
                : `${stats.disposedCount}`;

            const hasErrors = kind === "error" && stats.signalsWithErrors > 0;

            return (
              <button
                key={kind}
                style={{
                  padding: "3px 8px",
                  fontSize: "10px",
                  fontWeight: 600,
                  backgroundColor:
                    isActive || hasErrors
                      ? color + "33"
                      : styles.colors.bgHover,
                  border: `1px solid ${
                    isActive || hasErrors ? color : styles.colors.border
                  }`,
                  borderRadius: "4px",
                  color:
                    isActive || hasErrors ? color : styles.colors.textMuted,
                  cursor: "pointer",
                  fontFamily: "inherit",
                  display: "flex",
                  alignItems: "center",
                  gap: "4px",
                  ...(hasErrors &&
                    !isActive && {
                      animation: "pulse 2s infinite",
                    }),
                }}
                onClick={() => setSignalKindFilter(kind)}
                title={`Show ${kind} signals`}
              >
                {label}
                <span
                  style={{
                    fontWeight: 400,
                    fontSize: "9px",
                    opacity: 0.8,
                  }}
                >
                  {countDisplay}
                </span>
              </button>
            );
          }
        )}
      </>
    );
  };

  // Helper to render signal option filters (bookmarks, sort, auto toggle)
  const renderSignalOptionFilters = () => {
    return (
      <FilterGroup>
        {/* Bookmark filter toggle */}
        <button
          style={{
            padding: "3px 8px",
            fontSize: "10px",
            backgroundColor: showBookmarksOnly
              ? styles.colors.warning + "33"
              : styles.colors.bgHover,
            border: `1px solid ${
              showBookmarksOnly ? styles.colors.warning : styles.colors.border
            }`,
            borderRadius: "4px",
            color: showBookmarksOnly
              ? styles.colors.warning
              : styles.colors.textMuted,
            cursor: "pointer",
            fontFamily: "inherit",
            display: "flex",
            alignItems: "center",
            gap: "4px",
          }}
          onClick={(e) => {
            e.stopPropagation();
            setShowBookmarksOnly(!showBookmarksOnly);
          }}
          title={
            showBookmarksOnly
              ? "Show all signals"
              : "Show bookmarked signals only"
          }
        >
          <IconStar size={10} filled={showBookmarksOnly} />
          {bookmarkedSignals.size > 0 && (
            <span style={{ fontSize: "9px" }}>{bookmarkedSignals.size}</span>
          )}
        </button>
        {/* Recent activity sort toggle */}
        <button
          style={{
            padding: "3px 8px",
            fontSize: "10px",
            backgroundColor: recentActivitySort
              ? styles.colors.warning + "33"
              : styles.colors.bgHover,
            border: `1px solid ${
              recentActivitySort ? styles.colors.warning : styles.colors.border
            }`,
            borderRadius: "4px",
            color: recentActivitySort
              ? styles.colors.warning
              : styles.colors.textMuted,
            cursor: "pointer",
            fontFamily: "inherit",
            display: "flex",
            alignItems: "center",
            lineHeight: 1,
          }}
          onClick={() => setRecentActivitySort(!recentActivitySort)}
          title={
            recentActivitySort
              ? "Sort by default (active first)"
              : "Sort by recent activity"
          }
        >
          üïê
        </button>

        {/* Auto-generated toggle */}
        <button
          style={{
            padding: "3px 8px",
            fontSize: "10px",
            backgroundColor: flashAutoToggle
              ? styles.colors.warning + "44"
              : showAutoGenerated
              ? styles.colors.accent + "33"
              : styles.colors.bgHover,
            border: `1px solid ${
              flashAutoToggle
                ? styles.colors.warning
                : showAutoGenerated
                ? styles.colors.accent
                : styles.colors.border
            }`,
            borderRadius: "4px",
            color: flashAutoToggle
              ? styles.colors.warning
              : showAutoGenerated
              ? styles.colors.accent
              : styles.colors.textMuted,
            cursor: "pointer",
            fontFamily: "inherit",
            transition: "all 0.3s ease",
            animation: flashAutoToggle
              ? "pulse-warning 0.5s ease-in-out infinite"
              : "none",
            boxShadow: flashAutoToggle
              ? `0 0 8px ${styles.colors.warning}66`
              : "none",
          }}
          onClick={() => {
            updateShowAutoGenerated(!showAutoGenerated);
            if (flashAutoToggle) {
              setFlashAutoToggle(false);
              if (autoToggleFlashTimeoutRef.current) {
                clearTimeout(autoToggleFlashTimeoutRef.current);
                autoToggleFlashTimeoutRef.current = null;
              }
            }
          }}
          title={
            flashAutoToggle
              ? "New auto-generated signals created! Click to show."
              : showAutoGenerated
              ? "Click to hide auto-generated signals"
              : "Click to show auto-generated signals"
          }
        >
          #auto{" "}
          <span style={{ fontWeight: 400, opacity: 0.8 }}>
            {autoGeneratedCount}
          </span>
        </button>
      </FilterGroup>
    );
  };

  // Helper to render event kind filter buttons
  const renderEventKindFilters = () => {
    return (
      <>
        {(["all", "error", "update", "create", "dispose"] as const).map(
          (kind) => {
            const isActive = eventKindFilter === kind;
            const label =
              kind === "all"
                ? "A"
                : kind === "error"
                ? "E"
                : kind === "update"
                ? "U"
                : kind === "create"
                ? "C"
                : "D";
            const color =
              kind === "error"
                ? styles.colors.error
                : kind === "update"
                ? styles.colors.warning
                : kind === "create"
                ? styles.colors.success
                : kind === "dispose"
                ? "#666"
                : styles.colors.text;
            const count =
              kind === "all"
                ? events.length
                : kind === "error"
                ? events.filter((e) => e.isError || e.type === "signal:error")
                    .length
                : kind === "update"
                ? events.filter((e) => e.type === "signal:change").length
                : kind === "create"
                ? events.filter(
                    (e) => e.type === "signal:create" || e.type === "tag:create"
                  ).length
                : events.filter((e) => e.type === "signal:dispose").length;

            const hasErrors =
              kind === "error" &&
              events.some((e) => e.isError || e.type === "signal:error");

            return (
              <button
                key={kind}
                style={{
                  padding: "3px 8px",
                  fontSize: "10px",
                  fontWeight: 600,
                  backgroundColor:
                    isActive || hasErrors
                      ? color + "33"
                      : styles.colors.bgHover,
                  border: `1px solid ${
                    isActive || hasErrors ? color : styles.colors.border
                  }`,
                  borderRadius: "4px",
                  color:
                    isActive || hasErrors ? color : styles.colors.textMuted,
                  cursor: "pointer",
                  fontFamily: "inherit",
                  display: "flex",
                  alignItems: "center",
                  gap: "4px",
                  ...(hasErrors &&
                    !isActive && {
                      animation: "pulse 2s infinite",
                    }),
                }}
                onClick={() => setEventKindFilter(kind)}
                title={`Show ${kind} events`}
              >
                {label}
                <span
                  style={{
                    fontWeight: 400,
                    fontSize: "9px",
                    opacity: 0.8,
                  }}
                >
                  {count}
                </span>
              </button>
            );
          }
        )}
      </>
    );
  };

  const renderTabLabel = (tab: Tab) => {
    return tab.charAt(0).toUpperCase() + tab.slice(1);
  };

  const isLeftCollapsed = position === "left" && !isExpanded;
  const currentSize = position === "bottom" ? sizeBottom : sizeLeft;

  return (
    <>
      {/* Keyframes for pulse animation */}
      <style>
        {`
          @keyframes pulse-warning {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.05); }
          }
        `}
      </style>
      <div style={styles.panelContainerStyles(position)}>
        <div
          ref={panelRef}
          style={{
            ...styles.panelStyles(
              isExpanded,
              position,
              currentSize ?? undefined,
              isResizing
            ),
            position: "relative",
          }}
        >
          {/* Resize handle - only show when expanded */}
          {isExpanded && (
            <div
              style={styles.resizeHandleStyles(position, isResizing)}
              onMouseDown={handleResizeStart}
              onTouchStart={handleResizeStart}
            >
              <div style={styles.resizeHandleGripStyles(position)} />
            </div>
          )}

          {/* Header - clickable to toggle */}
          <div
            style={styles.headerStyles(position, isExpanded)}
            onClick={togglePanel}
          >
            <h3 style={styles.titleStyles(isLeftCollapsed)}>
              <span style={{ color: "#fbbf24" }}>
                <IconBolt size={18} />
              </span>
              {!isLeftCollapsed && <span>Rextive Devtools</span>}
            </h3>

            <div
              style={{
                ...styles.headerRightStyles,
                flexDirection: isLeftCollapsed ? "column" : "row",
              }}
            >
              {/* Settings button */}
              {!isLeftCollapsed && (
                <button
                  style={styles.positionButtonStyles}
                  onClick={(e) => {
                    e.stopPropagation();
                    setIsConfigModalOpen(true);
                  }}
                  title="DevTools settings"
                >
                  <IconSettings size={14} />
                </button>
              )}

              {/* Reset config button */}
              {!isLeftCollapsed && (
                <button
                  style={styles.positionButtonStyles}
                  onClick={(e) => {
                    e.stopPropagation();
                    resetConfig();
                  }}
                  title="Reset DevTools settings"
                >
                  <IconReset size={14} />
                </button>
              )}

              {/* Position toggle - hidden in mobile mode */}
              {!isMobile && (
                <button
                  style={styles.positionButtonStyles}
                  onClick={(e) => {
                    e.stopPropagation();
                    togglePosition();
                  }}
                  title={
                    position === "bottom" ? "Move to left" : "Move to bottom"
                  }
                >
                  {position === "bottom" ? (
                    <IconArrowLeft />
                  ) : (
                    <IconArrowDown />
                  )}
                </button>
              )}

              {/* Expand/Collapse toggle */}
              <button
                style={styles.toggleButtonStyles}
                onClick={(e) => {
                  e.stopPropagation();
                  togglePanel();
                }}
                title={isExpanded ? "Collapse" : "Expand"}
              >
                {position === "bottom" ? (
                  isExpanded ? (
                    <IconChevronDown />
                  ) : (
                    <IconChevronUp />
                  )
                ) : isExpanded ? (
                  <IconChevronLeft />
                ) : (
                  <IconChevronRight />
                )}
              </button>
            </div>
          </div>

          {/* Tabs + Content (only when expanded) */}
          {isExpanded && (
            <>
              <TabBar
                tabs={(
                  [
                    "signals",
                    "snaps",
                    "tags",
                    "events",
                    "chains",
                    "graph",
                  ] as Tab[]
                ).map((tab) => ({
                  id: tab,
                  label: renderTabLabel(tab),
                }))}
                activeTab={activeTab}
                onTabChange={(tabId) => updateActiveTab(tabId as Tab)}
                flashingTabs={flashingTabs}
              />

              {/* Tab content with search, filters, and main content */}
              <TabContent
                searchBox={
                  activeTab === "graph"
                    ? {
                        value: graphSearchQuery,
                        onChange: setGraphSearchQuery,
                        placeholder: "Search nodes...",
                        showHelp: false,
                        leftActions: undefined,
                      }
                    : activeTab === "chains"
                    ? {
                        value: chainFilter,
                        onChange: setChainFilter,
                        placeholder: "Filter by signal name...",
                        showHelp: false,
                        leftActions: undefined,
                      }
                    : activeTab === "snaps"
                    ? {
                        value: snapshotSearch,
                        onChange: setSnapshotSearch,
                        placeholder: "Search snapshots...",
                        showHelp: false,
                        leftActions: undefined,
                      }
                    : {
                        value: searchQuery,
                        onChange: setSearchQuery,
                        placeholder: getSearchPlaceholder(activeTab),
                        showHelp: true,
                        onHelpClick: () => setShowSearchHelp(true),
                      }
                }
                filterBar={
                  activeTab === "signals" ? (
                    <>
                      {renderSignalKindFilters()}
                      {renderSignalOptionFilters()}
                    </>
                  ) : activeTab === "events" ? (
                    <>
                      {renderEventKindFilters()}
                      <FilterSeparator />
                      <button
                        style={{
                          padding: "3px 8px",
                          fontSize: "10px",
                          backgroundColor: styles.colors.bgHover,
                          border: `1px solid ${styles.colors.border}`,
                          borderRadius: "4px",
                          color: styles.colors.textMuted,
                          cursor:
                            events.length === 0 ? "not-allowed" : "pointer",
                          opacity: events.length === 0 ? 0.5 : 1,
                          fontFamily: "inherit",
                        }}
                        onClick={clearEvents}
                        disabled={events.length === 0}
                        title="Clear all events"
                      >
                        Clear
                      </button>
                    </>
                  ) : activeTab === "snaps" ? (
                    <>
                      {/* Take Snap button */}
                      <button
                        style={{
                          padding: "3px 8px",
                          fontSize: "10px",
                          backgroundColor: styles.colors.error + "22",
                          border: `1px solid ${styles.colors.error}`,
                          borderRadius: "4px",
                          color: styles.colors.error,
                          cursor:
                            snapshotBookmarkedOnly &&
                            bookmarkedSignals.size === 0
                              ? "not-allowed"
                              : "pointer",
                          opacity:
                            snapshotBookmarkedOnly &&
                            bookmarkedSignals.size === 0
                              ? 0.5
                              : 1,
                          fontFamily: "inherit",
                          display: "flex",
                          alignItems: "center",
                          gap: "4px",
                        }}
                        onClick={() => takeSnapshot()}
                        disabled={
                          snapshotBookmarkedOnly && bookmarkedSignals.size === 0
                        }
                        title={
                          snapshotBookmarkedOnly
                            ? bookmarkedSignals.size === 0
                              ? "No bookmarked signals"
                              : `Take snapshot of ${bookmarkedSignals.size} bookmarked signal(s)`
                            : "Take snapshot of all mutable signals"
                        }
                      >
                        <IconRecord size={10} />
                      </button>
                      {/* Bookmarked only toggle */}
                      <button
                        style={{
                          padding: "3px 8px",
                          fontSize: "10px",
                          backgroundColor: snapshotBookmarkedOnly
                            ? styles.colors.warning + "33"
                            : styles.colors.bgHover,
                          border: `1px solid ${
                            snapshotBookmarkedOnly
                              ? styles.colors.warning
                              : styles.colors.border
                          }`,
                          borderRadius: "4px",
                          color: snapshotBookmarkedOnly
                            ? styles.colors.warning
                            : styles.colors.textMuted,
                          cursor: "pointer",
                          fontFamily: "inherit",
                          display: "flex",
                          alignItems: "center",
                          gap: "4px",
                        }}
                        onClick={() =>
                          updateSnapshotBookmarkedOnly(!snapshotBookmarkedOnly)
                        }
                        title={
                          snapshotBookmarkedOnly
                            ? "Click to snapshot all signals"
                            : "Click to snapshot bookmarked only"
                        }
                      >
                        <IconStar size={10} filled={snapshotBookmarkedOnly} />
                        {bookmarkedSignals.size > 0 && (
                          <span style={{ fontSize: "9px" }}>
                            {bookmarkedSignals.size}
                          </span>
                        )}
                      </button>
                      <FilterGroup>
                        {/* Diff button */}
                        <button
                          style={{
                            padding: "3px 8px",
                            fontSize: "10px",
                            backgroundColor:
                              snapshots.length < 2
                                ? styles.colors.bgHover
                                : styles.colors.computed + "22",
                            border: `1px solid ${
                              snapshots.length < 2
                                ? styles.colors.border
                                : styles.colors.computed
                            }`,
                            borderRadius: "4px",
                            color:
                              snapshots.length < 2
                                ? styles.colors.textMuted
                                : styles.colors.computed,
                            cursor:
                              snapshots.length < 2 ? "not-allowed" : "pointer",
                            opacity: snapshots.length < 2 ? 0.5 : 1,
                            fontFamily: "inherit",
                          }}
                          onClick={() => setSnapshotDiffOpen(true)}
                          disabled={snapshots.length < 2}
                          title={
                            snapshots.length < 2
                              ? "Need at least 2 snapshots to compare"
                              : "Compare two snapshots"
                          }
                        >
                          <IconCompare size={10} /> Diff
                        </button>
                      </FilterGroup>
                      <FilterGroup>
                        {/* Snapshot on init toggle */}
                        <button
                          style={{
                            padding: "3px 8px",
                            fontSize: "10px",
                            backgroundColor: snapshotOnInit
                              ? styles.colors.accent + "33"
                              : styles.colors.bgHover,
                            border: `1px solid ${
                              snapshotOnInit
                                ? styles.colors.accent
                                : styles.colors.border
                            }`,
                            borderRadius: "4px",
                            color: snapshotOnInit
                              ? styles.colors.accent
                              : styles.colors.textMuted,
                            cursor: "pointer",
                            fontFamily: "inherit",
                          }}
                          onClick={() => updateSnapshotOnInit(!snapshotOnInit)}
                          title="Take snapshot when DevTools loads"
                        >
                          On Init
                        </button>
                        {/* Auto interval toggle */}
                        <button
                          style={{
                            padding: "3px 8px",
                            fontSize: "10px",
                            backgroundColor: snapshotAutoInterval
                              ? styles.colors.accent + "33"
                              : styles.colors.bgHover,
                            border: `1px solid ${
                              snapshotAutoInterval
                                ? styles.colors.accent
                                : styles.colors.border
                            }`,
                            borderRadius: "4px",
                            color: snapshotAutoInterval
                              ? styles.colors.accent
                              : styles.colors.textMuted,
                            cursor: "pointer",
                            fontFamily: "inherit",
                          }}
                          onClick={() =>
                            updateSnapshotAutoInterval(!snapshotAutoInterval)
                          }
                          title={`Auto snapshot every ${autoSnapshotIntervalSeconds} seconds`}
                        >
                          Auto {autoSnapshotIntervalSeconds}s
                        </button>
                      </FilterGroup>
                    </>
                  ) : undefined
                }
                actionBar={
                  activeTab === "snaps" && snapshots.length > 0 ? (
                    <button
                      style={{
                        padding: "4px 10px",
                        fontSize: "10px",
                        backgroundColor: styles.colors.bgHover,
                        border: `1px solid ${styles.colors.border}`,
                        borderRadius: "4px",
                        color: styles.colors.textMuted,
                        cursor: "pointer",
                        fontFamily: "inherit",
                        display: "flex",
                        alignItems: "center",
                        gap: "4px",
                      }}
                      onClick={clearAllSnapshots}
                      title="Clear all snapshots"
                    >
                      <IconTrash size={12} /> Clear All
                    </button>
                  ) : activeTab === "graph" ? (
                    <>
                      <button
                        style={{
                          padding: "4px 10px",
                          fontSize: "10px",
                          backgroundColor: styles.colors.bgHover,
                          border: `1px solid ${styles.colors.border}`,
                          borderRadius: "4px",
                          color: styles.colors.text,
                          cursor: "pointer",
                          fontFamily: "inherit",
                        }}
                        onClick={handleGraphExpandAll}
                        title="Expand all nodes"
                      >
                        Expand All
                      </button>
                      <button
                        style={{
                          padding: "4px 10px",
                          fontSize: "10px",
                          backgroundColor: styles.colors.bgHover,
                          border: `1px solid ${styles.colors.border}`,
                          borderRadius: "4px",
                          color: styles.colors.text,
                          cursor: "pointer",
                          fontFamily: "inherit",
                        }}
                        onClick={handleGraphCollapseAll}
                        title="Collapse all nodes"
                      >
                        Collapse All
                      </button>
                      {stats.disposedCount > 0 && (
                        <button
                          style={{
                            padding: "4px 10px",
                            fontSize: "10px",
                            backgroundColor: "#66666633",
                            border: `1px solid #666`,
                            borderRadius: "4px",
                            color: "#888",
                            cursor: "pointer",
                            fontFamily: "inherit",
                            display: "flex",
                            alignItems: "center",
                            gap: "4px",
                            whiteSpace: "nowrap",
                          }}
                          onClick={(e) => {
                            e.stopPropagation();
                            clearDisposed();
                          }}
                          title={`Clear all ${
                            stats.disposedCount
                          } disposed signal${
                            stats.disposedCount !== 1 ? "s" : ""
                          }`}
                        >
                          <IconTrash size={12} /> Remove Disposed (
                          {stats.disposedCount})
                        </button>
                      )}
                    </>
                  ) : activeTab === "signals" &&
                    signalKindFilter === "disposed" &&
                    stats.disposedCount > 0 ? (
                    <button
                      style={{
                        padding: "4px 10px",
                        fontSize: "10px",
                        backgroundColor: "#66666633",
                        border: `1px solid #666`,
                        borderRadius: "4px",
                        color: "#888",
                        cursor: "pointer",
                        fontFamily: "inherit",
                        display: "flex",
                        alignItems: "center",
                        gap: "4px",
                        whiteSpace: "nowrap",
                      }}
                      onClick={(e) => {
                        e.stopPropagation();
                        clearDisposed();
                      }}
                      title={`Clear all ${stats.disposedCount} disposed signal${
                        stats.disposedCount !== 1 ? "s" : ""
                      }`}
                    >
                      <IconTrash size={12} /> Clear All Disposed (
                      {stats.disposedCount})
                    </button>
                  ) : undefined
                }
              >
                {renderContent()}
              </TabContent>
            </>
          )}
        </div>
        <SearchHelpModal
          isOpen={showSearchHelp}
          onClose={() => setShowSearchHelp(false)}
        />
        {compareModal && (
          <ValueDiffModal
            isOpen={!!compareModal}
            onClose={() => setCompareModal(null)}
            signalName={
              signals.get(compareModal.signalId)?.name || compareModal.signalId
            }
            currentValue={compareModal.currentValue}
            historyValue={compareModal.historyValue}
            historyTimestamp={compareModal.historyTimestamp}
            formatTime={formatTime}
          />
        )}
        <SnapshotDiffModal
          isOpen={snapshotDiffOpen}
          onClose={() => {
            setSnapshotDiffOpen(false);
            setSnapshotDiff1Id(null);
            setSnapshotDiff2Id(null);
          }}
          snapshots={snapshots}
          snapshot1Id={snapshotDiff1Id}
          snapshot2Id={snapshotDiff2Id}
          onSelectSnapshot1={setSnapshotDiff1Id}
          onSelectSnapshot2={setSnapshotDiff2Id}
          currentStateSignals={getCurrentStateSignals()}
        />
        <ConfigModal
          isOpen={isConfigModalOpen}
          onClose={() => setIsConfigModalOpen(false)}
          settings={{
            autoRemoveDisposedTimer,
            autoSnapshotInterval: autoSnapshotIntervalSeconds,
            signalHistoryLimit,
          }}
          onSettingsChange={handleSettingsChange}
        />
      </div>
    </>
  );
}
