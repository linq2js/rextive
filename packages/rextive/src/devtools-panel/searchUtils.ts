/**
 * Advanced search utilities for DevTools
 */

export type SearchField = "name" | "value" | "file" | "tag" | "kind" | "error" | "disposed";

export type SearchQuery = {
  /** Raw query string */
  raw: string;
  /** Field-specific filters */
  fields: Map<SearchField, string | RegExp>;
  /** Default search (when no field prefix) */
  defaultQuery?: string | RegExp;
  /** Whether to include auto-generated names */
  includeAutoGenerated: boolean;
  /** Whether query is a regex pattern */
  isRegex: boolean;
};

/**
 * Parse search query into structured format
 */
export function parseSearchQuery(query: string): SearchQuery {
  const trimmed = query.trim();
  const lower = trimmed.toLowerCase();

  // Check for auto-generated override
  const includeAutoGenerated = lower.startsWith("#");
  const queryWithoutHash = includeAutoGenerated ? trimmed.slice(1) : trimmed;

  // Check for regex pattern (wrapped in /.../)
  const regexMatch = queryWithoutHash.match(/^\/(.+)\/([gimuy]*)$/);
  const isRegex = !!regexMatch;

  const fields = new Map<SearchField, string | RegExp>();
  let defaultQuery: string | RegExp | undefined;

  if (regexMatch) {
    // Regex pattern
    try {
      const pattern = regexMatch[1];
      const flags = regexMatch[2] || "i"; // Default to case-insensitive
      const regex = new RegExp(pattern, flags);
      defaultQuery = regex;
    } catch {
      // Invalid regex, treat as plain text
      defaultQuery = queryWithoutHash;
    }
  } else {
    // Parse field-specific queries
    const fieldPattern = /(\w+):([^\s]+)/g;
    let match;
    let lastIndex = 0;
    const defaultParts: string[] = [];

    while ((match = fieldPattern.exec(queryWithoutHash)) !== null) {
      const field = match[1].toLowerCase() as SearchField;
      const value = match[2];

      // Check if it's a valid field
      if (
        field === "name" ||
        field === "value" ||
        field === "file" ||
        field === "tag" ||
        field === "kind" ||
        field === "error" ||
        field === "disposed"
      ) {
        // Handle boolean fields
        if (field === "error" || field === "disposed") {
          const boolValue = value.toLowerCase() === "true" || value === "1";
          fields.set(field, boolValue ? "true" : "false");
        } else {
          fields.set(field, value);
        }
      } else {
        // Not a valid field, treat as part of default query
        defaultParts.push(match[0]);
      }

      lastIndex = fieldPattern.lastIndex;
    }

    // Collect remaining text as default query
    if (lastIndex < queryWithoutHash.length) {
      defaultParts.push(queryWithoutHash.slice(lastIndex).trim());
    }

    // If we have field filters but no default query, use empty string
    // If we have no field filters, use the whole query as default
    if (fields.size === 0 && queryWithoutHash) {
      defaultQuery = queryWithoutHash;
    } else if (defaultParts.length > 0) {
      defaultQuery = defaultParts.join(" ").trim();
    }
  }

  return {
    raw: query,
    fields,
    defaultQuery,
    includeAutoGenerated,
    isRegex,
  };
}

/**
 * Test if a string matches a query (string or regex)
 */
function matchesQuery(text: string, query: string | RegExp | undefined): boolean {
  if (!query) return true;
  if (query instanceof RegExp) {
    return query.test(text);
  }
  return text.toLowerCase().includes(query.toLowerCase());
}

/**
 * Stringify a value for searching
 */
function stringifyValue(value: unknown): string {
  if (value === null) return "null";
  if (value === undefined) return "undefined";
  if (typeof value === "string") return value;
  if (typeof value === "number" || typeof value === "boolean") return String(value);
  if (typeof value === "object") {
    try {
      return JSON.stringify(value);
    } catch {
      return String(value);
    }
  }
  return String(value);
}

/**
 * Check if a signal matches the search query
 */
export function matchesSignalSearch(
  signal: {
    name: string;
    id: string;
    kind: "mutable" | "computed";
    signal: { get: () => unknown };
    source?: { file: string; line?: number; column?: number };
    tags: Set<string>;
    errorCount: number;
    disposed: boolean;
  },
  query: SearchQuery,
  isAutoGenerated: (name: string) => boolean,
  showAutoGenerated: boolean = false
): boolean {
  // Auto-generated filter: combine UI toggle with search query override
  const effectiveShowAutoGenerated = showAutoGenerated || query.includeAutoGenerated;
  if (!effectiveShowAutoGenerated && isAutoGenerated(signal.name)) {
    return false;
  }

  // Field-specific filters
  for (const [field, value] of query.fields.entries()) {
    switch (field) {
      case "name":
        if (!matchesQuery(signal.name, value)) return false;
        break;
      case "value": {
        try {
          const signalValue = signal.signal.get();
          const valueStr = stringifyValue(signalValue);
          if (!matchesQuery(valueStr, value)) return false;
        } catch {
          // Signal is in error state or disposed, skip value matching
          return false;
        }
        break;
      }
      case "file":
        if (!signal.source?.file) return false;
        if (!matchesQuery(signal.source.file, value)) return false;
        break;
      case "tag":
        let tagMatch = false;
        for (const tag of signal.tags) {
          if (matchesQuery(tag, value)) {
            tagMatch = true;
            break;
          }
        }
        if (!tagMatch) return false;
        break;
      case "kind":
        const kindValue = typeof value === "string" ? value.toLowerCase() : "";
        if (kindValue !== signal.kind) return false;
        break;
      case "error":
        const hasError = signal.errorCount > 0;
        const wantError = value === "true";
        if (hasError !== wantError) return false;
        break;
      case "disposed":
        const isDisposed = signal.disposed;
        const wantDisposed = value === "true";
        if (isDisposed !== wantDisposed) return false;
        break;
    }
  }

  // Default query (search across name, value, file)
  if (query.defaultQuery) {
    const nameMatch = matchesQuery(signal.name, query.defaultQuery);
    const fileMatch = signal.source?.file
      ? matchesQuery(signal.source.file, query.defaultQuery)
      : false;

    // Value search (only if not already filtered by value field)
    let valueMatch = false;
    if (!query.fields.has("value")) {
      try {
        const signalValue = signal.signal.get();
        const valueStr = stringifyValue(signalValue);
        valueMatch = matchesQuery(valueStr, query.defaultQuery);
      } catch {
        // Ignore errors when getting value
      }
    }

    if (!nameMatch && !fileMatch && !valueMatch) {
      return false;
    }
  }

  return true;
}

/**
 * Check if a tag matches the search query
 */
export function matchesTagSearch(
  tag: {
    id: string;
  },
  query: SearchQuery,
  isAutoGenerated: (name: string) => boolean,
  showAutoGenerated: boolean = false
): boolean {
  // Auto-generated filter: combine UI toggle with search query override
  const effectiveShowAutoGenerated = showAutoGenerated || query.includeAutoGenerated;
  if (!effectiveShowAutoGenerated && isAutoGenerated(tag.id)) {
    return false;
  }

  // Field-specific filters (only name applies to tags)
  for (const [field, value] of query.fields.entries()) {
    if (field === "name" || field === "tag") {
      if (!matchesQuery(tag.id, value)) return false;
    } else if (field !== "kind" && field !== "error" && field !== "disposed") {
      // Other fields don't apply to tags
      return false;
    }
  }

  // Default query
  if (query.defaultQuery) {
    if (!matchesQuery(tag.id, query.defaultQuery)) {
      return false;
    }
  }

  return true;
}

/**
 * Check if an event matches the search query
 */
export function matchesEventSearch(
  event: {
    type: string;
    signalId?: string;
    tagId?: string;
    value?: unknown;
  },
  query: SearchQuery,
  getSignalName: (id: string) => string | undefined
): boolean {
  // Field-specific filters
  for (const [field, value] of query.fields.entries()) {
    switch (field) {
      case "name":
        if (event.signalId) {
          const signalName = getSignalName(event.signalId) || event.signalId;
          if (!matchesQuery(signalName, value)) return false;
        } else if (event.tagId) {
          if (!matchesQuery(event.tagId, value)) return false;
        } else {
          return false;
        }
        break;
      case "value":
        if (event.value !== undefined) {
          const valueStr = stringifyValue(event.value);
          if (!matchesQuery(valueStr, value)) return false;
        } else {
          return false;
        }
        break;
      case "tag":
        if (event.tagId) {
          if (!matchesQuery(event.tagId, value)) return false;
        } else {
          return false;
        }
        break;
      case "kind":
        // Event type matching
        const kindValue = typeof value === "string" ? value.toLowerCase() : "";
        const eventType = event.type.toLowerCase();
        if (!eventType.includes(kindValue)) return false;
        break;
      // error and disposed don't apply to events in the same way
    }
  }

  // Default query
  if (query.defaultQuery) {
    const typeMatch = matchesQuery(event.type, query.defaultQuery);
    let idMatch = false;
    if (event.signalId) {
      const signalName = getSignalName(event.signalId) || event.signalId;
      idMatch = matchesQuery(signalName, query.defaultQuery);
    }
    if (event.tagId) {
      idMatch = idMatch || matchesQuery(event.tagId, query.defaultQuery);
    }
    if (event.value !== undefined) {
      const valueStr = stringifyValue(event.value);
      idMatch = idMatch || matchesQuery(valueStr, query.defaultQuery);
    }

    if (!typeMatch && !idMatch) {
      return false;
    }
  }

  return true;
}

/**
 * Get search query placeholder text
 */
export function getSearchPlaceholder(activeTab: string): string {
  return `Search ${activeTab}...`;
}

