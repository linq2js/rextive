/**
 * UI State Hook
 * Manages UI-related state like expanded items, search, editing, filters
 */

import { useState, useCallback, useMemo } from "react";
import type { SignalInfo } from "../../devtools/types";
import type { CompareModalState, SignalKindFilter, EventKindFilter, Tab, EventLogEntry } from "../types";
import { loadBookmarks, saveBookmarks } from "../config";
import {
  parseSearchQuery,
  matchesSignalSearch,
  matchesEventSearch,
  getSearchPlaceholder,
} from "../searchUtils";
import { isAutoGeneratedName } from "../../utils/nameGenerator";

export interface UIState {
  // Signal UI
  expandedSignal: string | null;
  hoveredItem: string | null;
  editingSignal: string | null;
  editValue: string;
  editError: string | null;
  bookmarkedSignals: Set<string>;
  showBookmarksOnly: boolean;
  signalKindFilter: SignalKindFilter;
  recentActivitySort: boolean;
  
  // Event UI
  expandedEvents: Set<number>;
  eventKindFilter: EventKindFilter;
  
  // Tag UI
  expandedTag: string | null;
  
  // Search
  searchQuery: string;
  showSearchHelp: boolean;
  parsedQuery: ReturnType<typeof parseSearchQuery>;
  
  // Chain UI
  expandedChain: string | null;
  chainFilter: string;
  
  // Modals
  compareModal: CompareModalState | null;
}

export interface UIStateActions {
  // Signal UI
  setExpandedSignal: (id: string | null) => void;
  setHoveredItem: (id: string | null) => void;
  setEditingSignal: (id: string | null) => void;
  setEditValue: (value: string) => void;
  setEditError: (error: string | null) => void;
  toggleBookmark: (signalId: string) => void;
  setShowBookmarksOnly: (show: boolean) => void;
  setSignalKindFilter: (filter: SignalKindFilter) => void;
  setRecentActivitySort: (sort: boolean) => void;
  
  // Event UI
  setExpandedEvents: React.Dispatch<React.SetStateAction<Set<number>>>;
  setEventKindFilter: (filter: EventKindFilter) => void;
  
  // Tag UI
  setExpandedTag: (id: string | null) => void;
  
  // Search
  setSearchQuery: (query: string) => void;
  setShowSearchHelp: (show: boolean) => void;
  
  // Chain UI
  setExpandedChain: (id: string | null) => void;
  setChainFilter: (filter: string) => void;
  
  // Modals
  setCompareModal: (modal: CompareModalState | null) => void;
  
  // Helpers
  getSearchBoxProps: (activeTab: Tab, snapshotSearch: string, setSnapshotSearch: (s: string) => void) => {
    value: string;
    onChange: (value: string) => void;
    placeholder: string;
    showHelp: boolean;
    onHelpClick?: () => void;
    leftActions?: React.ReactNode;
  };
  filterSignals: (signals: Map<string, SignalInfo>, showAutoGenerated: boolean) => SignalInfo[];
  filterEvents: (events: EventLogEntry[], signals: Map<string, SignalInfo>) => EventLogEntry[];
}

export function useUIState(): [UIState, UIStateActions] {
  // Signal UI
  const [expandedSignal, setExpandedSignal] = useState<string | null>(null);
  const [hoveredItem, setHoveredItem] = useState<string | null>(null);
  const [editingSignal, setEditingSignal] = useState<string | null>(null);
  const [editValue, setEditValue] = useState("");
  const [editError, setEditError] = useState<string | null>(null);
  const [bookmarkedSignals, setBookmarkedSignals] = useState<Set<string>>(() => loadBookmarks());
  const [showBookmarksOnly, setShowBookmarksOnly] = useState(false);
  const [signalKindFilter, setSignalKindFilter] = useState<SignalKindFilter>("all");
  const [recentActivitySort, setRecentActivitySort] = useState(true);
  
  // Event UI
  const [expandedEvents, setExpandedEvents] = useState<Set<number>>(new Set());
  const [eventKindFilter, setEventKindFilter] = useState<EventKindFilter>("all");
  
  // Tag UI
  const [expandedTag, setExpandedTag] = useState<string | null>(null);
  
  // Search
  const [searchQuery, setSearchQuery] = useState("");
  const [showSearchHelp, setShowSearchHelp] = useState(false);
  
  // Chain UI
  const [expandedChain, setExpandedChain] = useState<string | null>(null);
  const [chainFilter, setChainFilter] = useState("");
  
  // Modals
  const [compareModal, setCompareModal] = useState<CompareModalState | null>(null);

  // Parse search query
  const parsedQuery = useMemo(() => parseSearchQuery(searchQuery), [searchQuery]);

  // Toggle bookmark
  const toggleBookmark = useCallback((signalId: string) => {
    setBookmarkedSignals((prev) => {
      const next = new Set(prev);
      if (next.has(signalId)) {
        next.delete(signalId);
      } else {
        next.add(signalId);
      }
      saveBookmarks(next);
      return next;
    });
  }, []);

  // Search help click handler
  const handleSearchHelpClick = useCallback(() => setShowSearchHelp(true), []);

  // Get search box props based on active tab
  const getSearchBoxProps = useCallback((
    activeTab: Tab,
    snapshotSearch: string,
    setSnapshotSearch: (s: string) => void
  ) => {
    if (activeTab === "chains") {
      return {
        value: chainFilter,
        onChange: setChainFilter,
        placeholder: "Filter by signal name...",
        showHelp: false,
        leftActions: undefined,
      };
    }
    if (activeTab === "snaps") {
      return {
        value: snapshotSearch,
        onChange: setSnapshotSearch,
        placeholder: "Search snapshots...",
        showHelp: false,
        leftActions: undefined,
      };
    }
    return {
      value: searchQuery,
      onChange: setSearchQuery,
      placeholder: getSearchPlaceholder(activeTab),
      showHelp: true,
      onHelpClick: handleSearchHelpClick,
    };
  }, [chainFilter, searchQuery, handleSearchHelpClick]);

  // Filter signals based on current filters and search
  const filterSignals = useCallback((
    signals: Map<string, SignalInfo>,
    showAutoGenerated: boolean
  ): SignalInfo[] => {
    return Array.from(signals.values()).filter((s) => {
      if (showBookmarksOnly && !bookmarkedSignals.has(s.id)) {
        return false;
      }
      if (
        !parsedQuery.fields.has("kind") &&
        !parsedQuery.fields.has("error") &&
        !parsedQuery.fields.has("disposed")
      ) {
        if (signalKindFilter === "error") {
          if (s.errorCount === 0) return false;
        } else if (signalKindFilter === "disposed") {
          if (!s.disposed) return false;
        } else if (signalKindFilter !== "all" && s.kind !== signalKindFilter) {
          return false;
        }
      }

      return matchesSignalSearch(
        {
          name: s.name,
          id: s.id,
          kind: s.kind,
          signal: s.signal,
          source: s.source,
          tags: s.tags,
          errorCount: s.errorCount,
          disposed: s.disposed,
        },
        parsedQuery,
        isAutoGeneratedName,
        showAutoGenerated
      );
    });
  }, [showBookmarksOnly, bookmarkedSignals, signalKindFilter, parsedQuery]);

  // Filter events based on current filters and search
  const filterEvents = useCallback((
    events: EventLogEntry[],
    signals: Map<string, SignalInfo>
  ): EventLogEntry[] => {
    return events.filter((e) => {
      if (!parsedQuery.fields.has("kind")) {
        if (eventKindFilter === "error") {
          if (!(e.isError || e.type === "signal:error")) return false;
        } else if (eventKindFilter === "update") {
          if (e.type !== "signal:change") return false;
        } else if (eventKindFilter === "create") {
          if (e.type !== "signal:create" && e.type !== "tag:create")
            return false;
        } else if (eventKindFilter === "dispose") {
          if (e.type !== "signal:dispose") return false;
        }
      }

      const signalId = "signalId" in e ? String(e.signalId) : undefined;
      const tagId = "tagId" in e ? String(e.tagId) : undefined;
      const value = "value" in e ? e.value : undefined;

      return matchesEventSearch(
        {
          type: e.type,
          signalId,
          tagId,
          value,
        },
        parsedQuery,
        (id) => signals.get(id)?.name
      );
    });
  }, [eventKindFilter, parsedQuery]);

  const state: UIState = {
    expandedSignal,
    hoveredItem,
    editingSignal,
    editValue,
    editError,
    bookmarkedSignals,
    showBookmarksOnly,
    signalKindFilter,
    recentActivitySort,
    expandedEvents,
    eventKindFilter,
    expandedTag,
    searchQuery,
    showSearchHelp,
    parsedQuery,
    expandedChain,
    chainFilter,
    compareModal,
  };

  const actions: UIStateActions = {
    setExpandedSignal,
    setHoveredItem,
    setEditingSignal,
    setEditValue,
    setEditError,
    toggleBookmark,
    setShowBookmarksOnly,
    setSignalKindFilter,
    setRecentActivitySort,
    setExpandedEvents,
    setEventKindFilter,
    setExpandedTag,
    setSearchQuery,
    setShowSearchHelp,
    setExpandedChain,
    setChainFilter,
    setCompareModal,
    getSearchBoxProps,
    filterSignals,
    filterEvents,
  };

  return [state, actions];
}

