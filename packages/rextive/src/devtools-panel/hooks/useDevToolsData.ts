/**
 * DevTools Data Hook
 * Manages signals, tags, events, and stats data
 */

import { useState, useEffect, useCallback, useRef } from "react";
import type { SignalInfo, TagInfo, ChainReaction } from "../../devtools/types";
import type { EventLogEntry, Tab } from "../types";
import {
  isDevToolsEnabled,
  getSignals,
  getTags,
  getStats,
  onDevToolsEvent,
  deleteSignal as deleteSignalApi,
  enableChainTracking,
  disableChainTracking,
  getChainsList,
} from "../../devtools";
import { isAutoGeneratedName } from "../../utils/nameGenerator";

interface UseDevToolsDataOptions {
  showAutoGeneratedRef: React.RefObject<boolean>;
  autoRemoveDisposedTimer: number;
  activeTab: Tab;
  flashSignal: (signalId: string, type: "change" | "create") => void;
  flashTab: (tab: Tab) => void;
  setFlashAutoToggle: (value: boolean) => void;
  cleanupFlash: () => void;
}

export interface DevToolsDataState {
  signals: Map<string, SignalInfo>;
  tags: Map<string, TagInfo>;
  events: EventLogEntry[];
  stats: {
    signalCount: number;
    mutableCount: number;
    computedCount: number;
    tagCount: number;
    totalChanges: number;
    totalErrors: number;
    signalsWithErrors: number;
    disposedCount: number;
  };
  enabled: boolean;
  chains: ChainReaction[];
}

export interface DevToolsDataActions {
  setSignals: React.Dispatch<React.SetStateAction<Map<string, SignalInfo>>>;
  setEvents: React.Dispatch<React.SetStateAction<EventLogEntry[]>>;
  clearEvents: () => void;
  deleteSignal: (id: string) => void;
  setChains: React.Dispatch<React.SetStateAction<ChainReaction[]>>;
  refreshChains: () => void;
}

export function useDevToolsData({
  showAutoGeneratedRef,
  autoRemoveDisposedTimer,
  activeTab,
  flashSignal,
  flashTab,
  setFlashAutoToggle,
  cleanupFlash,
}: UseDevToolsDataOptions): [DevToolsDataState, DevToolsDataActions] {
  // Data state
  const [signals, setSignals] = useState<Map<string, SignalInfo>>(new Map());
  const [tags, setTags] = useState<Map<string, TagInfo>>(new Map());
  const [events, setEvents] = useState<EventLogEntry[]>([]);
  const [stats, setStats] = useState({
    signalCount: 0,
    mutableCount: 0,
    computedCount: 0,
    tagCount: 0,
    totalChanges: 0,
    totalErrors: 0,
    signalsWithErrors: 0,
    disposedCount: 0,
  });
  const [enabled, setEnabled] = useState(false);
  const [chains, setChains] = useState<ChainReaction[]>([]);

  // Refs
  const eventIdRef = useRef(0);
  const disposalTimeoutsRef = useRef<Map<string, NodeJS.Timeout>>(new Map());

  // Check if devtools is enabled
  useEffect(() => {
    const checkEnabled = () => {
      setEnabled(isDevToolsEnabled());
    };

    checkEnabled();
    const interval = setInterval(checkEnabled, 1000);
    return () => clearInterval(interval);
  }, []);

  // Refresh data periodically
  useEffect(() => {
    if (!enabled) return;

    const refresh = () => {
      const existingSignals = getSignals();
      const existingTags = getTags();
      const newStats = getStats();

      setSignals((prev) => {
        if (prev.size !== existingSignals.size)
          return new Map(existingSignals);
        return prev;
      });

      setTags((prev) => {
        if (prev.size !== existingTags.size) return new Map(existingTags);
        return prev;
      });

      setStats((prev) => {
        if (
          prev.mutableCount !== newStats.mutableCount ||
          prev.computedCount !== newStats.computedCount ||
          prev.disposedCount !== newStats.disposedCount ||
          prev.signalsWithErrors !== newStats.signalsWithErrors
        ) {
          return newStats;
        }
        return prev;
      });
    };

    refresh();
    const interval = setInterval(refresh, 500);
    return () => clearInterval(interval);
  }, [enabled]);

  // Auto-remove disposed signals
  useEffect(() => {
    if (!enabled) return;
    if (autoRemoveDisposedTimer < 0) return;

    const currentTimeouts = disposalTimeoutsRef.current;

    signals.forEach((signal, id) => {
      if (signal.disposed && !currentTimeouts.has(id)) {
        if (autoRemoveDisposedTimer === 0) {
          deleteSignalApi(id);
          setSignals((prev) => {
            const next = new Map(prev);
            next.delete(id);
            return next;
          });
        } else {
          const timeout = setTimeout(() => {
            deleteSignalApi(id);
            setSignals((prev) => {
              const next = new Map(prev);
              next.delete(id);
              return next;
            });
            currentTimeouts.delete(id);
          }, autoRemoveDisposedTimer * 1000);
          currentTimeouts.set(id, timeout);
        }
      }
    });

    currentTimeouts.forEach((timeout, id) => {
      const signal = signals.get(id);
      if (!signal || !signal.disposed) {
        clearTimeout(timeout);
        currentTimeouts.delete(id);
      }
    });
  }, [enabled, signals, autoRemoveDisposedTimer]);

  // Cleanup disposal timeouts on unmount
  useEffect(() => {
    return () => {
      disposalTimeoutsRef.current.forEach((timeout) => clearTimeout(timeout));
      disposalTimeoutsRef.current.clear();
    };
  }, []);

  // Subscribe to events
  useEffect(() => {
    if (!enabled) return;

    const unsubscribe = onDevToolsEvent((event) => {
      // Defer state updates to avoid "Cannot update a component while rendering"
      // This happens when signal reads during render trigger lazy computation
      queueMicrotask(() => {
        if (event.type === "signals:forget") {
          const forgottenIds = new Set(event.signalIds);
          setEvents((prev) =>
            prev.filter((e) => {
              if (e.type === "signal:create" || e.type === "tag:create") {
                return true;
              }
              if (
                "signalId" in e &&
                typeof e.signalId === "string" &&
                forgottenIds.has(e.signalId)
              )
                return false;
              return true;
            })
          );
          setSignals((prev) => {
            const next = new Map(prev);
            for (const id of forgottenIds) {
              next.delete(id);
            }
            return next;
          });
          return;
        }

        let isError = false;
        if (event.type === "signal:error") {
          isError = true;
        } else if (
          event.type === "window:error" ||
          event.type === "window:unhandledrejection"
        ) {
          isError = true;
        } else if (event.type === "signal:change" && "signalId" in event) {
          const signalInfo = getSignals().get(event.signalId);
          if (signalInfo?.signal?.error?.()) {
            isError = true;
          }
        }

        const entry: EventLogEntry = {
          ...event,
          id: eventIdRef.current++,
          timestamp: Date.now(),
          isError,
        };

        setEvents((prev) => {
          const newEvents = [entry, ...prev];
          return newEvents.slice(0, 100);
        });

        if (isError) {
          flashTab("events");
        }

        if (event.type === "signal:change" && "signalId" in event) {
          flashSignal(event.signalId, "change");
          flashTab("signals");
        } else if (event.type === "signal:create" && "signal" in event) {
          flashSignal(event.signal.id, "create");

          if (
            isAutoGeneratedName(event.signal.name) &&
            !showAutoGeneratedRef.current
          ) {
            setFlashAutoToggle(true);
          }
        }
      }); // End queueMicrotask
    });

    return () => {
      unsubscribe();
      cleanupFlash();
    };
  }, [enabled, flashSignal, flashTab, setFlashAutoToggle, cleanupFlash, showAutoGeneratedRef]);

  // Chain tracking
  useEffect(() => {
    if (activeTab === "chains" && enabled) {
      enableChainTracking();
      const interval = setInterval(() => {
        setChains(getChainsList());
      }, 200);
      return () => {
        disableChainTracking();
        clearInterval(interval);
      };
    } else {
      disableChainTracking();
    }
  }, [activeTab, enabled]);

  // Actions
  const clearEvents = useCallback(() => {
    setEvents([]);
  }, []);

  const deleteSignal = useCallback((id: string) => {
    deleteSignalApi(id);
    setSignals((prev) => {
      const next = new Map(prev);
      next.delete(id);
      return next;
    });
  }, []);

  const refreshChains = useCallback(() => {
    setChains(getChainsList());
  }, []);

  const state: DevToolsDataState = {
    signals,
    tags,
    events,
    stats,
    enabled,
    chains,
  };

  const actions: DevToolsDataActions = {
    setSignals,
    setEvents,
    clearEvents,
    deleteSignal,
    setChains,
    refreshChains,
  };

  return [state, actions];
}

