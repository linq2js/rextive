---
alwaysApply: true
---

# Rextive Framework Rules - Complete Guide

This comprehensive guide covers every aspect of the Rextive reactive state management library.

## üéØ Core Philosophy

Rextive is a **signal-based reactive state management** library with **explicit dependencies**:

- **One unified primitive**: `signal()` for all reactive needs (state, computed, async)
- **Explicit dependencies**: Dependencies are always declared, never auto-tracked
- **Framework agnostic**: Works in vanilla JS, React, or any environment
- **Lazy tracking**: Only subscribes to signals that are actually accessed
- **Unified sync/async**: Same API handles both synchronous and asynchronous values

---

## üì¶ Package Structure

```
rextive           Core signals (works anywhere)
rextive/react     React bindings (rx, useScope, provider)
rextive/op        Operators (to, filter, scan, debounce, throttle, etc.)
rextive/immer     Immer integration for immutable updates
rextive/cache     Data caching with strategies
rextive/plugins   Plugins (persistor)
rextive/devtools  DevTools panel
```

---

## üì¶ API Deep Dive

### 1. `signal()` - Complete Overload Reference

The `signal()` function has **6 overloads** - 3 for mutable signals, 3 for computed signals.

#### Overload 1: Empty Signal

```tsx
const user = signal<User>();
```

**When to use:**

- Optional values that start undefined
- Lazy initialization patterns
- Signals that receive values later

**Type behavior:**

- `user.get()` returns `User | undefined`
- `user.set()` requires `User` (not undefined)
- `user.set(undefined)` is a **type error**

**Example:**

```tsx
const selectedUser = signal<User>();

// Later...
selectedUser.set({ id: 1, name: "Alice" }); // ‚úÖ
// selectedUser.set(undefined); // ‚ùå Type error

// Reading
const current = selectedUser(); // User | undefined
if (current) {
  console.log(current.name); // Safe
}
```

---

#### Overload 2a: Mutable Signal with Initial Value

```tsx
const count = signal(0);
const user = signal({ name: "Alice" });
```

**When to use:**

- Simple state management
- Values that have clear initial state
- Most common use case

**Features:**

- Type is inferred from initial value
- Uses strict equality (Object.is) by default
- Can pass lazy initializer function

**Lazy initialization:**

```tsx
// Expensive computation only runs once when signal is created
const data = signal(() => {
  console.log("Computing initial value...");
  return expensiveComputation();
});
```

---

#### Overload 2b: Mutable Signal with Equality String Shortcut

```tsx
const user = signal({ name: "John" }, "shallow");
const data = signal(complexObj, "deep");
const count = signal(0, "strict");
```

**When to use:**

- Objects/arrays that change by reference
- Need custom comparison without full options object
- Performance optimization for large data structures

**Equality strategies:**

- `"strict"` - Object.is (default) - compares references
- `"shallow"` - Compares object keys/array elements one level deep
- `"deep"` - Deep comparison using lodash isEqual

**‚ö†Ô∏è Important:** Custom equality functions NOT allowed as second arg (use options form)

**Examples:**

```tsx
// Shallow: Prevents re-render if object content is same
const user = signal({ name: "John", age: 30 }, "shallow");
user.set({ name: "John", age: 30 }); // No update - same content
user.set({ name: "Jane", age: 25 }); // Updates - different content

// Deep: For nested objects
const config = signal({ theme: { color: "blue" } }, "deep");
config.set({ theme: { color: "blue" } }); // No update - deeply equal

// For custom equality, use options form:
const value = signal(0, {
  equals: (a, b) => Math.abs(a - b) < 0.01, // Threshold comparison
});
```

---

#### Overload 2c: Mutable Signal with Options

```tsx
const count = signal(0, {
  equals: (a, b) => a === b,
  name: "counter",
  onChange: (value) => console.log("Changed:", value),
  onError: (error) => console.error("Error:", error),
  fallback: (error) => 0,
  lazy: false,
});
```

**When to use:**

- Need multiple configuration options
- Custom equality function
- Side effects on change
- Error handling
- Debugging with names

**All options:**

```tsx
interface SignalOptions<T> {
  // Equality comparison
  equals?: "strict" | "shallow" | "deep" | ((a: T, b: T) => boolean);

  // Debugging
  name?: string; // For dev tools and debugging

  // Error handling
  fallback?: (error: unknown) => T; // Return fallback value on error
  onError?: (error: unknown) => void; // Handle errors

  // Side effects
  onChange?: (value: T) => void; // Called after value changes

  // Performance
  lazy?: boolean; // Delay computation until first access (default: true)

  // Advanced
  use?: readonly (Tag<T> | Plugin<T>)[]; // For plugins/extensions
}
```

**Advanced example:**

```tsx
const apiData = signal<Data[]>([], {
  name: "apiData",
  equals: "deep", // Deep compare arrays
  onChange: (data) => {
    // Side effect: persist to cache
    localStorage.setItem("cache", JSON.stringify(data));
  },
  onError: (error) => {
    // Log errors
    analytics.track("data-fetch-error", { error });
  },
  fallback: (error) => {
    // Return cached data on error
    const cached = localStorage.getItem("cache");
    return cached ? JSON.parse(cached) : [];
  },
});
```

---

#### Overload 3a: Computed Signal (Basic)

```tsx
const count = signal(0);
const doubled = signal({ count }, ({ deps }) => deps.count * 2);
```

**When to use:**

- Derive state from other signals
- Automatic recalculation when dependencies change
- Most common computed pattern

**Key rules:**

- ‚úÖ Always declare dependencies explicitly in first argument
- ‚úÖ Access dependencies via `deps` parameter
- ‚ùå Never try to auto-track: `signal(() => count() * 2)` won't work

**Multiple dependencies:**

```tsx
const firstName = signal("John");
const lastName = signal("Doe");
const email = signal("john@example.com");

const fullName = signal(
  { firstName, lastName },
  ({ deps }) => `${deps.firstName} ${deps.lastName}`
);

const userProfile = signal({ firstName, lastName, email }, ({ deps }) => ({
  name: `${deps.firstName} ${deps.lastName}`,
  email: deps.email,
  initials: deps.firstName[0] + deps.lastName[0],
}));
```

**Async computed:**

```tsx
const userId = signal(1);
const userData = signal({ userId }, async ({ deps, abortSignal }) => {
  const res = await fetch(`/users/${deps.userId}`, {
    signal: abortSignal, // Auto-cancels when userId changes
  });
  return res.json();
});
```

---

#### Overload 3b: Computed Signal with Equality Shortcut

```tsx
const fullName = signal(
  { firstName, lastName },
  ({ deps }) => ({ full: `${deps.firstName} ${deps.lastName}` }),
  "shallow"
);
```

**When to use:**

- Computed signals that return objects/arrays
- Need custom equality without full options
- Performance optimization

**‚ö†Ô∏è Important:** Custom equality functions NOT allowed as third arg (use options form)

---

#### Overload 3c: Computed Signal with Options

```tsx
const doubled = signal({ count }, ({ deps }) => deps.count * 2, {
  name: "doubled",
  equals: (a, b) => a === b,
  fallback: (error) => 0,
  onChange: (value) => console.log("Computed:", value),
  lazy: false, // Compute immediately
});
```

---

### 2. Signal Instance Methods

All signals have these methods:

#### `.get()` or `signal()` - Read Value

```tsx
const value = count.get();
const value = count(); // Shorthand
```

**‚ö†Ô∏è Important:** Reading a signal DOES NOT subscribe to changes!

```tsx
// This won't re-run when count changes:
const doubled = count() * 2; // ‚ùå Static snapshot

// Use computed signal instead:
const doubled = signal({ count }, ({ deps }) => deps.count * 2); // ‚úÖ
```

---

#### `.peek()` - Read Value Without Tracking ‚≠ê NEW

Read the current value **without** triggering reactive tracking:

```tsx
const value = count.peek();
```

**When to use:**
- In event handlers where you don't want to create dependencies
- Logging/debugging without affecting reactivity
- Internal reads in computed signals that shouldn't trigger updates
- Any place where you need the value but don't want reactive subscription

**Examples:**

```tsx
// In a tracking context, peek() won't create dependencies
rx(() => {
  // This WILL create a dependency (triggers re-render when count changes)
  console.log("Count:", count());
  
  // This WON'T create a dependency (no re-render when user changes)
  console.log("User (peeked):", user.peek());
});

// Useful in event handlers
const handleClick = () => {
  const currentCount = count.peek(); // Read without tracking
  console.log("Current count:", currentCount);
};

// Internal reads in operators/plugins
const operator = (source) => {
  // Use peek() to avoid creating unwanted dependencies
  const initialValue = source.peek();
  // ...
};
```

**Key differences from `.get()`:**
- `.get()` / `signal()` - triggers `onSignalAccess` in render hooks (creates dependencies)
- `.peek()` - never triggers tracking (safe for internal use)

---

#### `.set(value)` - Update Value (Mutable Only)

```tsx
// Direct value
count.set(5);

// Updater function
count.set((prev) => prev + 1);
```

---

#### `.reset()` - Reset to Initial Value (Mutable Only)

```tsx
const count = signal(0);
count.set(10);
count.reset(); // Back to 0
```

---

#### `.on(callback)` - Subscribe to Changes

```tsx
const unsubscribe = count.on(() => {
  console.log("Count changed to:", count());
});

// Later: cleanup
unsubscribe();
```

---

#### `.to(selector, equals?)` - Transform Signal Value ‚≠ê NEW

The `.to()` method is the **recommended way** to transform a single signal:

```tsx
const count = signal(5);
const doubled = count.to((x) => x * 2); // Creates computed signal
const formatted = count.to((x) => `Count: ${x}`);
```

**With equality:**

```tsx
const userName = user.to((u) => u.name, "shallow");
const userData = user.to((u) => u.data, "deep");
```

**Shorthand for:**

```tsx
const doubled = signal({ count }, ({ deps }) => deps.count * 2);
```

---

#### `.pipe(...operators)` - Chain Operators ‚≠ê NEW

```tsx
import { to, filter, scan } from "rextive/op";

const result = count.pipe(
  filter((x) => x > 0),
  to((x) => x * 2),
  scan((acc, x) => acc + x, 0)
);
```

---

#### `.refresh()` - Force Immediate Recomputation ‚≠ê NEW

```tsx
userData.refresh(); // Triggers recomputation now
```

---

#### `.stale()` - Mark for Lazy Recomputation ‚≠ê NEW

```tsx
userData.stale(); // Will recompute on next access
```

---

#### `.error()` / `.tryGet()` - Safe Error Access ‚≠ê NEW

```tsx
const error = signal.error();    // Get error without throwing
const value = signal.tryGet();   // Get value or undefined (never throws)
```

---

#### `.pause()` / `.resume()` / `.paused()` - Control Computed (Computed Only)

```tsx
const computed = signal({ count }, ({ deps }) => deps.count * 2);

computed.pause(); // Stop recomputing
count.set(10); // computed doesn't update

computed.paused(); // true

computed.resume(); // Resume recomputing (recalculates now)
```

---

#### `.dispose()` - Clean Up Signal

```tsx
count.dispose();
```

**‚ö†Ô∏è Critical:** Always dispose signals you create to prevent memory leaks!

---

#### `.when()` - React to Other Signals ‚≠ê NEW

React to changes in other signals by triggering actions or applying reducers.

**For Mutable Signals - Action-based:**

```tsx
const refreshTrigger = signal(0);
const userData = signal({ name: "John" });

// Refresh when trigger changes
userData.when(refreshTrigger, "refresh");

// Reset when trigger changes
userData.when(refreshTrigger, "reset");

// With filter - only trigger when condition is met
userData.when(refreshTrigger, "refresh", (self, notifier) => notifier() > 5);
```

**For Mutable Signals - Reducer-based:**

```tsx
const increment = signal(0);
const counter = signal(0);

// Update value based on notifier
counter.when(increment, (self, notifier) => self() + notifier());
```

**For Computed Signals:**

```tsx
const refreshTrigger = signal(0);
const fetchedData = signal({ userId }, async ({ deps }) => fetchUser(deps.userId));

// Refresh (immediate recompute)
fetchedData.when(refreshTrigger, "refresh");

// Stale (lazy recompute on next access)
fetchedData.when(refreshTrigger, "stale");

// Note: "reset" is NOT supported for computed signals
```

**Multiple Notifiers:**

```tsx
const trigger1 = signal(0);
const trigger2 = signal(0);

// React to any of multiple signals
userData.when([trigger1, trigger2], "refresh");

// Filter receives the specific notifier that changed
userData.when([trigger1, trigger2], "refresh", (self, notifier) => {
  return notifier() > 0; // notifier is the one that triggered
});
```

**Chaining:**

```tsx
// .when() returns this for chaining
userData
  .when(refreshTrigger, "refresh")
  .when(resetTrigger, "reset");
```

**Cleanup:**

Subscriptions created by `.when()` are automatically cleaned up when the signal is disposed.

**‚ö†Ô∏è Error Handling:**

```tsx
// Filter errors - action is NOT executed, error routed to signal's onError
userData.when(trigger, "refresh", (self, notifier) => {
  if (notifier() < 0) throw new Error("Invalid"); // Action skipped, onError called
  return true;
});

// Reducer errors - signal enters ERROR state
counter.when(increment, (self, notifier) => {
  if (notifier() < 0) throw new Error("Negative not allowed");
  return self() + notifier();
});
// After error: counter.error() returns the error, counter() throws
```

**‚ö†Ô∏è Common Pitfalls:**

```tsx
// ‚ùå BAD - Accessing disposed signal in filter/reducer
const data = signal([]);
data.when(trigger, (self, notifier) => {
  return self().concat(notifier()); // May throw if self is disposed
});

// ‚úÖ GOOD - Check for disposal or use tryGet()
data.when(trigger, (self, notifier) => {
  const current = self.tryGet();
  if (!current) return []; // Handle disposed/error state
  return current.concat(notifier());
});

// ‚ùå BAD - Circular dependency
const a = signal(0);
const b = signal(0);
a.when(b, (self, notifier) => notifier()); // a depends on b
b.when(a, (self, notifier) => notifier()); // b depends on a - INFINITE LOOP!

// ‚ùå BAD - "reset" on computed signals
computed.when(trigger, "reset"); // Throws error! Use "refresh" or "stale"
```

---

### 3. Compute Function Context

For computed signals, the compute function receives a context object:

```tsx
signal({ userId, filter }, (context) => {
  context.deps        // Dependency values
  context.abortSignal // AbortSignal for cancellation
});
```

#### Context Methods ‚≠ê NEW

```tsx
signal(async (context) => {
  // Safe execution (throws if aborted)
  const data = context.safe(() => processData());
  
  // Safe promise (never resolves if aborted)
  await context.safe(wait.delay(300));
  
  // Register cleanup
  context.onCleanup(() => cleanup());
  
  // Check if aborted
  if (context.aborted()) return null;
  
  // Reuse logic with context
  const result = await context.use(fetchUser, options);
  
  // Trigger recomputation (polling)
  setTimeout(() => context.refresh(), 1000);
  
  // Mark stale (TTL cache)
  setTimeout(() => context.stale(), 5 * 60 * 1000);
});
```

---

### 4. Static Methods

#### `signal.batch(fn)` - Batch Multiple Updates

```tsx
signal.batch(() => {
  firstName.set("Jane");
  lastName.set("Smith");
  email.set("jane@example.com");
});
// Only ONE notification!
```

---

#### `signal.on(signals, callback)` - Subscribe to Multiple Signals

```tsx
const control = signal.on([count, name], (trigger) => {
  console.log("Changed:", trigger());
});

control.pause();   // Pause
control.resume();  // Resume
control.dispose(); // Cleanup
```

---

#### `signal.tag()` - Create a Tag for Grouping

```tsx
const formTag = signal.tag();

const name = signal("", { use: [formTag] });
const email = signal("", { use: [formTag] });

formTag.forEach((s) => s.reset()); // Reset all
formTag.map((s) => s.get());       // Collect values
formTag.size;                       // Count
```

---

#### `signal.from(signals)` - Combine Signals

```tsx
// Record form
const user = signal.from({ name, age });
console.log(user()); // { name: "...", age: ... }

// Tuple form
const coords = signal.from([x, y]);
console.log(coords()); // [10, 20]
```

---

#### `signal.trace(error)` - Get Error Trace ‚≠ê NEW

```tsx
try {
  dashboard();
} catch (error) {
  const traces = signal.trace(error);
  // [{ signal: "db", when: "compute:initial", async: true }, ...]
  
  const errorPath = traces.map((t) => t.signal).join(" ‚Üí ");
  console.log("Error path:", errorPath);
}
```

---

#### `signal.is(value, kind?)` - Check Signal Type ‚≠ê NEW

```tsx
signal.is(maybeSignal);           // Is any signal?
signal.is(sig, "mutable");        // Is mutable?
signal.is(sig, "computed");       // Is computed?
```

---

### 5. `rx()` - React Integration

The `rx()` function has **4 overloads** for reactive rendering in React.

#### Overload 1: Single Signal

```tsx
const count = signal(42);
{rx(count)} // Renders: 42
```

---

#### Overload 2: Single Signal with Property/Selector

```tsx
const user = signal({ name: "Alice", age: 30 });

// Property access
{rx(user, "name")} // Renders: "Alice"

// Selector function
{rx(user, (u) => u.age + 5)} // Renders: 35
```

---

#### Overload 3: Reactive Function (Auto-Tracking)

```tsx
{rx(() => <div>Count: {count()}</div>)}
```

**How it works:**

- Signals accessed inside the function are automatically tracked
- Re-renders when any tracked signal changes

---

#### Overload 4: Component with Reactive Props

```tsx
{rx(Component, { prop1: signal1, prop2: "static" })}
{rx("div", { children: count, className: "counter" })}
```

---

#### ‚ö†Ô∏è Important `rx()` Warnings

**‚ùå NEVER use `rx()` directly in element attributes!**

```tsx
// ‚ùå WRONG - Won't be reactive!
<input value={rx(signal)} />
<div className={rx(theme)} />
```

**‚úÖ CORRECT - Use one of these instead:**

```tsx
// Option 1: Wrap entire element with rx(fn)
{rx(() => <input value={signal()} />)}

// Option 2: Use component form rx(Component, props)
{rx("input", { value: signal })}
```

---

#### `rx.use()` - Reactive Hook ‚≠ê NEW

Low-level hook for automatic signal tracking:

```tsx
function Component() {
  const value = rx.use(() => {
    const userData = wait(user());
    const postList = wait(posts());
    return { userData, postList };
  });

  return <div>{value.userData.name}</div>;
}
```

---

### 6. `useScope()` - Component Lifecycle

#### Mode 1: Factory (Most Common)

```tsx
function TodoList() {
  const scope = useScope(() => {
    const todos = signal([]);
    const filter = signal("all");
    
    return disposable({
      todos,
      filter,
      addTodo: (text) => todos.set(prev => [...prev, text]),
    });
  });

  return <div>{rx(scope.todos, (t) => t.length)} todos</div>;
}
```

---

#### Mode 2: Lifecycle

```tsx
useScope({
  init: () => console.log("Before first render"),
  mount: () => console.log("After first paint"),
  render: () => console.log("Every render"),
  cleanup: () => console.log("React cleanup"),
  dispose: () => console.log("True unmount"),
});
```

---

#### Mode 3: Object Tracking

```tsx
useScope({
  for: user,
  init: (user) => analytics.track("session-start", user),
  dispose: (user) => analytics.track("session-end", user),
});
```

---

#### Options

```tsx
useScope(factory, {
  watch: [dep1, dep2], // Recreate when deps change
  update: [(scope) => scope.refresh(), dep], // Run effect on deps change
});
```

---

### 7. `provider()` - Signal Context ‚≠ê NEW

Create signal-based React Context:

```tsx
const [useTheme, ThemeProvider] = provider({
  name: "Theme",
  create: (initialValue: "dark" | "light") => {
    return signal(initialValue);
  },
});

function App() {
  return (
    <ThemeProvider value="dark">
      <ChildComponent />
    </ThemeProvider>
  );
}

function ChildComponent() {
  const theme = useTheme();
  return <div>Theme: {rx(theme)}</div>;
}
```

---

### 8. Async Utilities

#### `wait()` / `wait.all()` - Wait for All

```tsx
// Suspense mode (throws for Suspense)
const value = wait(promise);
const [a, b] = wait([p1, p2]);
const { user, posts } = wait({ user: p1, posts: p2 });

// Promise mode
await wait(promise, (value) => processValue(value));
```

#### `wait.any()` - First to Resolve

```tsx
const [value, key] = wait.any({ fast, slow });
```

#### `wait.race()` - First to Settle

```tsx
const [value, key] = wait.race({ p1, p2 });
```

#### `wait.settled()` - All Settled (Never Throws)

```tsx
const results = wait.settled([p1, p2, p3]);
```

#### `wait.timeout()` - With Timeout

```tsx
const data = await wait.timeout(fetchData(), 5000);
```

#### `wait.delay()` - Simple Delay

```tsx
await wait.delay(1000);
```

---

### 9. `loadable()` - Manual Loading States

```tsx
const state = loadable(promise);

state.status;   // "loading" | "success" | "error"
state.loading;  // boolean
state.value;    // resolved value
state.error;    // error if rejected
```

**React usage:**

```tsx
{rx(() => {
  const state = loadable(userData());
  if (state.loading) return <Spinner />;
  if (state.error) return <Error error={state.error} />;
  return <div>{state.value.name}</div>;
})}
```

---

### 10. Operators (`rextive/op`) ‚≠ê NEW

```tsx
import { to, filter, scan, focus, debounce, throttle, pace } from "rextive/op";
```

#### `to()` - Transform Values

```tsx
const doubled = count.pipe(to((x) => x * 2));
```

#### `filter()` - Filter Values

```tsx
const positiveOnly = count.pipe(filter((x) => x > 0));
```

#### `scan()` - Accumulate Values

```tsx
const total = count.pipe(scan((acc, curr) => acc + curr, 0));
```

#### `focus()` - Bidirectional Lens for Nested Properties

Create a bidirectional mutable signal for a nested property path:

```tsx
// Basic usage with dot-notation
const form = signal({ user: { name: "Alice" } });
const userName = form.pipe(focus("user.name"));
console.log(userName()); // "Alice"
userName.set("Bob");     // Updates source immutably

// With fallback (for optional properties)
type User = { name: string; nickname?: string };
const user = signal<User>({ name: "Alice" });

// Without fallback - type is string | undefined
const nickname = user.pipe(focus("nickname"));

// With fallback - type is string (guaranteed non-nullable)
const nicknameDefault = user.pipe(focus("nickname", () => "Guest"));
console.log(nicknameDefault()); // "Guest"

// With options
const price = form.pipe(focus("price", {
  get: (v) => v * 1.1,     // Transform on read
  set: (v) => v / 1.1,     // Transform on write
  equals: "shallow",
}));

// Fallback + options
const theme = user.pipe(focus("settings.theme", () => "light", { name: "userTheme" }));
```

**Overloads:**
- `focus(path, options?)` ‚Üí `Mutable<PathValue<T, P>>` (may include undefined)
- `focus(path, fallback, options?)` ‚Üí `Mutable<F>` (F = fallback return type, non-nullable)

**Fallback behaviors:**
- Called only for `null` or `undefined` values
- **Memoized** - factory called only once
- `0`, `""`, `false` are NOT nullish (no fallback used)

#### `debounce()` - Debounce Updates

```tsx
const debouncedSearch = searchInput.pipe(debounce(300));
```

#### `throttle()` - Throttle Updates

```tsx
const throttledPosition = mousePosition.pipe(throttle(100));
```

#### `pace()` - Rate Limit Updates

```tsx
const pacedData = fastData.pipe(pace(1000));
```

---

### 11. Plugins (`rextive/plugins`) ‚≠ê NEW

#### `persistor` - Auto-Persistence

```tsx
import { persistor } from "rextive/plugins";

const persist = persistor<{ theme: string; fontSize: number }>({
  load: () => JSON.parse(localStorage.getItem("settings") || "{}"),
  save: (args) => {
    const existing = JSON.parse(localStorage.getItem("settings") || "{}");
    localStorage.setItem("settings", JSON.stringify({ ...existing, ...args.values }));
  },
});

const theme = signal("dark", { use: [persist("theme")] });
```

---

### 12. Immer Integration (`rextive/immer`) ‚≠ê NEW

```tsx
import { produce } from "rextive/immer";

const state = signal({ count: 0, user: { name: "John" } });

// Write "mutations" that are actually immutable
state.set(produce((draft) => {
  draft.count++;
  draft.user.name = "Jane";
}));
```

---

### 13. Cache (`rextive/cache`) ‚≠ê NEW

```tsx
import { cache, staleOn, evictOn, lru } from "rextive/cache";

const getUser = cache("users", async (userId: string) => {
  const res = await fetch(`/api/users/${userId}`);
  return res.json();
});

// Access cached data
const { value, unref } = getUser("123");
const user = await value;

// Release reference when done
unref();

// Cache methods
getUser.stale("123");   // Mark stale
getUser.refresh("123"); // Force re-fetch
getUser.delete("123");  // Remove
getUser.clear();        // Clear all
```

---

### 14. DevTools (`rextive/devtools`) ‚≠ê NEW

```tsx
import { enableDevTools, DevToolsPanel } from "rextive/devtools";

// Enable devtools
enableDevTools();

// Add panel to your app
function App() {
  return (
    <div>
      <YourApp />
      {process.env.NODE_ENV === "development" && <DevToolsPanel />}
    </div>
  );
}
```

---

### 15. Utilities

#### `disposable(obj)` - Create Disposable ‚≠ê NEW

```tsx
const scope = disposable({
  count: signal(0),
  doubled: count.to(x => x * 2),
});
// Automatically adds dispose array
```

#### `awaited(...selectors)` - Transform Async Values ‚≠ê NEW

```tsx
const titles = todoList.to(
  awaited(
    (todos) => todos.filter(t => !t.done),
    (todos) => todos.map(t => t.title)
  )
);
```

#### `emitter()` - Event Emitter

```tsx
const events = emitter<string>();
events.on((value) => console.log(value));
events.emit("hello");
events.dispose();
```

---

## üé® Advanced Patterns

### Pattern 1: Single Dependency - Transform with `.to()`

When you need to **transform one signal** into another:

```tsx
const count = signal(0);

// Transform it with .to()
const doubled = count.to((x) => x * 2);
const formatted = count.to((x) => `Count: ${x}`);
```

---

### Pattern 2: Multiple Dependencies - Combine Signals

When you need to **combine multiple signals**:

```tsx
const firstName = signal("John");
const lastName = signal("Doe");

const fullName = signal(
  { firstName, lastName },
  ({ deps }) => `${deps.firstName} ${deps.lastName}`
);
```

---

### Pattern 3: Async with Dependencies

```tsx
const userId = signal(1);

const user = signal({ userId }, async ({ deps, abortSignal }) => {
  const response = await fetch(`/api/users/${deps.userId}`, {
    signal: abortSignal, // Automatically cancels previous request
  });
  return response.json();
});
```

---

### Pattern 4: Chain Multiple Operators

```tsx
import { to, filter, scan } from "rextive/op";

const result = count.pipe(
  filter((x) => x > 0),
  to((x) => x * 2),
  scan((acc, x) => acc + x, 0)
);
```

---

### Pattern 5: Debounced Search

```tsx
function SearchBox() {
  const scope = useScope(() => {
    const searchInput = signal("");

    const results = signal(
      { searchInput },
      async ({ deps, abortSignal, safe }) => {
        const query = deps.searchInput.trim();
        if (!query || query.length < 2) return [];

        // Debounce: wait 300ms
        await safe(wait.delay(300));

        const res = await fetch(`/api/search?q=${query}`, { signal: abortSignal });
        return res.json();
      }
    );

    return disposable({ searchInput, results });
  });

  return (
    <div>
      <input onChange={(e) => scope.searchInput.set(e.target.value)} />
      {rx(() => {
        const state = loadable(scope.results());
        if (state.loading) return <div>Searching...</div>;
        return <ul>{state.value.map(item => <li key={item.id}>{item.name}</li>)}</ul>;
      })}
    </div>
  );
}
```

---

### Pattern 6: Batch Updates

```tsx
signal.batch(() => {
  firstName.set("Jane");
  lastName.set("Smith");
  email.set("jane@example.com");
});
// Only ONE notification!
```

---

### Pattern 7: Group Signals with Tags

```tsx
const formTag = signal.tag();

const name = signal("", { use: [formTag] });
const email = signal("", { use: [formTag] });
const message = signal("", { use: [formTag] });

// Reset all form fields at once
formTag.forEach((s) => s.reset());
```

---

## üö® Critical Rules

### ‚úÖ Always Do These

1. **Declare dependencies explicitly**

```tsx
// ‚úÖ GOOD
signal({ a, b }, ({ deps }) => deps.a + deps.b);

// ‚ùå BAD - won't work!
signal(() => a() + b());
```

2. **Use `abortSignal` for queries**

```tsx
// ‚úÖ GOOD - Cancels previous request
signal({ searchTerm }, async ({ deps, abortSignal }) => {
  return fetch(`/search?q=${deps.searchTerm}`, { signal: abortSignal });
});
```

3. **Use `disposable()` for auto-cleanup**

```tsx
// ‚úÖ GOOD
useScope(() => disposable({
  count: signal(0),
  doubled: count.to(x => x * 2),
}));
```

4. **Use `.to()` for single-signal transforms**

```tsx
// ‚úÖ GOOD - cleaner
const doubled = count.to(x => x * 2);

// ‚úÖ Also valid but verbose
const doubled = signal({ count }, ({ deps }) => deps.count * 2);
```

### ‚ùå Never Do These

1. **Never try auto-tracking**

```tsx
// ‚ùå Won't work
const doubled = signal(() => count() * 2);
```

2. **Never pass Promises directly**

```tsx
// ‚ùå Wrong
const data = signal(Promise.resolve(42));

// ‚úÖ Correct
const data = signal(async () => 42);
```

3. **Never use `abortSignal` for mutations**

```tsx
// ‚ùå Bad - mutations should complete
signal({ payload }, async ({ deps, abortSignal }) => {
  return fetch("/api", { method: "POST", signal: abortSignal });
});

// ‚úÖ Good
signal({ payload }, async ({ deps }) => {
  return fetch("/api", { method: "POST" });
});
```

4. **Never create signals in render without useScope**

```tsx
function Component() {
  // ‚ùå Bad - memory leak
  const count = signal(0);

  // ‚úÖ Good
  const { count } = useScope(() => disposable({ count: signal(0) }));
}
```

5. **Never use `rx()` in attributes**

```tsx
// ‚ùå Bad
<input value={rx(signal)} />;

// ‚úÖ Good
{rx(() => <input value={signal()} />)}
{rx("input", { value: signal })}
```

---

## üìö Complete API Reference

### Signal Methods

- `signal()` - Empty signal
- `signal(value)` - With initial value
- `signal(value, equals)` - With equality strategy
- `signal(value, options)` - With full options
- `signal(deps, compute)` - Computed signal
- `signal(deps, compute, equals)` - Computed with equality
- `signal(deps, compute, options)` - Computed with options
- `.set(value)` - Update (mutable only)
- `.get()` or `()` - Read value (triggers tracking)
- `.peek()` - Read value without tracking ‚≠ê
- `.on(listener)` - Subscribe
- `.dispose()` - Cleanup
- `.reset()` - Reset to initial (mutable only)
- `.to(fn, equals?)` - Transform (creates computed) ‚≠ê
- `.pipe(...operators)` - Chain operators ‚≠ê
- `.refresh()` - Force recomputation ‚≠ê
- `.stale()` - Mark stale ‚≠ê
- `.error()` - Get error safely ‚≠ê
- `.tryGet()` - Get value safely ‚≠ê
- `.pause()` / `.resume()` / `.paused()` - Control (computed only)
- `.when(notifier, action, filter?)` - React to other signals ‚≠ê
- `.when(notifier, reducer)` - Update value when notifier changes (mutable only) ‚≠ê

### Static Methods

- `signal.batch(fn)` - Batch updates
- `signal.on(signals, callback)` - Subscribe to multiple
- `signal.tag()` - Create tag for grouping
- `signal.from(signals)` - Combine signals
- `signal.trace(error)` - Error tracing ‚≠ê
- `signal.is(value, kind?)` - Type checking ‚≠ê

### Wait Methods

- `wait()` / `wait.all()` - Wait for all
- `wait.any()` - First to resolve
- `wait.race()` - First to settle
- `wait.settled()` - All settled (never throws)
- `wait.timeout()` - With timeout
- `wait.delay()` - Simple delay

### Loadable Methods

- `loadable()` - Normalize to loadable
- `loadable.loading()` - Create loading state
- `loadable.success()` - Create success state
- `loadable.error()` - Create error state
- `loadable.is()` - Type guard

### React Hooks

- `rx()` - Reactive rendering (4 overloads)
- `rx.use()` - Reactive hook ‚≠ê
- `useScope()` - Lifecycle & scoped state (3 overloads)
- `provider()` - Signal context ‚≠ê

### Operators (`rextive/op`) ‚≠ê

- `to(fn, equals?)` - Transform
- `filter(predicate)` - Filter
- `scan(fn, initial)` - Accumulate
- `focus(path, options?)` - Bidirectional lens (returns Mutable)
- `focus(path, fallback, options?)` - With fallback (non-nullable)
- `debounce(ms)` - Debounce
- `throttle(ms)` - Throttle
- `pace(ms)` - Rate limit

### Plugins (`rextive/plugins`) ‚≠ê

- `persistor(options)` - Auto-persistence

### Utilities

- `disposable(obj)` - Create disposable ‚≠ê
- `awaited(...selectors)` - Transform async ‚≠ê
- `emitter()` - Event emitter

---

## üîß Internal Architecture

### Hooks System (`src/hooks.ts`)

The hooks system provides centralized integration points for render tracking and devtools.

#### Render Hooks (for `rx()` auto-tracking)

```tsx
import { RenderHooks, getRenderHooks, withRenderHooks } from "./hooks";

// RenderHooks interface
interface RenderHooks {
  onSignalAccess: (signal: AnySignal<any>) => void;
  onLoadableAccess: (loadable: Loadable<any>) => void;
}

// Get current render hooks
const hooks = getRenderHooks();

// Execute with custom render hooks (used by rx())
withRenderHooks({
  onSignalAccess: (signal) => accessedSignals.add(signal),
}, () => {
  return renderFn();
});
```

#### DevTools Hooks (for monitoring)

```tsx
import { DevToolsHooks, setDevToolsHooks, hasDevTools, emit } from "./hooks";

// DevToolsHooks interface
interface DevToolsHooks {
  onSignalCreate: (signal: SignalRef) => void;
  onSignalChange: (signal: SignalRef, value: unknown) => void;
  onSignalError: (signal: SignalRef, error: unknown) => void;
  onSignalDispose: (signal: SignalRef) => void;
  onSignalRename: (signal: SignalRef) => void;
  onTagCreate: (tag: TagRef) => void;
  onTagAdd: (tag: TagRef, signal: AnySignal<any>) => void;
  onTagRemove: (tag: TagRef, signal: AnySignal<any>) => void;
}

// Register devtools hooks (called by enableDevTools)
setDevToolsHooks({
  onSignalCreate: (signal) => { /* track */ },
  onSignalChange: (signal, value) => { /* log */ },
});

// Emit events from core code
emit.signalCreate(signalRef);
emit.signalChange(signalRef, newValue);
emit.signalError(signalRef, error);
```

#### Migration from `contextDispatcher.ts`

| Old (Removed) | New |
|---------------|-----|
| `contextDispatcher.ts` | `hooks.ts` |
| `ContextDispatcher` | `RenderHooks` |
| `getCurrent()` | `getRenderHooks()` |
| `withDispatcher()` | `withRenderHooks()` |
| `trackSignal()` | `onSignalAccess()` |
| `trackLoadable()` | `onLoadableAccess()` |
| `globalThis.__REXTIVE_DEVTOOLS__` | `setDevToolsHooks()` + `emit` |

---

## Summary

**Core Principles:**

1. ‚úÖ **Explicit dependencies** - Always declare what signals depend on
2. ‚úÖ **Lazy tracking** - Only subscribe to what you access
3. ‚úÖ **Use `.to()` for single transforms** - Cleaner than computed signals
4. ‚úÖ **Use `disposable()` for cleanup** - Automatic disposal
5. ‚úÖ **Unified API** - One `signal()` function for everything
6. ‚ùå **No auto-tracking** - Dependencies must be explicit
7. ‚ùå **No magic** - Clear, predictable behavior

**Remember:**

- Use `.to()` for single-signal transforms
- Use `signal({ deps }, compute)` for multi-signal
- Use `disposable()` in `useScope()` for auto-cleanup
- Use `rx()` for reactive rendering
- Use `wait()` for Suspense-based async handling
- Use `loadable()` for manual loading states
- Use `abortSignal` for queries, not mutations
- Import from `rextive/react` in React apps
