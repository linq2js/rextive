---
alwaysApply: true
---

# Rextive Framework Rules - Complete Guide

This comprehensive guide covers every aspect of the Rextive reactive state management library.

## ğŸ¯ Core Philosophy

Rextive is a **signal-based reactive state management** library with **explicit dependencies**:

- **One unified primitive**: `signal()` for all reactive needs (state, computed, async)
- **Explicit dependencies**: Dependencies are always declared, never auto-tracked
- **Framework agnostic**: Works in vanilla JS, React, or any environment
- **Lazy tracking**: Only subscribes to signals that are actually accessed
- **Unified sync/async**: Same API handles both synchronous and asynchronous values

---

## ğŸ“¦ Package Structure

```
rextive           Core signals (works anywhere)
rextive/react     React bindings (rx, useScope, provider)
rextive/op        Operators (to, filter, scan, debounce, throttle, etc.)
rextive/immer     Immer integration for immutable updates
rextive/cache     Data caching with strategies
rextive/plugins   Plugins (persistor)
rextive/devtools  DevTools panel
rextive/test      Testing utilities (mockLogic)
```

---

## ğŸ“¦ API Deep Dive

### 1. `signal()` - Complete Overload Reference

The `signal()` function has **6 overloads** - 3 for mutable signals, 3 for computed signals.

#### Overload 1: Empty Signal (Notifier Pattern)

```tsx
const user = signal<User>();
```

**When to use:**

- Optional values that start undefined
- Lazy initialization patterns
- Signals that receive values later
- **Action/event dispatching** (notifier pattern)

**Type behavior:**

- `user.get()` returns `User | undefined`
- `user.set()` requires `User` (not undefined)
- `user.set(undefined)` is a **type error**

**â­ Notifier Behavior:**

Empty signals act as **notifiers** - they trigger subscribers on every `.set()` call, even with the same value:

| Property      | Value                           |
| ------------- | ------------------------------- |
| Initial value | `undefined`                     |
| Equality      | Always different (`NOT_EQUALS`) |
| Name          | Auto-generated `#notifier-xxx`  |

```tsx
const notifier = signal<"action1" | "action2">();

notifier.on(() => {
  console.log("triggered:", notifier());
});

notifier.set("action1"); // âœ… Triggers (1st time)
notifier.set("action1"); // âœ… Triggers again (same value!)
```

**Example - Action Dispatching:**

```tsx
type Action =
  | { type: "login"; username: string; password: string }
  | { type: "logout" };

const action = signal<Action>();

action.on(() => {
  const a = action();
  if (a?.type === "login") handleLogin(a.username, a.password);
  if (a?.type === "logout") handleLogout();
});

action.set({ type: "login", username: "admin", password: "secret" });
action.set({ type: "logout" });
```

**Example - Event Bus:**

```tsx
const onClick = signal<MouseEvent>();
const onKeyPress = signal<KeyboardEvent>();

onClick.on(() => console.log("clicked!", onClick()));

// Works great with refreshOn/staleOn operators
const data = asyncSignal.pipe(refreshOn(onClick));
```

**Example - Optional/Lazy Value:**

```tsx
const selectedUser = signal<User>();

// Later...
selectedUser.set({ id: 1, name: "Alice" }); // âœ…
// selectedUser.set(undefined); // âŒ Type error

// Reading
const current = selectedUser(); // User | undefined
if (current) {
  console.log(current.name); // Safe
}
```

---

#### Overload 2a: Mutable Signal with Initial Value

```tsx
const count = signal(0);
const user = signal({ name: "Alice" });
```

**When to use:**

- Simple state management
- Values that have clear initial state
- Most common use case

**Features:**

- Type is inferred from initial value
- Uses strict equality (Object.is) by default
- Can pass lazy initializer function

**Lazy initialization:**

```tsx
// Expensive computation only runs once when signal is created
const data = signal(() => {
  console.log("Computing initial value...");
  return expensiveComputation();
});
```

---

#### Overload 2b: Mutable Signal with Equality String Shortcut

```tsx
const user = signal({ name: "John" }, "shallow");
const data = signal(complexObj, "deep");
const count = signal(0, "strict");
```

**When to use:**

- Objects/arrays that change by reference
- Need custom comparison without full options object
- Performance optimization for large data structures

**Equality strategies:**

- `"strict"` - Object.is (default) - compares references
- `"shallow"` - Compares object keys/array elements one level deep
- `"deep"` - Deep comparison using lodash isEqual

**âš ï¸ Important:** Custom equality functions NOT allowed as second arg (use options form)

**Examples:**

```tsx
// Shallow: Prevents re-render if object content is same
const user = signal({ name: "John", age: 30 }, "shallow");
user.set({ name: "John", age: 30 }); // No update - same content
user.set({ name: "Jane", age: 25 }); // Updates - different content

// Deep: For nested objects
const config = signal({ theme: { color: "blue" } }, "deep");
config.set({ theme: { color: "blue" } }); // No update - deeply equal

// For custom equality, use options form:
const value = signal(0, {
  equals: (a, b) => Math.abs(a - b) < 0.01, // Threshold comparison
});
```

---

#### Overload 2c: Mutable Signal with Options

```tsx
const count = signal(0, {
  equals: (a, b) => a === b,
  name: "counter",
  onChange: (value) => console.log("Changed:", value),
  onError: (error) => console.error("Error:", error),
  fallback: (error) => 0,
  lazy: false,
});
```

**When to use:**

- Need multiple configuration options
- Custom equality function
- Side effects on change
- Error handling
- Debugging with names

**All options:**

```tsx
interface SignalOptions<T> {
  // Equality comparison
  equals?: "strict" | "shallow" | "deep" | ((a: T, b: T) => boolean);

  // Debugging
  name?: string; // For dev tools and debugging

  // Error handling
  fallback?: (error: unknown) => T; // Return fallback value on error
  onError?: (error: unknown) => void; // Handle errors

  // Side effects
  onChange?: (value: T) => void; // Called after value changes

  // Performance
  lazy?: boolean; // Delay computation until first access (default: true)

  // Advanced
  use?: readonly (Tag<T> | Plugin<T>)[]; // For plugins/extensions
}
```

**Advanced example:**

```tsx
const apiData = signal<Data[]>([], {
  name: "apiData",
  equals: "deep", // Deep compare arrays
  onChange: (data) => {
    // Side effect: persist to cache
    localStorage.setItem("cache", JSON.stringify(data));
  },
  onError: (error) => {
    // Log errors
    analytics.track("data-fetch-error", { error });
  },
  fallback: (error) => {
    // Return cached data on error
    const cached = localStorage.getItem("cache");
    return cached ? JSON.parse(cached) : [];
  },
});
```

---

#### Overload 3a: Computed Signal (Basic)

```tsx
const count = signal(0);
const doubled = signal({ count }, ({ deps }) => deps.count * 2);
```

**When to use:**

- Derive state from other signals
- Automatic recalculation when dependencies change
- Most common computed pattern

**Key rules:**

- âœ… Always declare dependencies explicitly in first argument
- âœ… Access dependencies via `deps` parameter
- âŒ Never try to auto-track: `signal(() => count() * 2)` won't work

**Multiple dependencies:**

```tsx
const firstName = signal("John");
const lastName = signal("Doe");
const email = signal("john@example.com");

const fullName = signal(
  { firstName, lastName },
  ({ deps }) => `${deps.firstName} ${deps.lastName}`
);

const userProfile = signal({ firstName, lastName, email }, ({ deps }) => ({
  name: `${deps.firstName} ${deps.lastName}`,
  email: deps.email,
  initials: deps.firstName[0] + deps.lastName[0],
}));
```

**Async computed:**

```tsx
const userId = signal(1);
const userData = signal({ userId }, async ({ deps, abortSignal }) => {
  const res = await fetch(`/users/${deps.userId}`, {
    signal: abortSignal, // Auto-cancels when userId changes
  });
  return res.json();
});
```

---

#### Overload 3b: Computed Signal with Equality Shortcut

```tsx
const fullName = signal(
  { firstName, lastName },
  ({ deps }) => ({ full: `${deps.firstName} ${deps.lastName}` }),
  "shallow"
);
```

**When to use:**

- Computed signals that return objects/arrays
- Need custom equality without full options
- Performance optimization

**âš ï¸ Important:** Custom equality functions NOT allowed as third arg (use options form)

---

#### Overload 3c: Computed Signal with Options

```tsx
const doubled = signal({ count }, ({ deps }) => deps.count * 2, {
  name: "doubled",
  equals: (a, b) => a === b,
  fallback: (error) => 0,
  onChange: (value) => console.log("Computed:", value),
  lazy: false, // Compute immediately
});
```

---

### 2. Signal Instance Methods

All signals have these properties and methods:

#### `.uid` - Unique Identifier â­ NEW

Every signal has a unique ID that is auto-generated and immutable:

```tsx
const count = signal(0);
console.log(count.uid); // "sig-1"

const doubled = signal({ count }, ({ deps }) => deps.count * 2);
console.log(doubled.uid); // "sig-2"

// Use as React key
signals.map((s) => <div key={s.uid}>{s.displayName}</div>);
```

**Key characteristics:**

- Auto-generated on signal creation
- Immutable - never changes for the lifetime of the signal
- Unique across all signals in the application
- Format: `"sig-{n}"` (e.g., "sig-1", "sig-42")

---

#### `.get()` or `signal()` - Read Value

```tsx
const value = count.get();
const value = count(); // Shorthand
```

**âš ï¸ Important:** Reading a signal DOES NOT subscribe to changes!

```tsx
// This won't re-run when count changes:
const doubled = count() * 2; // âŒ Static snapshot

// Use computed signal instead:
const doubled = signal({ count }, ({ deps }) => deps.count * 2); // âœ…
```

---

#### `.peek()` - Read Value Without Tracking â­ NEW

Read the current value **without** triggering reactive tracking:

```tsx
const value = count.peek();
```

**When to use:**

- In event handlers where you don't want to create dependencies
- Logging/debugging without affecting reactivity
- Internal reads in computed signals that shouldn't trigger updates
- Any place where you need the value but don't want reactive subscription

**Examples:**

```tsx
// In a tracking context, peek() won't create dependencies
rx(() => {
  // This WILL create a dependency (triggers re-render when count changes)
  console.log("Count:", count());

  // This WON'T create a dependency (no re-render when user changes)
  console.log("User (peeked):", user.peek());
});

// Useful in event handlers
const handleClick = () => {
  const currentCount = count.peek(); // Read without tracking
  console.log("Current count:", currentCount);
};

// Internal reads in operators/plugins
const operator = (source) => {
  // Use peek() to avoid creating unwanted dependencies
  const initialValue = source.peek();
  // ...
};
```

**Key differences from `.get()`:**

- `.get()` / `signal()` - triggers `onSignalAccess` in render hooks (creates dependencies)
- `.peek()` - never triggers tracking (safe for internal use)

---

#### `.set(value)` - Update Value (Mutable Only)

```tsx
// Direct value
count.set(5);

// Updater function
count.set((prev) => prev + 1);
```

---

#### `.reset()` - Reset to Initial Value (Mutable Only)

```tsx
const count = signal(0);
count.set(10);
count.reset(); // Back to 0
```

---

#### `.on(callback)` - Subscribe to Changes

```tsx
const unsubscribe = count.on(() => {
  console.log("Count changed to:", count());
});

// Later: cleanup
unsubscribe();
```

---

#### `.to(selector, equals?)` - Transform Signal Value â­ NEW

The `.to()` method is the **recommended way** to transform a single signal:

```tsx
const count = signal(5);
const doubled = count.to((x) => x * 2); // Creates computed signal
const formatted = count.to((x) => `Count: ${x}`);
```

**With equality:**

```tsx
const userName = user.to((u) => u.name, "shallow");
const userData = user.to((u) => u.data, "deep");
```

**Shorthand for:**

```tsx
const doubled = signal({ count }, ({ deps }) => deps.count * 2);
```

---

#### `.pipe(...operators)` - Chain Operators â­ NEW

```tsx
import { to, filter, scan } from "rextive/op";

const result = count.pipe(
  filter((x) => x > 0),
  to((x) => x * 2),
  scan((acc, x) => acc + x, 0)
);
```

---

#### `.refresh()` - Force Immediate Recomputation â­ NEW

```tsx
userData.refresh(); // Triggers recomputation now
```

---

#### `.stale()` - Mark for Lazy Recomputation â­ NEW

```tsx
userData.stale(); // Will recompute on next access
```

---

#### `.error()` / `.tryGet()` - Safe Error Access â­ NEW

For **synchronous errors** during signal computation:

```tsx
const error = signal.error(); // Get sync error without throwing
const value = signal.tryGet(); // Get value or undefined (never throws)
```

**âš ï¸ For async signals**: Use `task.from()` to access error states:

```tsx
// Async signal returns a Promise
const asyncData = signal(async () => fetchData());

// Access async state via task.from()
const promise = asyncData();
const state = task.from(promise);
// state.loading, state.error, state.value

// In React with rx()
{
  rx(() => {
    const state = task.from(asyncData());
    if (state.loading) return <Spinner />;
    if (state.error) return <Error error={state.error} />;
    return <div>{state.value}</div>;
  });
}
```

---

#### `.pause()` / `.resume()` / `.paused()` - Control Computed (Computed Only)

```tsx
const computed = signal({ count }, ({ deps }) => deps.count * 2);

computed.pause(); // Stop recomputing
count.set(10); // computed doesn't update

computed.paused(); // true

computed.resume(); // Resume recomputing (recalculates now)
```

---

#### `.dispose()` - Clean Up Signal

```tsx
count.dispose();
```

**âš ï¸ Critical:** Always dispose signals you create to prevent memory leaks!

---

#### `.when()` - React to Other Signals â­ NEW

React to changes in other signals by triggering actions.

**Overload 1: Action String (for both Mutable and Computed)**

```tsx
const refreshTrigger = signal(0);
const userData = signal({ name: "John" });

// Refresh when trigger changes
userData.when(refreshTrigger, "refresh");

// Reset when trigger changes (mutable only)
userData.when(refreshTrigger, "reset");

// With filter - only trigger when condition is met
// Filter receives (notifier, self)
userData.when(refreshTrigger, "refresh", (notifier, self) => notifier() > 5);
```

**Overload 2: Action Callback (for both Mutable and Computed)**

```tsx
const increment = signal(0);
const counter = signal(0);

// Action callback receives (notifier, self) and returns void
// Use self.set() to update the value
counter.when(increment, (notifier, self) => {
  self.set((prev) => prev + notifier());
});
```

**For Computed Signals:**

```tsx
const refreshTrigger = signal(0);
const fetchedData = signal({ userId }, async ({ deps }) =>
  fetchUser(deps.userId)
);

// Action string: "refresh" or "stale"
fetchedData.when(refreshTrigger, "refresh");
fetchedData.when(refreshTrigger, "stale");

// Action callback: use self.refresh() or self.stale()
fetchedData.when(refreshTrigger, (notifier, self) => {
  if (notifier() > 0) {
    self.refresh();
  }
});

// Note: "reset" is NOT supported for computed signals
```

**Multiple Notifiers:**

```tsx
const trigger1 = signal(0);
const trigger2 = signal(0);

// React to any of multiple signals
userData.when([trigger1, trigger2], "refresh");

// Filter receives (notifier, self) - notifier is the one that triggered
userData.when([trigger1, trigger2], "refresh", (notifier, self) => {
  return notifier() > 0;
});

// Action callback receives (notifier, self)
userData.when([trigger1, trigger2], (notifier, self) => {
  console.log("Triggered by:", notifier());
  self.refresh();
});
```

**Chaining:**

```tsx
// .when() returns this for chaining
userData.when(refreshTrigger, "refresh").when(resetTrigger, "reset");
```

**Action Dispatch Pattern with `.tuple`:**

```tsx
type TodoAction = { type: "add"; text: string } | { type: "edit"; id: number };

// Use .tuple to get [signal, setter] for semantic naming
const [todoAction, dispatch] = signal<TodoAction>().tuple;

// React to actions
todoList.when(todoAction, (action) => {
  const a = action();
  if (a?.type === "add") addTodo(a.text);
  if (a?.type === "edit") editTodo(a.id);
});

// Dispatch actions
dispatch({ type: "add", text: "Buy milk" });
dispatch({ type: "edit", id: 1 });
```

**Cleanup:**

Subscriptions created by `.when()` are automatically cleaned up when the signal is disposed.

**âš ï¸ Error Handling:**

```tsx
// Filter errors - action is NOT executed, error routed to signal's onError
userData.when(trigger, "refresh", (notifier, self) => {
  if (notifier() < 0) throw new Error("Invalid"); // Action skipped, onError called
  return true;
});

// Action callback errors - routed through signal's error handling
counter.when(increment, (notifier, self) => {
  if (notifier() < 0) throw new Error("Negative not allowed");
  self.set((prev) => prev + notifier());
});
```

**âš ï¸ Common Pitfalls:**

```tsx
// âŒ BAD - Circular dependency
const a = signal(0);
const b = signal(0);
a.when(b, (notifier, self) => self.set(notifier())); // a depends on b
b.when(a, (notifier, self) => self.set(notifier())); // b depends on a - INFINITE LOOP!

// âŒ BAD - "reset" on computed signals (TypeScript error)
computed.when(trigger, "reset"); // Use "refresh" or "stale" instead
```

---

### 3. Compute Function Context

For computed signals, the compute function receives a context object:

```tsx
signal({ userId, filter }, (context) => {
  context.deps; // Dependency values
  context.abortSignal; // AbortSignal for cancellation
});
```

#### Context Methods â­ NEW

```tsx
signal(async (context) => {
  // Safe execution (throws if aborted)
  const data = context.safe(() => processData());

  // Safe promise (never resolves if aborted)
  await context.safe(wait.delay(300));

  // Register cleanup
  context.onCleanup(() => cleanup());

  // Check if aborted
  if (context.aborted()) return null;

  // Reuse logic with context
  const result = await context.use(fetchUser, options);

  // Trigger recomputation (polling)
  setTimeout(() => context.refresh(), 1000);

  // Mark stale (TTL cache)
  setTimeout(() => context.stale(), 5 * 60 * 1000);
});
```

---

### 4. Static Methods

#### `signal.batch(fn)` - Batch Multiple Updates

```tsx
signal.batch(() => {
  firstName.set("Jane");
  lastName.set("Smith");
  email.set("jane@example.com");
});
// Only ONE notification!
```

---

#### `signal.on(signals, callback)` - Subscribe to Multiple Signals

```tsx
const control = signal.on([count, name], (trigger) => {
  console.log("Changed:", trigger());
});

control.pause(); // Pause
control.resume(); // Resume
control.dispose(); // Cleanup
```

---

#### `signal.tag()` - Create a Tag for Grouping

```tsx
const formTag = signal.tag();

const name = signal("", { use: [formTag] });
const email = signal("", { use: [formTag] });

formTag.forEach((s) => s.reset()); // Reset all
formTag.map((s) => s.get()); // Collect values
formTag.size; // Count
```

---

#### `signal.from(signals)` - Combine Signals

```tsx
// Record form
const user = signal.from({ name, age });
console.log(user()); // { name: "...", age: ... }

// Tuple form
const coords = signal.from([x, y]);
console.log(coords()); // [10, 20]
```

---

#### `signal.trace(error)` - Get Error Trace â­ NEW

```tsx
try {
  dashboard();
} catch (error) {
  const traces = signal.trace(error);
  // [{ signal: "db", when: "compute:initial", async: true }, ...]

  const errorPath = traces.map((t) => t.signal).join(" â†’ ");
  console.log("Error path:", errorPath);
}
```

---

### 5. `rx()` - React Integration

The `rx()` function has **4 overloads** for reactive rendering in React.

#### Overload 1: Single Signal

```tsx
const count = signal(42);
{
  rx(count);
} // Renders: 42
```

---

#### Overload 2: Single Signal with Property/Selector

```tsx
const user = signal({ name: "Alice", age: 30 });

// Property access
{
  rx(user, "name");
} // Renders: "Alice"

// Selector function
{
  rx(user, (u) => u.age + 5);
} // Renders: 35
```

---

#### Overload 3: Reactive Function (Auto-Tracking)

```tsx
{
  rx(() => <div>Count: {count()}</div>);
}
```

**How it works:**

- Signals accessed inside the function are automatically tracked
- Re-renders when any tracked signal changes

---

#### Overload 4: Component with Reactive Props

```tsx
{
  rx(Component, { prop1: signal1, prop2: "static" });
}
{
  rx("div", { children: count, className: "counter" });
}
```

---

#### âš ï¸ Important `rx()` Warnings

**âŒ NEVER use `rx()` directly in element attributes!**

```tsx
// âŒ WRONG - Won't be reactive!
<input value={rx(signal)} />
<div className={rx(theme)} />
```

**âœ… CORRECT - Use one of these instead:**

```tsx
// Option 1: Wrap entire element with rx(fn)
{
  rx(() => <input value={signal()} />);
}

// Option 2: Use component form rx(Component, props)
{
  rx("input", { value: signal });
}
```

---

#### `rx.use()` - Reactive Hook â­ NEW

Low-level hook for automatic signal tracking.

**â­ Auto-Dispose Feature**: Like `useScope()`, signals created inside `rx.use()` are **automatically disposed** on unmount.

```tsx
function Component() {
  const value = rx.use(() => {
    const userData = wait(user());
    const postList = wait(posts());
    return { userData, postList };
  });

  return <div>{value.userData.name}</div>;
}
```

---

### 6. `useScope()` - Component Lifecycle

#### Mode 1: Factory (Most Common)

**â­ Auto-Dispose Feature**: Signals created inside the factory are **automatically disposed** when the component unmounts or deps change. No need for explicit `disposable()` wrapper!

```tsx
function TodoList() {
  // âœ… Signals are auto-disposed on unmount - no disposable() needed!
  const scope = useScope(() => {
    const todos = signal([]);
    const filter = signal("all");

    return {
      todos,
      filter,
      addTodo: (text) => todos.set((prev) => [...prev, text]),
    };
  });

  return <div>{rx(scope.todos, (t) => t.length)} todos</div>;
}
```

**Note**: For additional cleanup beyond signals:

```tsx
// Simple case - just add dispose() method
const scope = useScope(() => {
  const todos = signal([]);
  const subscription = someExternalService.subscribe();

  return {
    todos,
    dispose: () => subscription.unsubscribe(),
  };
});

// Multiple cleanup logic - use disposable() to combine them
const scope = useScope(() => {
  const todos = signal([]);
  const sub1 = service1.subscribe();
  const sub2 = service2.subscribe();
  const timer = setInterval(() => {}, 1000);

  return disposable({
    todos,
    dispose: [sub1, sub2, () => clearInterval(timer)],
  });
});
```

---

#### Mode 2: Lifecycle

```tsx
useScope({
  init: () => console.log("Before first render"),
  mount: () => console.log("After first paint"),
  render: () => console.log("Every render"),
  cleanup: () => console.log("React cleanup"),
  dispose: () => console.log("True unmount"),
});
```

---

#### Mode 3: Object Tracking

```tsx
useScope({
  for: user,
  init: (user) => analytics.track("session-start", user),
  dispose: (user) => analytics.track("session-end", user),
});
```

---

#### Options

```tsx
useScope(factory, {
  watch: [dep1, dep2], // Recreate when deps change
  update: [(scope) => scope.refresh(), dep], // Run effect on deps change
});
```

---

### 7. `provider()` - Signal Context â­ NEW

Create signal-based React Context:

```tsx
const [useTheme, ThemeProvider] = provider({
  name: "Theme",
  create: (initialValue: "dark" | "light") => {
    return signal(initialValue);
  },
});

function App() {
  return (
    <ThemeProvider value="dark">
      <ChildComponent />
    </ThemeProvider>
  );
}

function ChildComponent() {
  const theme = useTheme();
  return <div>Theme: {rx(theme)}</div>;
}
```

---

### 8. Async Utilities

#### `wait()` / `wait.all()` - Wait for All

```tsx
// Suspense mode (throws for Suspense)
const value = wait(promise);
const [a, b] = wait([p1, p2]);
const { user, posts } = wait({ user: p1, posts: p2 });

// Promise mode
await wait(promise, (value) => processValue(value));
```

#### `wait.any()` - First to Resolve

```tsx
const [value, key] = wait.any({ fast, slow });
```

#### `wait.race()` - First to Settle

```tsx
const [value, key] = wait.race({ p1, p2 });
```

#### `wait.settled()` - All Settled (Never Throws)

```tsx
const results = wait.settled([p1, p2, p3]);
```

#### `wait.timeout()` - With Timeout

```tsx
const data = await wait.timeout(fetchData(), 5000);
```

#### `wait.delay()` - Simple Delay

```tsx
await wait.delay(1000);
```

---

### 9. `task.from()` - Async State Access

Async signals return Promises. Use `task.from()` to access loading/error/success states:

```tsx
const promise = asyncSignal();
const state = task.from(promise);

state.status; // "loading" | "success" | "error"
state.loading; // boolean
state.value; // resolved value
state.error; // error if rejected
```

**React usage:**

```tsx
{
  rx(() => {
    const state = task.from(userData());
    if (state.loading) return <Spinner />;
    if (state.error) return <Error error={state.error} />;
    return <div>{state.value.name}</div>;
  });
}
```

**Key points:**

- Async signals return the **Promise itself** as their value
- Subscribers are **notified when the Promise settles** (resolve or reject)
- Use `task.from()` to check the Promise's current state
- The `onError` callback is for **sync errors only** (during computation)

---

### 10. Operators (`rextive/op`) â­ NEW

```tsx
import { to, filter, scan, focus, debounce, throttle, pace } from "rextive/op";
```

#### `to()` - Transform Values

```tsx
const doubled = count.pipe(to((x) => x * 2));
```

#### `filter()` - Filter Values

```tsx
const positiveOnly = count.pipe(filter((x) => x > 0));
```

#### `scan()` - Accumulate Values

```tsx
const total = count.pipe(scan((acc, curr) => acc + curr, 0));
```

#### `focus()` - Bidirectional Lens for Nested Properties

Create a bidirectional mutable signal for a nested property path:

```tsx
// Basic usage with dot-notation
const form = signal({ user: { name: "Alice" } });
const userName = form.pipe(focus("user.name"));
console.log(userName()); // "Alice"
userName.set("Bob"); // Updates source immutably

// With fallback (for optional properties)
type User = { name: string; nickname?: string };
const user = signal<User>({ name: "Alice" });

// Without fallback - type is string | undefined
const nickname = user.pipe(focus("nickname"));

// With fallback - type is string (guaranteed non-nullable)
const nicknameDefault = user.pipe(focus("nickname", () => "Guest"));
console.log(nicknameDefault()); // "Guest"

// With options
const price = form.pipe(
  focus("price", {
    get: (v) => v * 1.1, // Transform on read
    set: (v) => v / 1.1, // Transform on write
    equals: "shallow",
  })
);

// Fallback + options
const theme = user.pipe(
  focus("settings.theme", () => "light", { name: "userTheme" })
);
```

**Overloads:**

- `focus(path, options?)` â†’ `Mutable<PathValue<T, P>>` (may include undefined)
- `focus(path, fallback, options?)` â†’ `Mutable<F>` (F = fallback return type, non-nullable)

**Fallback behaviors:**

- Called only for `null` or `undefined` values
- **Memoized** - factory called only once
- `0`, `""`, `false` are NOT nullish (no fallback used)

#### `debounce()` - Debounce Updates

```tsx
const debouncedSearch = searchInput.pipe(debounce(300));
```

#### `throttle()` - Throttle Updates

```tsx
const throttledPosition = mousePosition.pipe(throttle(100));
```

#### `pace()` - Rate Limit Updates

```tsx
const pacedData = fastData.pipe(pace(1000));
```

#### `task()` - Async State with Stale-While-Revalidate â­ NEW

Creates a task signal that ensures `value` is always defined (never undefined):

```tsx
import { task } from "rextive/op";

const userProfile = signal(async () => fetchUser());
const userTask = userProfile.pipe(task({ name: "Guest" }));
```

**Stale-while-revalidate pattern:**

- **First load**: Uses `initial` value while loading
- **Loading after success**: Shows previous successful value (stale data)
- **Success**: Shows current value (fresh data)

```tsx
const DEFAULT_USER = { id: 0, name: "Loading..." };

const userProfileTask = userProfileAsync.pipe(task(DEFAULT_USER));

function UserProfile() {
  return rx(() => {
    const { loading, error, value } = userProfileTask();
    // âœ… value is ALWAYS defined - never undefined!
    return (
      <div>
        {loading && <Spinner />}
        <h2>{value.name}</h2>
        {error && <ErrorToast error={error} />}
      </div>
    );
  });
}
```

**With options:**

```tsx
const userTask = userProfile.pipe(task(DEFAULT_USER, { name: "userTask" }));
```

#### `refreshOn()` - Trigger Immediate Recomputation

Triggers `.refresh()` on a computed signal when notifier(s) change:

```tsx
import { refreshOn } from "rextive/op";

const refreshTrigger = signal(0);
const userData = asyncSignal.pipe(refreshOn(refreshTrigger));

// Click to refresh immediately
<button onClick={() => refreshTrigger.set((v) => v + 1)}>Refresh</button>;
```

**With filter:**

```tsx
const networkStatus = signal<"online" | "offline">("online");

// Only refresh when coming back online
const data = asyncSignal.pipe(
  refreshOn(networkStatus, (status) => status() === "online")
);
```

#### `staleOn()` - Mark for Lazy Recomputation

Marks a computed signal as stale when notifier(s) change (recomputes on next access):

```tsx
import { staleOn } from "rextive/op";

const cacheInvalidate = signal(0);
const userData = asyncSignal.pipe(staleOn(cacheInvalidate));

// Mark data as stale (won't refetch until accessed)
cacheInvalidate.set((v) => v + 1);
```

**Use `staleOn` vs `refreshOn`:**

- `refreshOn` - Immediate recomputation (use for active data)
- `staleOn` - Lazy recomputation (use for cached/background data)

#### `resetOn()` - Reset Mutable Signal to Initial Value

Triggers `.reset()` on a mutable signal when notifier(s) change:

```tsx
import { resetOn } from "rextive/op";

const clearTrigger = signal<void>();
const formData = signal({ name: "", email: "" }).pipe(resetOn(clearTrigger));

// Reset form after submission
<button
  onClick={() => {
    submitForm(formData());
    clearTrigger.set(undefined as void);
  }}
>
  Submit & Clear
</button>;
```

**With filter:**

```tsx
const routeChange = signal<string>("/home");

// Reset filters when navigating away from /products
const productFilters = signal({ category: "all", sort: "name" }).pipe(
  resetOn(routeChange, (route) => !route().startsWith("/products"))
);
```

**Note:** Only works with **mutable signals** (not computed).

---

### 11. Plugins (`rextive/plugins`) â­ NEW

#### `persistor` - Auto-Persistence

```tsx
import { persistor } from "rextive/plugins";

const persist = persistor<{ theme: string; fontSize: number }>({
  load: () => JSON.parse(localStorage.getItem("settings") || "{}"),
  save: (args) => {
    const existing = JSON.parse(localStorage.getItem("settings") || "{}");
    localStorage.setItem(
      "settings",
      JSON.stringify({ ...existing, ...args.values })
    );
  },
});

const theme = signal("dark", { use: [persist("theme")] });
```

---

### 12. Immer Integration (`rextive/immer`) â­ NEW

```tsx
import { produce } from "rextive/immer";

const state = signal({ count: 0, user: { name: "John" } });

// Write "mutations" that are actually immutable
state.set(
  produce((draft) => {
    draft.count++;
    draft.user.name = "Jane";
  })
);
```

---

### 13. Cache (`rextive/cache`) â­ NEW

```tsx
import { cache, staleOn, evictOn, lru } from "rextive/cache";

const getUser = cache("users", async (userId: string) => {
  const res = await fetch(`/api/users/${userId}`);
  return res.json();
});

// Access cached data
const { value, unref } = getUser("123");
const user = await value;

// Release reference when done
unref();

// Cache methods
getUser.stale("123"); // Mark stale
getUser.refresh("123"); // Force re-fetch
getUser.delete("123"); // Remove
getUser.clear(); // Clear all
```

---

### 14. DevTools (`rextive/devtools`) â­ NEW

```tsx
import { enableDevTools, DevToolsPanel } from "rextive/devtools";

// Enable devtools
enableDevTools();

// Add panel to your app
function App() {
  return (
    <div>
      <YourApp />
      {process.env.NODE_ENV === "development" && <DevToolsPanel />}
    </div>
  );
}
```

---

### 15. Utilities

#### `disposable(obj)` - Create Disposable â­ NEW

```tsx
const scope = disposable({
  count: signal(0),
  doubled: count.to((x) => x * 2),
});
// Automatically adds dispose array
```

#### `awaited(...selectors)` - Transform Async Values â­ NEW

```tsx
const titles = todoList.to(
  awaited(
    (todos) => todos.filter((t) => !t.done),
    (todos) => todos.map((t) => t.title)
  )
);
```

#### `emitter()` - Event Emitter

```tsx
const events = emitter<string>();
events.on((value) => console.log(value));
events.emit("hello");
events.dispose();
```

---

### 16. `logic()` - Reusable Logic Units

Create reusable, testable logic units that encapsulate signals and actions:

```tsx
import { logic, signal } from "rextive";

export const counterLogic = logic("counterLogic", () => {
  const count = signal(0, { name: "counter.count" });
  const doubled = count.to((x) => x * 2, { name: "counter.doubled" });

  const increment = () => count.set((x) => x + 1);
  const decrement = () => count.set((x) => x - 1);
  const reset = () => count.reset();

  return {
    count,
    doubled,
    increment,
    decrement,
    reset,
  };
});
```

#### Logic Structure

A well-organized logic follows this structure:

```ts
export const myLogic = logic("myLogic", () => {
  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  // 1. DEPENDENCIES - Import other logics (at factory level!)
  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  const $auth = authLogic(); // Shared singleton
  const $config = configLogic(); // Shared singleton

  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  // 2. STATE - Signals and computed values
  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  const items = signal<Item[]>([], { name: "myLogic.items" });
  const filter = signal("all", { name: "myLogic.filter" });

  // Computed signals
  const filtered = signal(
    { items, filter },
    ({ deps }) => deps.items.filter(/* ... */),
    { name: "myLogic.filtered" }
  );
  const count = items.to((list) => list.length, { name: "myLogic.count" });

  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  // 3. SIDE EFFECTS - Subscriptions, timers, external resources
  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  const socket = new WebSocket($config.wsUrl);
  const interval = setInterval(() => refresh(), 60000);

  // Signal subscriptions
  $auth.user.on(() => {
    if (!$auth.user()) items.reset();
  });

  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  // 4. METHODS - Actions and business logic
  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  const add = (item: Item) => {
    items.set((prev) => [...prev, item]);
  };

  const remove = (id: string) => {
    items.set((prev) => prev.filter((i) => i.id !== id));
  };

  const refresh = async () => {
    const data = await fetch("/api/items");
    items.set(await data.json());
  };

  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  // 5. RETURN - Public API + cleanup
  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  return {
    // State (read-only or mutable as needed)
    items,
    filter,
    filtered,
    count,

    // Methods
    add,
    remove,
    refresh,

    // Cleanup (optional - for external resources)
    dispose: () => {
      socket.close();
      clearInterval(interval);
      // Note: Signals are auto-disposed, no need to dispose them manually
    },
  };
});
```

**Section Breakdown:**

| Section          | Purpose              | Guidelines                                             |
| ---------------- | -------------------- | ------------------------------------------------------ |
| **Dependencies** | Import other logics  | Always at factory level, not inside methods            |
| **State**        | Signals & computed   | Name signals for debugging: `{ name: "logic.signal" }` |
| **Side Effects** | External resources   | WebSockets, timers, event listeners, subscriptions     |
| **Methods**      | Business logic       | Keep pure when possible, use signals for state         |
| **Return**       | Public API + cleanup | Include `dispose()` if you have side effects           |

**âš ï¸ Common Mistakes:**

```ts
// âŒ BAD: Getting logic inside a method (stale reference risk)
const myLogic = logic("myLogic", () => {
  const doSomething = () => {
    const $auth = authLogic(); // âŒ Called on every invocation
    return $auth.user();
  };
  return { doSomething };
});

// âœ… GOOD: Get logic at factory level
const myLogic = logic("myLogic", () => {
  const $auth = authLogic(); // âœ… Called once during initialization

  const doSomething = () => {
    return $auth.user(); // Uses captured reference
  };
  return { doSomething };
});
```

```ts
// âŒ BAD: Forgetting to clean up external resources
const myLogic = logic("myLogic", () => {
  const socket = new WebSocket("wss://...");
  // No dispose! Memory leak when instance is disposed
  return {
    /* ... */
  };
});

// âœ… GOOD: Clean up external resources
const myLogic = logic("myLogic", () => {
  const socket = new WebSocket("wss://...");
  return {
    /* ... */
    dispose: () => socket.close(),
  };
});
```

```ts
// âŒ BAD: Disposing shared logics
const myLogic = logic("myLogic", () => {
  const $auth = authLogic(); // Singleton - shared!
  return {
    dispose: () => {
      $auth.dispose(); // âŒ Don't dispose shared logics!
    },
  };
});

// âœ… GOOD: Only dispose what you own
const myLogic = logic("myLogic", () => {
  const $auth = authLogic(); // Shared - DON'T dispose
  const tabs = [tabLogic.create()]; // Owned - MUST dispose

  return {
    dispose: () => {
      tabs.forEach((t) => t.dispose()); // âœ… Dispose owned only
    },
  };
});
```

#### Naming Conventions

**âœ… Logic Name (first parameter):**

Always use `Logic` postfix in the logic name string:

```tsx
// âœ… GOOD
logic("authLogic", () => { ... });
logic("cartLogic", () => { ... });
logic("checkout.shippingLogic", () => { ... });

// âŒ BAD
logic("auth", () => { ... });
logic("cart", () => { ... });
```

**âœ… Variable/Export Name:**

Always use `Logic` postfix:

```tsx
// âœ… GOOD
export const authLogic = logic("authLogic", () => { ... });
export const cartLogic = logic("cartLogic", () => { ... });

// âŒ BAD
export const auth = logic("authLogic", () => { ... });
```

**âœ… File Name:**

Use `Logic` postfix in file names:

```
âœ… GOOD
src/logic/authLogic.ts
src/logic/cartLogic.ts
src/logic/checkout/shippingLogic.ts

âŒ BAD
src/logic/auth.ts
src/logic/cart.ts
```

#### Consumer Convention: `$` Prefix

When consuming logic instances, use `$` prefix to distinguish logic instances from local variables:

```tsx
// âœ… GOOD - Clear distinction
export function UserMenu() {
  const $auth = authLogic();
  const $cart = cartLogic();

  return rx(() => {
    const user = $auth.user();
    const itemCount = $cart.itemCount();
    return (
      <div>
        {user?.name} ({itemCount})
      </div>
    );
  });
}

// âŒ BAD - Ambiguous naming
export function UserMenu() {
  const auth = authLogic(); // Easy to confuse with local 'auth' object
  const cart = cartLogic();

  return rx(() => {
    const user = auth.user();
    return <div>{user?.name}</div>;
  });
}
```

**When to use `$` prefix:**

- âœ… When storing the full logic instance: `const $auth = authLogic();`
- âŒ NOT when destructuring: `const { user, logout } = authLogic();` (destructured values are not logic instances)

**Mixed usage:**

```tsx
// âœ… GOOD - $prefix for full instance, no prefix for destructured
export function OrderReview() {
  const $shipping = shippingLogic();
  const $payment = paymentLogic();
  const $order = orderLogic();
  const { goToStep, prevStep } = checkoutLogic(); // Destructured actions

  return rx(() => {
    const info = $shipping.info();
    const method = $payment.method();
    const total = $order.total();
    // ...
  });
}
```

#### Logic Within Logic

When consuming logic from another logic, use the same `$` prefix convention:

```tsx
export const checkoutLogic = logic("checkoutLogic", () => {
  // Get child logics with $ prefix
  const $shipping = shippingLogic();
  const $payment = paymentLogic();
  const $order = orderLogic();

  const open = () => {
    $shipping.prefillFromUser();
    $order.reset();
    // ...
  };

  const placeOrder = async () => {
    await $order.placeOrder();
    // ...
  };

  return {
    open,
    placeOrder,
    // ...
  };
});
```

#### Splitting Logic by Concern

For complex features, split logic into focused units:

```
src/logic/checkout/
â”œâ”€â”€ types.ts           # Shared types and constants
â”œâ”€â”€ shippingLogic.ts   # Shipping form state & validation
â”œâ”€â”€ paymentLogic.ts    # Payment method selection
â”œâ”€â”€ orderLogic.ts      # Order totals & placement
â”œâ”€â”€ checkoutLogic.ts   # Flow coordinator
â””â”€â”€ index.ts           # Barrel exports
```

**Coordinator pattern:**

```tsx
// checkoutLogic.ts - coordinates child logics
export const checkoutLogic = logic("checkoutLogic", () => {
  const $shipping = shippingLogic();
  const $payment = paymentLogic();
  const $order = orderLogic();

  // Only exposes flow control, not child state
  return {
    isOpen,
    currentStep,
    open,
    close,
    nextStep,
    prevStep,
    placeOrder,
    reset,
  };
});
```

**Components access step logics directly:**

```tsx
// ShippingForm.tsx - uses shippingLogic directly
export function ShippingForm() {
  const $shipping = shippingLogic();
  const { nextStep } = checkoutLogic(); // Only navigation from coordinator

  return rx(() => {
    const info = $shipping.info();
    const isValid = $shipping.isValid();
    // ...
  });
}
```

#### Testing Logic

**Option 1: Using `mockLogic` (Recommended for React Components)**

```tsx
import { signal } from "rextive";
import { mockLogic } from "rextive/test";
import { vi } from "vitest";

describe("UserMenu", () => {
  const $auth = mockLogic(authLogic);

  beforeEach(() => {
    $auth.default({
      user: signal(null),
      isRestoring: signal(false),
      logout: vi.fn(),
      openLoginModal: vi.fn(),
    });
  });

  afterEach(() => {
    $auth.clear();
  });

  it("should show Sign In when not authenticated", () => {
    $auth.provide({ user: signal(null) });
    render(<UserMenu />);
    expect(screen.getByText("Sign In")).toBeInTheDocument();
  });

  it("should call logout when clicked", () => {
    const mock = $auth.provide({
      user: signal({ id: 1, name: "John" }),
      logout: vi.fn(),
    });
    render(<UserMenu />);
    fireEvent.click(screen.getByTitle("Logout"));
    expect(mock.logout).toHaveBeenCalledTimes(1);
  });
});
```

**`mockLogic` API:**

| Method               | Description                                       |
| -------------------- | ------------------------------------------------- |
| `.default(partial)`  | Set default mock values (merged with overrides)   |
| `.provide(partial?)` | Apply mock to logic registry, returns merged mock |
| `.clear()`           | Clear defaults, overrides, and logic registry     |

**Option 2: Using `logic.provide()` (For Logic Unit Tests)**

```tsx
import { logic, signal } from "rextive";
import { vi } from "vitest";

describe("userStore", () => {
  afterEach(() => {
    logic.clear();
  });

  it("should fetch user with overridden API", async () => {
    logic.provide(apiClient, () => ({
      get: vi.fn().mockResolvedValue({ id: 1, name: "John" }),
      post: vi.fn(),
    }));

    const store = logic.create(userStore);
    await store.fetchUser("1");

    expect(store.user()).toEqual({ id: 1, name: "John" });
  });
});
```

**When to Use Each:**

| Scenario                     | Recommended                             |
| ---------------------------- | --------------------------------------- |
| Testing React components     | `mockLogic()` from `rextive/test`       |
| Testing logic units directly | `logic.provide()` + `logic.create()`    |
| Library/SDK testing          | `logic.provide()` with partial override |

---

## ğŸ¨ Advanced Patterns

### Pattern 1: Single Dependency - Transform with `.to()`

When you need to **transform one signal** into another:

```tsx
const count = signal(0);

// Transform it with .to()
const doubled = count.to((x) => x * 2);
const formatted = count.to((x) => `Count: ${x}`);
```

---

### Pattern 2: Multiple Dependencies - Combine Signals

When you need to **combine multiple signals**:

```tsx
const firstName = signal("John");
const lastName = signal("Doe");

const fullName = signal(
  { firstName, lastName },
  ({ deps }) => `${deps.firstName} ${deps.lastName}`
);
```

---

### Pattern 3: Async with Dependencies

```tsx
const userId = signal(1);

const user = signal({ userId }, async ({ deps, abortSignal }) => {
  const response = await fetch(`/api/users/${deps.userId}`, {
    signal: abortSignal, // Automatically cancels previous request
  });
  return response.json();
});
```

---

### Pattern 4: Chain Multiple Operators

```tsx
import { to, filter, scan } from "rextive/op";

const result = count.pipe(
  filter((x) => x > 0),
  to((x) => x * 2),
  scan((acc, x) => acc + x, 0)
);
```

---

### Pattern 5: Debounced Search

```tsx
function SearchBox() {
  const scope = useScope(() => {
    const searchInput = signal("");

    const results = signal(
      { searchInput },
      async ({ deps, abortSignal, safe }) => {
        const query = deps.searchInput.trim();
        if (!query || query.length < 2) return [];

        // Debounce: wait 300ms
        await safe(wait.delay(300));

        const res = await fetch(`/api/search?q=${query}`, {
          signal: abortSignal,
        });
        return res.json();
      }
    );

    return disposable({ searchInput, results });
  });

  return (
    <div>
      <input onChange={(e) => scope.searchInput.set(e.target.value)} />
      {rx(() => {
        const state = task.from(scope.results());
        if (state.loading) return <div>Searching...</div>;
        return (
          <ul>
            {state.value.map((item) => (
              <li key={item.id}>{item.name}</li>
            ))}
          </ul>
        );
      })}
    </div>
  );
}
```

---

### Pattern 6: Batch Updates

```tsx
signal.batch(() => {
  firstName.set("Jane");
  lastName.set("Smith");
  email.set("jane@example.com");
});
// Only ONE notification!
```

---

### Pattern 7: Group Signals with Tags

```tsx
const formTag = signal.tag();

const name = signal("", { use: [formTag] });
const email = signal("", { use: [formTag] });
const message = signal("", { use: [formTag] });

// Reset all form fields at once
formTag.forEach((s) => s.reset());
```

---

### Pattern 8: Notifier / Action Dispatcher

Use `signal<T>()` (empty signal) as an action dispatcher or event bus:

```tsx
// Action dispatcher pattern
type Action =
  | { type: "login"; username: string; password: string }
  | { type: "logout" }
  | { type: "refresh" };

const action = signal<Action>();

// Subscribe to actions
action.on(() => {
  const a = action();
  switch (a?.type) {
    case "login":
      handleLogin(a.username, a.password);
      break;
    case "logout":
      handleLogout();
      break;
    case "refresh":
      refreshData();
      break;
  }
});

// Dispatch actions - triggers even with same value!
action.set({ type: "refresh" });
action.set({ type: "refresh" }); // Triggers again!
```

**Using `.tuple` for cleaner action dispatch:**

```tsx
type TodoAction = { type: "add"; text: string } | { type: "edit"; id: number };

// .tuple gives [signal, setter] with semantic naming
const [todoAction, dispatch] = signal<TodoAction>().tuple;

// React using .when()
todoList.when(todoAction, (action) => {
  const a = action();
  if (a.type === "add") addTodo(a.text);
  if (a.type === "edit") editTodo(a.id);
});

// Dispatch with semantic setter
dispatch({ type: "add", text: "Buy milk" });
```

**Key difference from regular signals:**

```tsx
// Regular signal - same value = NO trigger
const count = signal(0);
count.set(1); // triggers
count.set(1); // NO trigger (same value)

// Empty signal (notifier) - always triggers
const notifier = signal<number>();
notifier.set(1); // triggers
notifier.set(1); // triggers again!
```

**Works great with `refreshOn`/`staleOn`:**

```tsx
const refreshTrigger = signal<void>();
const invalidateCache = signal<void>();

const userData = asyncSignal.pipe(
  refreshOn(refreshTrigger), // Manual refresh
  staleOn(invalidateCache) // Cache invalidation
);

// Trigger refresh
refreshTrigger.set(undefined as void);
```

---

## ğŸš¨ Critical Rules

### âœ… Always Do These

1. **Declare dependencies explicitly**

```tsx
// âœ… GOOD
signal({ a, b }, ({ deps }) => deps.a + deps.b);

// âŒ BAD - won't work!
signal(() => a() + b());
```

2. **Use `abortSignal` for queries**

```tsx
// âœ… GOOD - Cancels previous request
signal({ searchTerm }, async ({ deps, abortSignal }) => {
  return fetch(`/search?q=${deps.searchTerm}`, { signal: abortSignal });
});
```

3. **Signals in `useScope`/`rx.use` are auto-disposed**

```tsx
// âœ… GOOD - Signals auto-dispose on unmount (no wrapper needed!)
useScope(() => {
  const count = signal(0);
  const doubled = count.to((x) => x * 2);
  return { count, doubled };
});

// âœ… Also GOOD - Add dispose() method for additional cleanup
useScope(() => {
  const count = signal(0);
  const subscription = someService.subscribe();
  return {
    count,
    dispose: () => subscription.unsubscribe(),
  };
});

// âœ… Use disposable() to combine multiple cleanup logic
useScope(() =>
  disposable({
    count: signal(0),
    dispose: [sub1, sub2, () => clearInterval(timer)],
  })
);
```

4. **Use `.to()` for single-signal transforms**

```tsx
// âœ… GOOD - cleaner
const doubled = count.to((x) => x * 2);

// âœ… Also valid but verbose
const doubled = signal({ count }, ({ deps }) => deps.count * 2);
```

5. **Use `Logic` postfix for logic names**

```tsx
// âœ… GOOD
export const authLogic = logic("authLogic", () => { ... });

// âŒ BAD
export const auth = logic("auth", () => { ... });
```

6. **Use `$` prefix for logic instances**

```tsx
// âœ… GOOD
const $auth = authLogic();
const $cart = cartLogic();

// âŒ BAD
const auth = authLogic();
const cart = cartLogic();
```

### âŒ Never Do These

1. **Never try auto-tracking**

```tsx
// âŒ Won't work
const doubled = signal(() => count() * 2);
```

2. **Never pass Promises directly**

```tsx
// âŒ Wrong
const data = signal(Promise.resolve(42));

// âœ… Correct
const data = signal(async () => 42);
```

3. **Never use `abortSignal` for mutations**

```tsx
// âŒ Bad - mutations should complete
signal({ payload }, async ({ deps, abortSignal }) => {
  return fetch("/api", { method: "POST", signal: abortSignal });
});

// âœ… Good
signal({ payload }, async ({ deps }) => {
  return fetch("/api", { method: "POST" });
});
```

4. **Never create signals in render without useScope**

```tsx
function Component() {
  // âŒ Bad - memory leak
  const count = signal(0);

  // âœ… Good - signals are auto-disposed on unmount
  const { count } = useScope(() => ({ count: signal(0) }));
}
```

5. **Never use `rx()` in attributes**

```tsx
// âŒ Bad
<input value={rx(signal)} />;

// âœ… Good
{
  rx(() => <input value={signal()} />);
}
{
  rx("input", { value: signal });
}
```

---

## ğŸ“š Complete API Reference

### Signal Methods

- `signal()` - Empty signal
- `signal(value)` - With initial value
- `signal(value, equals)` - With equality strategy
- `signal(value, options)` - With full options
- `signal(deps, compute)` - Computed signal
- `signal(deps, compute, equals)` - Computed with equality
- `signal(deps, compute, options)` - Computed with options
- `.uid` - Unique ID (auto-generated, immutable) â­
- `.displayName` - Debug name for devtools
- `.set(value)` - Update (mutable only)
- `.get()` or `()` - Read value (triggers tracking)
- `.peek()` - Read value without tracking â­
- `.on(listener)` - Subscribe
- `.dispose()` - Cleanup
- `.reset()` - Reset to initial (mutable only)
- `.to(fn, equals?)` - Transform (creates computed) â­
- `.pipe(...operators)` - Chain operators â­
- `.refresh()` - Force recomputation â­
- `.stale()` - Mark stale â­
- `.error()` - Get error safely â­
- `.tryGet()` - Get value safely â­
- `.pause()` / `.resume()` / `.paused()` - Control (computed only)
- `.when(notifier, action, filter?)` - React to other signals with action string â­
- `.when(notifier, callback)` - React to other signals with action callback `(notifier, self) => void` â­
- `.tuple` - Get `[signal, setter]` tuple for semantic naming

### Static Methods

- `signal.batch(fn)` - Batch updates
- `signal.on(signals, callback)` - Subscribe to multiple
- `signal.tag()` - Create tag for grouping
- `signal.from(signals)` - Combine signals
- `signal.trace(error)` - Error tracing â­

### Wait Methods

- `wait()` / `wait.all()` - Wait for all
- `wait.any()` - First to resolve
- `wait.race()` - First to settle
- `wait.settled()` - All settled (never throws)
- `wait.timeout()` - With timeout
- `wait.delay()` - Simple delay

### Task Methods

- `task.from(promise)` - Get loading/error/success state from Promise
- `task.loading()` - Create loading state
- `task.success(value)` - Create success state
- `task.error(error)` - Create error state

### React Hooks

- `rx()` - Reactive rendering (4 overloads)
- `rx.use()` - Reactive hook â­
- `useScope()` - Lifecycle & scoped state (3 overloads)
- `provider()` - Signal context â­

### Operators (`rextive/op`) â­

- `to(fn, equals?)` - Transform
- `filter(predicate)` - Filter
- `scan(fn, initial)` - Accumulate
- `focus(path, options?)` - Bidirectional lens (returns Mutable)
- `focus(path, fallback, options?)` - With fallback (non-nullable)
- `debounce(ms)` - Debounce
- `throttle(ms)` - Throttle
- `pace(ms)` - Rate limit
- `task(initial, options?)` - Async state with stale-while-revalidate
- `refreshOn(notifier, filter?)` - Trigger immediate recomputation
- `staleOn(notifier, filter?)` - Mark for lazy recomputation
- `resetOn(notifier, filter?)` - Reset mutable signal to initial value

### Plugins (`rextive/plugins`) â­

- `persistor(options)` - Auto-persistence

### Type Guards

- `is(value)` - Check if value is any Signal
- `is(value, "mutable")` - Check if mutable signal
- `is(value, "computed")` - Check if computed signal
- `is(value, "task")` - Check if Task
- `is(value, "tag")` - Check if Tag
- `is(value, "accessor")` - Check if Accessor (function with on)
- `is(value, "observable")` - Check if Observable (object with on)

### Utilities

- `disposable(obj)` - Create disposable â­
- `awaited(...selectors)` - Transform async â­
- `emitter()` - Event emitter

---

## ğŸ”§ Internal Architecture

### Hooks System (`src/hooks.ts`)

The hooks system provides centralized integration points for render tracking and devtools.

#### Render Hooks (for `rx()` auto-tracking)

```tsx
import { RenderHooks, getRenderHooks, withRenderHooks } from "./hooks";

// RenderHooks interface
interface RenderHooks {
  onSignalAccess: (signal: AnySignal<any>) => void;
  onTaskAccess: (task: Task<any>) => void;
}

// Get current render hooks
const hooks = getRenderHooks();

// Execute with custom render hooks (used by rx())
withRenderHooks(
  {
    onSignalAccess: (signal) => accessedSignals.add(signal),
  },
  () => {
    return renderFn();
  }
);
```

#### DevTools Hooks (for monitoring)

```tsx
import { DevToolsHooks, setDevToolsHooks, hasDevTools, emit } from "./hooks";

// DevToolsHooks interface
interface DevToolsHooks {
  onSignalCreate: (signal: SignalRef) => void;
  onSignalChange: (signal: SignalRef, value: unknown) => void;
  onSignalError: (signal: SignalRef, error: unknown) => void;
  onSignalDispose: (signal: SignalRef) => void;
  onSignalRename: (signal: SignalRef) => void;
  onTagCreate: (tag: TagRef) => void;
  onTagAdd: (tag: TagRef, signal: AnySignal<any>) => void;
  onTagRemove: (tag: TagRef, signal: AnySignal<any>) => void;
}

// Register devtools hooks (called by enableDevTools)
setDevToolsHooks({
  onSignalCreate: (signal) => {
    /* track */
  },
  onSignalChange: (signal, value) => {
    /* log */
  },
});

// Emit events from core code
emit.signalCreate(signalRef);
emit.signalChange(signalRef, newValue);
emit.signalError(signalRef, error);
```

#### Migration from `contextDispatcher.ts`

| Old (Removed)                     | New                           |
| --------------------------------- | ----------------------------- |
| `contextDispatcher.ts`            | `hooks.ts`                    |
| `ContextDispatcher`               | `RenderHooks`                 |
| `getCurrent()`                    | `getRenderHooks()`            |
| `withDispatcher()`                | `withRenderHooks()`           |
| `trackSignal()`                   | `onSignalAccess()`            |
| `trackTask()`                     | `onTaskAccess()`              |
| `globalThis.__REXTIVE_DEVTOOLS__` | `setDevToolsHooks()` + `emit` |

---

## Summary

**Core Principles:**

1. âœ… **Explicit dependencies** - Always declare what signals depend on
2. âœ… **Lazy tracking** - Only subscribe to what you access
3. âœ… **Use `.to()` for single transforms** - Cleaner than computed signals
4. âœ… **Use `disposable()` for cleanup** - Automatic disposal
5. âœ… **Unified API** - One `signal()` function for everything
6. âŒ **No auto-tracking** - Dependencies must be explicit
7. âŒ **No magic** - Clear, predictable behavior

**Remember:**

- Use `.to()` for single-signal transforms
- Use `signal({ deps }, compute)` for multi-signal
- Signals in `useScope()`/`rx.use()` are auto-disposed on unmount
- Add `dispose()` method for single cleanup, use `disposable()` to combine multiple
- Use `rx()` for reactive rendering
- Use `wait()` for Suspense-based async handling
- Use `task.from()` for manual loading states
- Use `abortSignal` for queries, not mutations
- Import from `rextive/react` in React apps

**Logic Conventions:**

- Always use `Logic` postfix: `authLogic`, `cartLogic`, `checkoutLogic`
- Logic file names: `authLogic.ts`, `cartLogic.ts`
- Use `$` prefix when consuming: `const $auth = authLogic()`
- No `$` prefix when destructuring: `const { user, logout } = authLogic()`
- Split complex logic by concern (e.g., `checkout/shippingLogic.ts`, `checkout/paymentLogic.ts`)
- Follow Logic Structure: Dependencies â†’ State â†’ Side Effects â†’ Methods â†’ Return

**Testing Conventions:**

- Use `mockLogic()` from `rextive/test` for React component testing
- Use `logic.provide()` + `logic.create()` for logic unit tests
- Always call `logic.clear()` or `$mock.clear()` in `afterEach`
- Get dependencies at factory level, not inside methods
