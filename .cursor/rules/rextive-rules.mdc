---
alwaysApply: true
---

# Rextive Framework Rules

A signal-based reactive state management library with explicit dependencies.

## Table of Contents

1. [Core Philosophy](#-core-philosophy)
2. [Package Structure](#-package-structure)
3. [Quick Reference](#-quick-reference)
4. [Signal API](#-signal-api)
5. [React Integration](#-react-integration)
6. [Operators](#-operators)
7. [Async Utilities](#-async-utilities)
8. [Logic System](#-logic-system)
9. [Plugins & Extensions](#-plugins--extensions)
10. [Naming Conventions](#-naming-conventions)
11. [Critical Rules](#-critical-rules)
12. [Internal Architecture](#-internal-architecture)

---

## üéØ Core Philosophy

- **One unified primitive**: `signal()` for all reactive needs (state, computed, async)
- **Explicit dependencies**: Dependencies are always declared, never auto-tracked
- **Framework agnostic**: Works in vanilla JS, React, or any environment
- **Lazy tracking**: Only subscribes to signals that are actually accessed
- **Unified sync/async**: Same API handles both synchronous and asynchronous values

---

## üì¶ Package Structure

```
rextive           Core signals (works anywhere)
rextive/react     React bindings (rx, useScope, provider)
rextive/op        Operators (to, filter, scan, debounce, throttle, etc.)
rextive/immer     Immer integration for immutable updates
rextive/cache     Data caching with strategies
rextive/plugins   Plugins (persistor)
rextive/devtools  DevTools integration
rextive/test      Testing utilities (mockLogic)
```

---

## üìã Quick Reference

### Signal Creation Patterns

```tsx
// Mutable signals
const count = signal(0);                    // Simple value
const user = signal({ name: "John" });      // Object
const items = signal<Item[]>([]);           // Typed array
const selected = signal<User>();            // Empty (notifier pattern)

// Computed signals (explicit deps)
const doubled = signal({ count }, ({ deps }) => deps.count * 2);
const fullName = signal({ firstName, lastName }, ({ deps }) => 
  `${deps.firstName} ${deps.lastName}`
);

// Single dependency transform (shorthand)
const doubled = count.to(x => x * 2);

// Async computed
const userData = signal({ userId }, async ({ deps, abortSignal }) => {
  const res = await fetch(`/api/users/${deps.userId}`, { signal: abortSignal });
  return res.json();
});
```

### React Patterns

```tsx
// Reactive rendering
{rx(count)}                              // Direct value
{rx(user, "name")}                       // Property access
{rx(user, u => u.age + 5)}               // Selector
{rx(() => <div>{count()}</div>)}         // Reactive function
{rx("div", { children: count })}         // Component form

// Scoped state (auto-disposed)
const { input, results } = useScope(() => ({
  input: signal(""),
  results: signal([]),
}));

// Async state
rx(() => {
  const state = task.from(userData());
  if (state.loading) return <Spinner />;
  if (state.error) return <Error error={state.error} />;
  return <div>{state.value.name}</div>;
});
```

### Key Methods

| Method | Description |
|--------|-------------|
| `signal()` / `.get()` | Read value (triggers tracking in rx) |
| `.peek()` | Read without tracking |
| `.set(value)` | Update value (mutable only) |
| `.reset()` | Reset to initial (mutable only) |
| `.on(fn)` | Subscribe to changes |
| `.to(fn)` | Transform (creates computed) |
| `.pipe(...ops)` | Chain operators |
| `.dispose()` | Clean up signal |
| `.refresh()` | Force recomputation |
| `.stale()` | Mark for lazy recomputation |
| `.when(notifier, action)` | React to other signals |

---

## üì¶ Signal API

### 1. Creating Signals

#### Empty Signal (Notifier Pattern)

```tsx
const user = signal<User>();
```

- Returns `User | undefined` on read
- `.set()` requires `User` (not undefined)
- **Always triggers** on set, even with same value

#### Mutable Signal with Value

```tsx
const count = signal(0);
const user = signal({ name: "John" }, "shallow");  // Equality shortcut
const data = signal(complexObj, { 
  equals: "deep",
  name: "appData",
  onChange: (v) => console.log(v)
});
```

**Equality strategies:** `"strict"` (default), `"shallow"`, `"deep"`

#### Computed Signal

```tsx
const doubled = signal({ count }, ({ deps }) => deps.count * 2);

// With options
const result = signal({ a, b }, ({ deps }) => deps.a + deps.b, {
  name: "result",
  equals: "shallow",
  lazy: false,  // Compute immediately
});
```

#### Async Computed

```tsx
const userData = signal({ userId }, async ({ deps, abortSignal }) => {
  const res = await fetch(`/users/${deps.userId}`, { signal: abortSignal });
  return res.json();
});
```

### 2. Signal Options

```tsx
interface SignalOptions<T> {
  equals?: "strict" | "shallow" | "deep" | ((a: T, b: T) => boolean);
  name?: string;
  fallback?: (error: unknown) => T;
  onError?: (error: unknown) => void;
  onChange?: (value: T) => void;
  lazy?: boolean;
  use?: readonly (Tag<T> | Plugin<T>)[];
}
```

### 3. Instance Properties & Methods

```tsx
// Properties
signal.uid          // Unique ID (auto-generated, immutable)
signal.displayName  // Debug name

// Reading
signal()            // Read value (triggers tracking)
signal.get()        // Same as signal()
signal.peek()       // Read without tracking
signal.tryGet()     // Get value or undefined (never throws)
signal.error()      // Get sync error without throwing

// Writing (mutable only)
signal.set(value)   // Update value
signal.set(prev => prev + 1)  // Update with function
signal.reset()      // Reset to initial value

// Subscribing
const unsub = signal.on(() => console.log(signal()))

// Transforming
const doubled = signal.to(x => x * 2, "shallow");
const result = signal.pipe(filter(x => x > 0), to(x => x * 2));

// Control (computed only)
signal.refresh()    // Force immediate recomputation
signal.stale()      // Mark for lazy recomputation
signal.pause()      // Stop recomputing
signal.resume()     // Resume recomputing
signal.paused()     // Check if paused

// Cleanup
signal.dispose()    // Clean up signal
```

### 4. Computed Context

```tsx
signal({ userId }, async (context) => {
  context.deps           // Dependency values
  context.abortSignal    // AbortSignal for cancellation
  context.nth            // Computation number (0, 1, 2...)
  
  context.safe(fn)       // Execute safely (throws if aborted)
  context.safe(promise)  // Safe promise (never resolves if aborted)
  context.aborted()      // Check if aborted
  context.onCleanup(fn)  // Register cleanup callback
  context.use(fn, args)  // Reuse logic with context
  context.refresh()      // Schedule recomputation
  context.stale()        // Mark stale
});
```

### 5. Static Methods

```tsx
// Batch updates (single notification)
signal.batch(() => {
  firstName.set("Jane");
  lastName.set("Smith");
});

// Subscribe to multiple signals
const control = signal.on([count, name], (trigger) => {
  console.log("Changed:", trigger());
});
control.pause();
control.resume();
control.dispose();

// Create tag for grouping
const formTag = signal.tag();
const name = signal("", { use: [formTag] });
formTag.forEach(s => s.reset());

// Combine signals
const user = signal.from({ name, age });  // Record
const coords = signal.from([x, y]);       // Tuple

// Error tracing
const traces = signal.trace(error);
```

### 6. `.when()` - Reactive Triggers

```tsx
// Action string
userData.when(refreshTrigger, "refresh");  // Force recomputation
userData.when(resetTrigger, "reset");      // Reset (mutable only)
userData.when(cacheInvalidate, "stale");   // Mark stale

// With filter
userData.when(trigger, "refresh", (notifier, self) => notifier() > 5);

// Action callback
counter.when(increment, (notifier, self) => {
  self.set(prev => prev + notifier());
});

// Multiple notifiers
userData.when([trigger1, trigger2], "refresh");

// Chaining
userData.when(refreshTrigger, "refresh").when(resetTrigger, "reset");
```

---

## ‚öõÔ∏è React Integration

### `rx()` - Reactive Rendering

```tsx
// Direct signal value
{rx(count)}                    // Renders: 42

// Property access
{rx(user, "name")}             // Renders: "Alice"

// Selector function
{rx(user, u => u.age + 5)}     // Renders: 35

// Reactive function (auto-tracking)
{rx(() => <div>Count: {count()}</div>)}

// Component with reactive props
{rx(Component, { prop1: signal1, prop2: "static" })}
{rx("div", { children: count, className: "counter" })}
```

**‚ö†Ô∏è Never use rx() in attributes!**

```tsx
// ‚ùå WRONG
<input value={rx(signal)} />

// ‚úÖ CORRECT
{rx(() => <input value={signal()} />)}
{rx("input", { value: signal })}
```

### `rx.use()` - Reactive Hook

```tsx
function Component() {
  const value = rx.use(() => {
    const userData = wait(user());
    const postList = wait(posts());
    return { userData, postList };
  });
  return <div>{value.userData.name}</div>;
}
```

### `useScope()` - Scoped State Management

**Local Mode** (each component gets own scope):

```tsx
// Basic
const { count, doubled } = useScope(() => ({
  count: signal(0),
  doubled: count.to(x => x * 2),
}));

// With deps
const { user } = useScope(
  (id) => ({ user: signal(async () => fetchUser(id)) }),
  [userId]
);

// With logic
const { count, increment } = useScope(counterLogic);
```

**Shared Mode** (multiple components share scope):

```tsx
const { input } = useScope("searchBar", searchBarLogic);
const { content } = useScope(`tab:${tabId}`, () => ({
  content: signal(""),
}));
```

**Features:**
- Auto-dispose on unmount
- Deps comparison (recreates scope when deps change)
- StrictMode safe
- Logic support

### `useStable()` - Stable References

```tsx
const stable = useStable<{
  onClick: () => void;
  config: { theme: string };
}>();

// Single key-value
const onClick = stable("onClick", () => handleClick());
const config = stable("config", { theme: "dark" }, "shallow");

// Partial object
const handlers = stable({
  onSubmit: () => submitForm(),
  onCancel: () => cancelForm(),
});
```

### `provider()` - Signal Context

```tsx
// Signal mode (default)
const [useTheme, ThemeProvider] = provider<"dark" | "light">({ name: "Theme" });

// Raw mode (for logic instances)
const [useProduct, ProductProvider] = provider<ProductInstance>({ 
  name: "Product", 
  raw: true 
});

// Factory mode
const [useAuth, AuthProvider] = provider<AuthContext, User | null>({
  name: "Auth",
  create: (user) => ({ user: signal(user), login: async () => {} }),
  update: (ctx, value) => ctx.user.set(value)
});
```

---

## üîß Operators

Import from `rextive/op`:

```tsx
import { to, filter, scan, focus, debounce, throttle, task } from "rextive/op";
```

### Transform Operators

```tsx
// to() - Transform values
const doubled = count.pipe(to(x => x * 2));

// filter() - Filter values
const positiveOnly = count.pipe(filter(x => x > 0));

// scan() - Accumulate values
const total = count.pipe(scan((acc, curr) => acc + curr, 0));

// distinct() - Filter duplicates
const unique = count.pipe(distinct());           // Consecutive mode
const allUnique = count.pipe(distinct({ mode: "all" }));
```

### Focus Operator (Bidirectional Lens)

```tsx
// Basic path access
const userName = form.pipe(focus("user.name"));
userName.set("Bob");  // Updates source immutably

// With fallback
const nickname = user.pipe(focus("nickname", () => "Guest"));

// With options
const price = form.pipe(focus("price", {
  get: v => v * 1.1,    // Transform on read
  set: v => v / 1.1,    // Transform on write
}));

// Lightweight lens (no signal created)
const [getName, setName] = focus.lens(form, "user.name");
```

### Timing Operators

```tsx
// debounce() - Wait for pause in changes
const debouncedSearch = searchInput.pipe(debounce(300));

// throttle() - Limit update frequency
const throttledPosition = mousePosition.pipe(throttle(100));

// pace() - Rate limit updates
const pacedData = fastData.pipe(pace(1000));

// delay() - Delay emissions
const delayed = source.pipe(delay(500));
```

### Flow Control Operators

```tsx
// take() - Take first N emissions
const first3 = source.pipe(take(3));

// takeWhile() - Take while predicate is true
const whilePositive = source.pipe(takeWhile(x => x > 0));

// takeUntil() - Take until notifier emits
const untilClick = source.pipe(takeUntil(clickSignal));

// skip() - Skip first N emissions
const afterFirst3 = source.pipe(skip(3));

// skipWhile() - Skip while predicate is true
const afterNegatives = source.pipe(skipWhile(x => x < 0));

// skipUntil() - Skip until notifier emits
const afterStart = source.pipe(skipUntil(startSignal));
```

### Math Operators

```tsx
// min() / max() - Track minimum/maximum
const minimum = source.pipe(min());
const maximum = source.pipe(max());

// count() - Count emissions
const emissions = source.pipe(count());
```

### Reactive Trigger Operators

```tsx
// refreshOn() - Trigger immediate recomputation
const userData = asyncSignal.pipe(refreshOn(refreshTrigger));

// staleOn() - Mark for lazy recomputation
const cachedData = asyncSignal.pipe(staleOn(cacheInvalidate));

// resetOn() - Reset mutable signal to initial value
const formData = signal({ name: "" }).pipe(resetOn(clearTrigger));
```

### Task Operator (Stale-While-Revalidate)

```tsx
import { task } from "rextive/op";

const userProfile = signal(async () => fetchUser());
const userTask = userProfile.pipe(task({ name: "Guest" }));

// value is ALWAYS defined
rx(() => {
  const { loading, error, value } = userTask();
  return (
    <div>
      {loading && <Spinner />}
      <h2>{value.name}</h2>  {/* Safe - never undefined */}
    </div>
  );
});
```

---

## ‚è≥ Async Utilities

### `task.from()` - Access Async State

```tsx
const promise = asyncSignal();
const state = task.from(promise);

state.status  // "loading" | "success" | "error"
state.loading // boolean
state.value   // resolved value
state.error   // error if rejected
```

### `task` Factory Methods

```tsx
task.loading(promise)    // Create loading state
task.success(value)      // Create success state
task.error(error)        // Create error state
```

### `wait()` - Suspense Integration

```tsx
// Single value
const value = wait(promise);

// Multiple (parallel)
const [a, b] = wait([p1, p2]);
const { user, posts } = wait({ user: p1, posts: p2 });

// First to resolve
const [value, key] = wait.any({ fast, slow });

// First to settle
const [value, key] = wait.race({ p1, p2 });

// All settled (never throws)
const results = wait.settled([p1, p2, p3]);

// With timeout
const data = await wait.timeout(fetchData(), 5000);

// Delay
await wait.delay(1000);
```

---

## üß† Logic System

### Creating Logic

```tsx
export const counterLogic = logic("counterLogic", () => {
  // 1. DEPENDENCIES
  const $auth = authLogic();
  
  // 2. STATE
  const count = signal(0, { name: "counter.count" });
  const doubled = count.to(x => x * 2);
  
  // 3. SIDE EFFECTS
  $auth.user.on(() => {
    if (!$auth.user()) count.reset();
  });
  
  // 4. METHODS
  const increment = () => count.set(x => x + 1);
  const decrement = () => count.set(x => x - 1);
  
  // 5. RETURN
  return {
    count,
    doubled,
    increment,
    decrement,
  };
});
```

### Using Logic

```tsx
// In React components
const $counter = counterLogic();
const { count, increment } = useScope(counterLogic);

// As singleton
const $auth = authLogic();  // Same instance everywhere
```

### Testing Logic

```tsx
import { mockLogic } from "rextive/test";

describe("UserMenu", () => {
  const $auth = mockLogic(authLogic);
  
  beforeEach(() => {
    $auth.default({
      user: signal(null),
      logout: vi.fn(),
    });
  });
  
  afterEach(() => $auth.clear());
  
  it("should show Sign In when not authenticated", () => {
    $auth.provide({ user: signal(null) });
    render(<UserMenu />);
    expect(screen.getByText("Sign In")).toBeInTheDocument();
  });
});
```

---

## üîå Plugins & Extensions

### Persistor Plugin

```tsx
import { persistor } from "rextive/plugins";

const persist = persistor<{ theme: string; fontSize: number }>({
  load: () => JSON.parse(localStorage.getItem("settings") || "{}"),
  save: (args) => {
    const existing = JSON.parse(localStorage.getItem("settings") || "{}");
    localStorage.setItem("settings", JSON.stringify({ ...existing, ...args.values }));
  },
});

const theme = signal("dark", { use: [persist("theme")] });
```

### Immer Integration

```tsx
import { produce } from "rextive/immer";

const state = signal({ count: 0, user: { name: "John" } });

state.set(produce((draft) => {
  draft.count++;
  draft.user.name = "Jane";
}));
```

### DevTools

```tsx
import { enableDevTools, DevToolsPanel } from "rextive/devtools";

enableDevTools();

function App() {
  return (
    <div>
      <YourApp />
      {process.env.NODE_ENV === "development" && <DevToolsPanel />}
    </div>
  );
}
```

---

## üè∑Ô∏è Naming Conventions

### Signal Naming

| Type | Postfix | Example |
|------|---------|---------|
| Primitive | None | `count`, `filter`, `selectedId` |
| Boolean | `is`/`has` prefix | `isOpen`, `isLoading`, `hasError` |
| Async | None | `user`, `products` |
| Task-wrapped | `Task` | `userTask`, `productsTask` |

### Logic Naming

```tsx
// Definition: Logic postfix
export const authLogic = logic("authLogic", () => { ... });

// File: Logic postfix
// src/logic/authLogic.ts

// Consumer: $ prefix
const $auth = authLogic();
const $cart = cartLogic();

// Destructuring: no prefix
const { user, logout } = authLogic();
```

### Action Naming

```tsx
// Dispatcher: verb name
export const login = loginAction.dispatch;
export const addToCart = cartAction.dispatch;

// Result (if needed): Result postfix
export const loginResult = loginAction.result;
export const loginResultTask = loginAction.result.pipe(task(null));
```

---

## üö® Critical Rules

### ‚úÖ Always Do

1. **Declare dependencies explicitly**
   ```tsx
   // ‚úÖ GOOD
   signal({ a, b }, ({ deps }) => deps.a + deps.b);
   
   // ‚ùå BAD - won't work!
   signal(() => a() + b());
   ```

2. **Use `abortSignal` for queries**
   ```tsx
   signal({ searchTerm }, async ({ deps, abortSignal }) => {
     return fetch(`/search?q=${deps.searchTerm}`, { signal: abortSignal });
   });
   ```

3. **Use `useScope` for signals in components**
   ```tsx
   const { count } = useScope(() => ({ count: signal(0) }));
   ```

4. **Use `.to()` for single transforms**
   ```tsx
   const doubled = count.to(x => x * 2);
   ```

5. **Use `Logic` postfix and `$` prefix**
   ```tsx
   export const authLogic = logic("authLogic", () => { ... });
   const $auth = authLogic();
   ```

### ‚ùå Never Do

1. **Never try auto-tracking**
   ```tsx
   // ‚ùå Won't work
   const doubled = signal(() => count() * 2);
   ```

2. **Never pass Promises directly**
   ```tsx
   // ‚ùå Wrong
   const data = signal(Promise.resolve(42));
   
   // ‚úÖ Correct
   const data = signal(async () => 42);
   ```

3. **Never use `abortSignal` for mutations**
   ```tsx
   // ‚ùå Bad - mutations should complete
   signal({ payload }, async ({ deps, abortSignal }) => {
     return fetch("/api", { method: "POST", signal: abortSignal });
   });
   ```

4. **Never create signals in render without useScope**
   ```tsx
   function Component() {
     // ‚ùå Bad - memory leak
     const count = signal(0);
     
     // ‚úÖ Good
     const { count } = useScope(() => ({ count: signal(0) }));
   }
   ```

5. **Never use `rx()` in attributes**
   ```tsx
   // ‚ùå Bad
   <input value={rx(signal)} />
   
   // ‚úÖ Good
   {rx(() => <input value={signal()} />)}
   ```

---

## üîß Internal Architecture

### Unified Hooks System (`src/hooks.ts`)

The hooks system provides centralized integration for:
- Render-time tracking (scoped via `withHooks`)
- DevTools/monitoring (global via `setHooks`)

```tsx
import { getHooks, setHooks, withHooks, resetHooks, emit } from "./hooks";
```

#### Hooks Interface

```tsx
interface Hooks {
  // Render-time tracking (scoped via withHooks)
  onSignalAccess: (signal: AnySignal<any>) => void;
  onTaskAccess: (task: Task<any>) => void;
  
  // Lifecycle monitoring (global via setHooks)
  onSignalCreate?: (signal: AnySignal<any>, deps?: SignalMap, disposalHandled?: boolean) => void;
  onSignalChange?: (signal: AnySignal<any>, value: unknown) => void;
  onSignalError?: (signal: AnySignal<any>, error: unknown) => void;
  onSignalDispose?: (signal: AnySignal<any>) => void;
  onSignalRename?: (signal: AnySignal<any>) => void;
  onForgetSignals?: (signals: AnySignal<any>[]) => void;
  onTagCreate?: (tag: Tag<any, any>) => void;
  onTagAdd?: (tag: Tag<any, any>, signal: AnySignal<any>) => void;
  onTagRemove?: (tag: Tag<any, any>, signal: AnySignal<any>) => void;
  
  // Utility
  hasDevTools: () => boolean;
}
```

#### Hook Functions

```tsx
// Get current hooks
const hooks = getHooks();

// Set/merge global hooks
setHooks({ onSignalCreate: (signal) => console.log(signal) });
setHooks((current) => ({ ...current, onSignalChange: () => {} }));

// Temporarily override hooks
withHooks({ onSignalAccess: (s) => tracked.add(s) }, () => {
  return renderFn();
});

// Reset to defaults
resetHooks();
```

#### Emit Helpers

```tsx
emit.signalCreate(signal, deps);
emit.signalChange(signal, value);
emit.signalError(signal, error);
emit.signalDispose(signal);
emit.signalRename(signal);
emit.tagCreate(tag);
emit.tagAdd(tag, signal);
emit.tagRemove(tag, signal);

// For StrictMode orphan cleanup
emit.forgetDisposedSignals(() => {
  tryDispose(orphanedScope);
});
```

#### Legacy Exports (Deprecated)

```tsx
// Use getHooks() instead
getRenderHooks()

// Use withHooks() instead
withRenderHooks(hooks, fn)

// Use setHooks() or resetHooks() instead
setDevToolsHooks(hooks)

// Use getHooks().hasDevTools() instead
hasDevTools()
```

### Type Guards

```tsx
import { is } from "rextive";

is(value)              // Any Signal
is(value, "mutable")   // Mutable signal
is(value, "computed")  // Computed signal
is(value, "task")      // Task
is(value, "tag")       // Tag
is(value, "accessor")  // Accessor (function with on)
is(value, "observable") // Observable (object with on)
```

---

## üìö Complete API Reference

### Core Exports (`rextive`)

```tsx
signal, $                    // Signal creation
task                         // Task utilities
wait, awaited                // Async utilities
logic                        // Logic system
emitter                      // Event emitter
disposable, wrapDispose      // Disposal utilities
is                           // Type guards
compose, dev, producer       // Utilities
validate                     // Validation helpers
```

### React Exports (`rextive/react`)

```tsx
// Re-exports all from rextive, plus:
rx                           // Reactive rendering
useScope                     // Scoped state
useStable                    // Stable references
provider                     // Context creation
```

### Operator Exports (`rextive/op`)

```tsx
// Transform
to, filter, scan, focus, lens

// Timing
debounce, throttle, pace, delay

// Flow control
take, takeWhile, takeLast, takeUntil
skip, skipWhile, skipLast, skipUntil

// Math
min, max, count, distinct

// Reactive triggers
refreshOn, staleOn, resetOn

// Async
task (operator version)
```

### Plugin Exports

```tsx
// rextive/plugins
persistor

// rextive/immer
produce

// rextive/devtools
enableDevTools, disableDevTools, DevToolsPanel
getSignals, getTags, getStats, onDevToolsEvent

// rextive/test
mockLogic

// rextive/cache
cache, staleOn, evictOn, lru
```
